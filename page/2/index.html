<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="pragma" content="no-cache">
  <meta http-equiv="cache-control" content="no-cache">
  <meta http-equiv="expires" content="0">
  
  <title>第 2 页 | tlhg&#39;s Blog|</title>
  <meta name="author" content="Heisenberg Lee">
  
  <meta name="description" content="学习记录。">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="tlhg&#39;s Blog|"/>

  
    <meta property="og:image" content=""/>
  

  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-70812759-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-70812759-1');
</script>






<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="tlhg's Blog|" type="application/atom+xml">
</head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">tlhg&#39;s Blog|</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class=""></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class=""></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/tags" title="All the tags.">
			  <i class=""></i>Tags
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class=""></i>About
			</a>
		  </li>
		  
		  <li>
			<a href="/atom.xml" title="Subscribe me.">
			  <i class=""></i>RSS
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 <div class="page-header logo">
  <h1>tlhg<span class="blink-fast">|</span></h1>
</div>

<div class="row page">

	
	<div class="col-md-9">
	

		<div class="slogan">


		<i class="fa fa-heart blink-slow"></i>

		wubba lubba dub dub.

</div>    

		<div id="top_search"></div>
		<div class="mypage">
		
		<!-- title and entry -->
		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/posts/7060.html" >VS Code edit background</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2020-05-29  </div>
		</div>
	</div>
	


			<!--
<div class="entry">
  <div class="row">
	
	
		<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1>
<p>  今天用VS Code 写代码，感觉背景有点单调，所以决定美化一下（美名其曰美化，其实是偷偷摸鱼），网上大部分教程都是使用background插件来自定义vscode的背景图，这种方法需要在配置文件中配置一下，但是折腾完了发现这个方法不是很对我的胃口。</p>
<p>​	 这是在使用过程中出现的一些问题：</p>
<ol>
<li>在VS Code窗口右下角会有警告提示，虽然可以手动关闭，但是我不喜欢。</li>
<li>背景图只能覆盖代码区，左侧菜单区是不能覆盖的。</li>
<li>VS Code更新后，配置文件setting.json下修改的适应背景的配置代码会消失。</li>
</ol>
<p>  感兴趣的小伙伴可以去百度一下教程，我在这里就不在赘述了，这里着重介绍第二种方法：修改一下vscode的源css文件。</p>
<p>**ps：**background插件在删除的时候，会自动删除添加的样式（依赖node环境）。<br>
如果没有node环境，需要在 settings.json 中设置 {“background.enabled”: false} ，然后再删除插件。如果直接删除插件会有遗留，就需要重装vscode了。</p>
<p>这里先把效果图放一下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200529162132.png" alt></p>
<h1 id="如何实现"><a class="markdownIt-Anchor" href="#如何实现"></a> 如何实现</h1>
<ol>
<li>
<p>进入VS Code的源文件下面，找到 workbench.desktop.main.css 文件，文件地址  E:\Microsoft VS Code\resources\app\out\vs\workbench  （我的VS Code安装在E盘下）</p>
<p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/J(OZ_WI@QE67%7BAU)59~7RZW.png" alt="img"></p>
</li>
<li>
<p>任意的编译器打开workbench.desktop.main.css 文件，可以插入源代码中，也可以直接写在末尾位置，添加body{}，这一步也就是在css中写入配置文件，修改添加到背景的图片的相关信息，代码如下：</p>
<figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> {</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">11px</span>;</span><br><span class="line">  user-select: none;</span><br><span class="line">  <span class="attribute">pointer-events</span>: auto;</span><br><span class="line">  <span class="attribute">background-size</span>: cover;    //详见说明</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.75</span>;             //透明度修改，注意这里图片和代码文字都能会被透明度影响</span><br><span class="line">  <span class="attribute">background-position</span>: <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">"file:///F:/picture/wallpaper/cartoon/大姐姐.png"</span>);</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">99999</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ol>
	

	</div>
  <a type="button" href="/posts/7060.html#more" class="btn btn-default more">阅读此文</a>
</div>

-->
<div class="entry">
  <div class="row">
	
	
		<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1>
<p>  今天用VS Code 写代码，感觉背景有点单调，所以决定美化一下（美名其曰美化，其实是偷偷摸鱼），网上大部分教程都是使用background插件来自定义vscode的背景图，这种方法需要在配置文件中配置一下，但是折腾完了发现这个方法不是很对我的胃口。</p>
<p>​	 这是在使用过程中出现的一些问题：</p>
<ol>
<li>在VS Code窗口右下角会有警告提示，虽然可以手动关闭，但是我不喜欢。</li>
<li>背景图只能覆盖代码区，左侧菜单区是不能覆盖的。</li>
<li>VS Code更新后，配置文件setting.json下修改的适应背景的配置代码会消失。</li>
</ol>
<p>  感兴趣的小伙伴可以去百度一下教程，我在这里就不在赘述了，这里着重介绍第二种方法：修改一下vscode的源css文件。</p>
<p>**ps：**background插件在删除的时候，会自动删除添加的样式（依赖node环境）。<br>
如果没有node环境，需要在 settings.json 中设置 {“background.enabled”: false} ，然后再删除插件。如果直接删除插件会有遗留，就需要重装vscode了。</p>
<p>这里先把效果图放一下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200529162132.png" alt></p>
<h1 id="如何实现"><a class="markdownIt-Anchor" href="#如何实现"></a> 如何实现</h1>
<ol>
<li>
<p>进入VS Code的源文件下面，找到 workbench.desktop.main.css 文件，文件地址  E:\Microsoft VS Code\resources\app\out\vs\workbench  （我的VS Code安装在E盘下）</p>
<p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/J(OZ_WI@QE67%7BAU)59~7RZW.png" alt="img"></p>
</li>
<li>
<p>任意的编译器打开workbench.desktop.main.css 文件，可以插入源代码中，也可以直接写在末尾位置，添加body{}，这一步也就是在css中写入配置文件，修改添加到背景的图片的相关信息，代码如下：</p>
<figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> {</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">11px</span>;</span><br><span class="line">  user-select: none;</span><br><span class="line">  <span class="attribute">pointer-events</span>: auto;</span><br><span class="line">  <span class="attribute">background-size</span>: cover;    //详见说明</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.75</span>;             //透明度修改，注意这里图片和代码文字都能会被透明度影响</span><br><span class="line">  <span class="attribute">background-position</span>: <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">"file:///F:/picture/wallpaper/cartoon/大姐姐.png"</span>);</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">99999</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ol>
	
	</div>
  <a type="button" href="/posts/7060.html#more" class="btn btn-default more">阅读此文</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/posts/b01d.html" >Markdown grammer</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2020-05-19  </div>
		</div>
	</div>
	


			<!--
<div class="entry">
  <div class="row">
	
	
		<h2 id="正文"><a class="markdownIt-Anchor" href="#正文"></a> 正文</h2>
<h3 id="1-markdown是什么"><a class="markdownIt-Anchor" href="#1-markdown是什么"></a> 1. Markdown<em>是什么</em>？</h3>
<p><strong>Markdown</strong>是一种轻量级<strong>标记语言</strong>，它以纯文本形式(<em>易读、易写、易更改</em>)编写文档，并最终以HTML格式发布。<br>
<strong>Markdown</strong>也可以理解为将以MARKDOWN语法编写的语言转换成HTML内容的工具。</p>
<h3 id="2-为什么要使用它"><a class="markdownIt-Anchor" href="#2-为什么要使用它"></a> 2. <em>为什么</em>要使用它？</h3>
<ul>
<li>它是易读（看起来舒服）、易写（语法简单）、易更改<strong>纯文本</strong>。处处体现着<strong>极简主义</strong>的影子。</li>
<li>兼容HTML，可以转换为HTML格式发布。</li>
<li>跨平台使用。</li>
<li>越来越多的网站支持Markdown。</li>
<li>更方便清晰地组织你的电子邮件。（Markdown-here, Airmail）</li>
<li>摆脱Word（我不是认真的）。</li>
</ul>
<h3 id="3-怎么使用"><a class="markdownIt-Anchor" href="#3-怎么使用"></a> 3. <em>怎么</em>使用？</h3>
<p>如果不算<strong>扩展</strong>，Markdown的语法绝对<strong>简单</strong>到让你爱不释手。</p>
<p>Markdown语法主要分为如下几大部分： <strong>标题</strong>，<strong>段落</strong>，<strong>区块引用</strong>，<strong>代码区块</strong>，<strong>强调</strong>，<strong>列表</strong>，<strong>分割线</strong>，<strong>链接</strong>，<strong>图片</strong>，<strong>反斜杠 <code>\</code></strong>，<strong>符号’`’</strong>。</p>
<h4 id="31-标题"><a class="markdownIt-Anchor" href="#31-标题"></a> 3.1 标题</h4>
<p>两种形式：<br>
1）使用<code>=</code>和<code>-</code>标记一级和二级标题。</p>
	

	</div>
  <a type="button" href="/posts/b01d.html#more" class="btn btn-default more">阅读此文</a>
</div>

-->
<div class="entry">
  <div class="row">
	
	
		<h2 id="正文"><a class="markdownIt-Anchor" href="#正文"></a> 正文</h2>
<h3 id="1-markdown是什么"><a class="markdownIt-Anchor" href="#1-markdown是什么"></a> 1. Markdown<em>是什么</em>？</h3>
<p><strong>Markdown</strong>是一种轻量级<strong>标记语言</strong>，它以纯文本形式(<em>易读、易写、易更改</em>)编写文档，并最终以HTML格式发布。<br>
<strong>Markdown</strong>也可以理解为将以MARKDOWN语法编写的语言转换成HTML内容的工具。</p>
<h3 id="2-为什么要使用它"><a class="markdownIt-Anchor" href="#2-为什么要使用它"></a> 2. <em>为什么</em>要使用它？</h3>
<ul>
<li>它是易读（看起来舒服）、易写（语法简单）、易更改<strong>纯文本</strong>。处处体现着<strong>极简主义</strong>的影子。</li>
<li>兼容HTML，可以转换为HTML格式发布。</li>
<li>跨平台使用。</li>
<li>越来越多的网站支持Markdown。</li>
<li>更方便清晰地组织你的电子邮件。（Markdown-here, Airmail）</li>
<li>摆脱Word（我不是认真的）。</li>
</ul>
<h3 id="3-怎么使用"><a class="markdownIt-Anchor" href="#3-怎么使用"></a> 3. <em>怎么</em>使用？</h3>
<p>如果不算<strong>扩展</strong>，Markdown的语法绝对<strong>简单</strong>到让你爱不释手。</p>
<p>Markdown语法主要分为如下几大部分： <strong>标题</strong>，<strong>段落</strong>，<strong>区块引用</strong>，<strong>代码区块</strong>，<strong>强调</strong>，<strong>列表</strong>，<strong>分割线</strong>，<strong>链接</strong>，<strong>图片</strong>，<strong>反斜杠 <code>\</code></strong>，<strong>符号’`’</strong>。</p>
<h4 id="31-标题"><a class="markdownIt-Anchor" href="#31-标题"></a> 3.1 标题</h4>
<p>两种形式：<br>
1）使用<code>=</code>和<code>-</code>标记一级和二级标题。</p>
	
	</div>
  <a type="button" href="/posts/b01d.html#more" class="btn btn-default more">阅读此文</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/posts/702d.html" >Chapter08-IO库</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2020-05-12  </div>
		</div>
	</div>
	


			<!--
<div class="entry">
  <div class="row">
	
	
		<p>部分IO库设施：</p>
<ul>
<li><code>istream</code>：输入流类型，提供输入操作。</li>
<li><code>ostream</code>：输出流类型，提供输出操作。</li>
<li><code>cin</code>：<code>istream</code>对象，从标准输入读取数据。</li>
<li><code>cout</code>：<code>ostream</code>对象，向标准输出写入数据。</li>
<li><code>cerr</code>：<code>ostream</code>对象，向标准错误写入数据。</li>
<li><code>&gt;&gt;</code>运算符：从<code>istream</code>对象读取输入数据。</li>
<li><code>&lt;&lt;</code>运算符：向<code>ostream</code>对象写入输出数据。</li>
<li><code>getline</code>函数：从<code>istream</code>对象读取一行数据，写入<code>string</code>对象。</li>
</ul>
<h2 id="io类the-io-classes"><a class="markdownIt-Anchor" href="#io类the-io-classes"></a> IO类（The IO Classes）</h2>
<p>头文件<em>iostream</em>定义了用于读写流的基本类型，<em>fstream</em>定义了读写命名文件的类型，<em>sstream</em>定义了读写内存中<code>string</code>对象的类型。</p>
<p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200825174630.png" alt></p>
<p>宽字符版本的IO类型和函数的名字以<code>w</code>开始，如<code>wcin</code>、<code>wcout</code>和<code>wcerr</code>分别对应<code>cin</code>、<code>cout</code>和<code>cerr</code>。它们与其对应的普通<code>char</code>版本都定义在同一个头文件中，如头文件<em>fstream</em>定义了<code>ifstream</code>和<code>wifstream</code>类型。</p>
<p>可以将派生类的对象当作其基类的对象使用。</p>
<h3 id="io象无拷贝或赋值no-copy-or-assign-for-io-objects"><a class="markdownIt-Anchor" href="#io象无拷贝或赋值no-copy-or-assign-for-io-objects"></a> IO象无拷贝或赋值（No Copy or Assign for IO Objects）</h3>
<p>不能拷贝或对IO对象赋值。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">ofstream out1, out2;</span><br><span class="line">out1 = out2;    <span class="comment">// error: cannot assign stream objects</span></span><br><span class="line"><span class="function">ofstream <span class="title">print</span><span class="params">(ofstream)</span></span>;   <span class="comment">// error: can't initialize the ofstream parameter</span></span><br><span class="line">out2 = <span class="built_in">print</span>(out2);     <span class="comment">// error: cannot copy stream objects</span></span><br></pre></td></tr></tbody></table></figure>
	

	</div>
  <a type="button" href="/posts/702d.html#more" class="btn btn-default more">阅读此文</a>
</div>

-->
<div class="entry">
  <div class="row">
	
	
		<p>部分IO库设施：</p>
<ul>
<li><code>istream</code>：输入流类型，提供输入操作。</li>
<li><code>ostream</code>：输出流类型，提供输出操作。</li>
<li><code>cin</code>：<code>istream</code>对象，从标准输入读取数据。</li>
<li><code>cout</code>：<code>ostream</code>对象，向标准输出写入数据。</li>
<li><code>cerr</code>：<code>ostream</code>对象，向标准错误写入数据。</li>
<li><code>&gt;&gt;</code>运算符：从<code>istream</code>对象读取输入数据。</li>
<li><code>&lt;&lt;</code>运算符：向<code>ostream</code>对象写入输出数据。</li>
<li><code>getline</code>函数：从<code>istream</code>对象读取一行数据，写入<code>string</code>对象。</li>
</ul>
<h2 id="io类the-io-classes"><a class="markdownIt-Anchor" href="#io类the-io-classes"></a> IO类（The IO Classes）</h2>
<p>头文件<em>iostream</em>定义了用于读写流的基本类型，<em>fstream</em>定义了读写命名文件的类型，<em>sstream</em>定义了读写内存中<code>string</code>对象的类型。</p>
<p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200825174630.png" alt></p>
<p>宽字符版本的IO类型和函数的名字以<code>w</code>开始，如<code>wcin</code>、<code>wcout</code>和<code>wcerr</code>分别对应<code>cin</code>、<code>cout</code>和<code>cerr</code>。它们与其对应的普通<code>char</code>版本都定义在同一个头文件中，如头文件<em>fstream</em>定义了<code>ifstream</code>和<code>wifstream</code>类型。</p>
<p>可以将派生类的对象当作其基类的对象使用。</p>
<h3 id="io象无拷贝或赋值no-copy-or-assign-for-io-objects"><a class="markdownIt-Anchor" href="#io象无拷贝或赋值no-copy-or-assign-for-io-objects"></a> IO象无拷贝或赋值（No Copy or Assign for IO Objects）</h3>
<p>不能拷贝或对IO对象赋值。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">ofstream out1, out2;</span><br><span class="line">out1 = out2;    <span class="comment">// error: cannot assign stream objects</span></span><br><span class="line"><span class="function">ofstream <span class="title">print</span><span class="params">(ofstream)</span></span>;   <span class="comment">// error: can't initialize the ofstream parameter</span></span><br><span class="line">out2 = <span class="built_in">print</span>(out2);     <span class="comment">// error: cannot copy stream objects</span></span><br></pre></td></tr></tbody></table></figure>
	
	</div>
  <a type="button" href="/posts/702d.html#more" class="btn btn-default more">阅读此文</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/posts/fef1.html" >Hexo+github搭建博客</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2020-05-02  </div>
		</div>
	</div>
	


			<!--
<div class="entry">
  <div class="row">
	
	
		<p>转载此文章前，请先联系作者，经作者同意后再转载，并请注明原文链接和作者，整理这些不容易，最终版权归作者所有，谢谢合作！</p>
<p>你了解Hexo吗？ Hexo是一个静态博客框架，基于Node.js，将Markdown文章通过渲染引擎，生成一个静态网页，再结合Git命令（ssh），Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
<p>几个月前偶然间了解到了Hexo这个静态博客网站，很适合那些喜欢写作的朋友们，最重要的是它是免费的，里面有许多的博客主题模板，这些主题都是一些很牛的大佬们开发的，而且设计的主题都很棒，让我很心动，心动不如行动，于是开始整理搭建属于自己的博客。直到今天，这中间经历了许多的坎坷荆棘，我将我的博客搭建的流程分享出来，能为那些博客小石榴们提供一些帮助吧，如果有错的话，请给我留言，我会及时修改，废话不多说，直接上教程。</p>
<blockquote>
<p>如果下面的教程有错误之处，请在评论区留言，收到后，我会尽快修改，谢谢支持！</p>
</blockquote>
<h2 id="一-博客环境搭建"><a class="markdownIt-Anchor" href="#一-博客环境搭建"></a> 一、博客环境搭建</h2>
<blockquote>
<p>本文系统环境信息：Win10专业版，64位（10.0 版本18362）</p>
<p>Node.js：12.13.0 Git：2.24.0</p>
<p>修改配置文件要用到的软件（可选）：</p>
<ul>
<li>Visual Studio Code（适合有开发基础的程序员，非常好用）</li>
<li>Sublime Text3，可免费使用。</li>
<li>NodePad++ 7.8.1（最新的，也可以在官网选择其他版本）</li>
</ul>
</blockquote>
<h3 id="1下载git和nodejs"><a class="markdownIt-Anchor" href="#1下载git和nodejs"></a> 1.下载Git和Node.js</h3>
<h4 id="11-nodejs的安装与配置"><a class="markdownIt-Anchor" href="#11-nodejs的安装与配置"></a> 1.1 Node.js的安装与配置</h4>
<p>首先去<a target="_blank" rel="noopener" href="https://nodejs.org/en/download/">Node.js官网 </a>下载node.js的安装程序，根据你电脑系统的配置信息，下载对应的安装程序，然后开始进行下面的步骤。</p>
<p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200604161523.png" alt="Node.js下载以及版本的选择"></p>
	

	</div>
  <a type="button" href="/posts/fef1.html#more" class="btn btn-default more">阅读此文</a>
</div>

-->
<div class="entry">
  <div class="row">
	
	
		<p>转载此文章前，请先联系作者，经作者同意后再转载，并请注明原文链接和作者，整理这些不容易，最终版权归作者所有，谢谢合作！</p>
<p>你了解Hexo吗？ Hexo是一个静态博客框架，基于Node.js，将Markdown文章通过渲染引擎，生成一个静态网页，再结合Git命令（ssh），Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
<p>几个月前偶然间了解到了Hexo这个静态博客网站，很适合那些喜欢写作的朋友们，最重要的是它是免费的，里面有许多的博客主题模板，这些主题都是一些很牛的大佬们开发的，而且设计的主题都很棒，让我很心动，心动不如行动，于是开始整理搭建属于自己的博客。直到今天，这中间经历了许多的坎坷荆棘，我将我的博客搭建的流程分享出来，能为那些博客小石榴们提供一些帮助吧，如果有错的话，请给我留言，我会及时修改，废话不多说，直接上教程。</p>
<blockquote>
<p>如果下面的教程有错误之处，请在评论区留言，收到后，我会尽快修改，谢谢支持！</p>
</blockquote>
<h2 id="一-博客环境搭建"><a class="markdownIt-Anchor" href="#一-博客环境搭建"></a> 一、博客环境搭建</h2>
<blockquote>
<p>本文系统环境信息：Win10专业版，64位（10.0 版本18362）</p>
<p>Node.js：12.13.0 Git：2.24.0</p>
<p>修改配置文件要用到的软件（可选）：</p>
<ul>
<li>Visual Studio Code（适合有开发基础的程序员，非常好用）</li>
<li>Sublime Text3，可免费使用。</li>
<li>NodePad++ 7.8.1（最新的，也可以在官网选择其他版本）</li>
</ul>
</blockquote>
<h3 id="1下载git和nodejs"><a class="markdownIt-Anchor" href="#1下载git和nodejs"></a> 1.下载Git和Node.js</h3>
<h4 id="11-nodejs的安装与配置"><a class="markdownIt-Anchor" href="#11-nodejs的安装与配置"></a> 1.1 Node.js的安装与配置</h4>
<p>首先去<a target="_blank" rel="noopener" href="https://nodejs.org/en/download/">Node.js官网 </a>下载node.js的安装程序，根据你电脑系统的配置信息，下载对应的安装程序，然后开始进行下面的步骤。</p>
<p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200604161523.png" alt="Node.js下载以及版本的选择"></p>
	
	</div>
  <a type="button" href="/posts/fef1.html#more" class="btn btn-default more">阅读此文</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/posts/88d3.html" >Chapter07-类.md</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2020-04-25  </div>
		</div>
	</div>
	


			<!--
<div class="entry">
  <div class="row">
	
	
		<p>类的基本思想是数据抽象（data abstraction）和封装（encapsulation）。数据抽象是一种依赖于接口（interface）和实现（implementation）分离的编程及设计技术。类的接口包括用户所能执行的操作；类的实现包括类的数据成员、负责接口实现的函数体以及其他私有函数。</p>
<h2 id="定义抽象数据类型defining-abstract-data-types"><a class="markdownIt-Anchor" href="#定义抽象数据类型defining-abstract-data-types"></a> 定义抽象数据类型（Defining Abstract Data Types）</h2>
<h3 id="设计sales_data类designing-the-sales_data-class"><a class="markdownIt-Anchor" href="#设计sales_data类designing-the-sales_data-class"></a> 设计Sales_data类（Designing the Sales_data Class）</h3>
<p>类的用户是程序员，而非应用程序的最终使用者。</p>
<h3 id="定义改进的sales_data类defining-the-revised-sales_data-class"><a class="markdownIt-Anchor" href="#定义改进的sales_data类defining-the-revised-sales_data-class"></a> 定义改进的Sales_data类（Defining the Revised Sales_data Class）</h3>
<p>成员函数（member function）的声明必须在类的内部，定义则既可以在类的内部也可以在类的外部。定义在类内部的函数是隐式的内联函数。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Sales_data</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// new members: operations on Sales_data objects</span></span><br><span class="line">    <span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> bookNo; }</span><br><span class="line">    <span class="function">Sales_data&amp; <span class="title">combine</span><span class="params">(<span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">avg_price</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// data members</span></span><br><span class="line">    std::string bookNo;</span><br><span class="line">    <span class="type">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>成员函数通过一个名为<code>this</code>的隐式额外参数来访问调用它的对象。<code>this</code>参数是一个常量指针，被初始化为调用该函数的对象地址。在函数体内可以显式使用<code>this</code>指针。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">total.<span class="built_in">isbn</span>()</span><br><span class="line"><span class="comment">// pseudo-code illustration of how a call to a member function is translated</span></span><br><span class="line">Sales_data::<span class="built_in">isbn</span>(&amp;total)</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> <span class="keyword">this</span>-&gt;bookNo; }</span><br><span class="line"><span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> bookNo; }</span><br></pre></td></tr></tbody></table></figure>
<p>默认情况下，<code>this</code>的类型是指向类类型非常量版本的常量指针。<code>this</code>也遵循初始化规则，所以默认不能把<code>this</code>绑定到一个常量对象上，即不能在常量对象上调用普通的成员函数。</p>
	

	</div>
  <a type="button" href="/posts/88d3.html#more" class="btn btn-default more">阅读此文</a>
</div>

-->
<div class="entry">
  <div class="row">
	
	
		<p>类的基本思想是数据抽象（data abstraction）和封装（encapsulation）。数据抽象是一种依赖于接口（interface）和实现（implementation）分离的编程及设计技术。类的接口包括用户所能执行的操作；类的实现包括类的数据成员、负责接口实现的函数体以及其他私有函数。</p>
<h2 id="定义抽象数据类型defining-abstract-data-types"><a class="markdownIt-Anchor" href="#定义抽象数据类型defining-abstract-data-types"></a> 定义抽象数据类型（Defining Abstract Data Types）</h2>
<h3 id="设计sales_data类designing-the-sales_data-class"><a class="markdownIt-Anchor" href="#设计sales_data类designing-the-sales_data-class"></a> 设计Sales_data类（Designing the Sales_data Class）</h3>
<p>类的用户是程序员，而非应用程序的最终使用者。</p>
<h3 id="定义改进的sales_data类defining-the-revised-sales_data-class"><a class="markdownIt-Anchor" href="#定义改进的sales_data类defining-the-revised-sales_data-class"></a> 定义改进的Sales_data类（Defining the Revised Sales_data Class）</h3>
<p>成员函数（member function）的声明必须在类的内部，定义则既可以在类的内部也可以在类的外部。定义在类内部的函数是隐式的内联函数。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Sales_data</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// new members: operations on Sales_data objects</span></span><br><span class="line">    <span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> bookNo; }</span><br><span class="line">    <span class="function">Sales_data&amp; <span class="title">combine</span><span class="params">(<span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">avg_price</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// data members</span></span><br><span class="line">    std::string bookNo;</span><br><span class="line">    <span class="type">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>成员函数通过一个名为<code>this</code>的隐式额外参数来访问调用它的对象。<code>this</code>参数是一个常量指针，被初始化为调用该函数的对象地址。在函数体内可以显式使用<code>this</code>指针。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">total.<span class="built_in">isbn</span>()</span><br><span class="line"><span class="comment">// pseudo-code illustration of how a call to a member function is translated</span></span><br><span class="line">Sales_data::<span class="built_in">isbn</span>(&amp;total)</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> <span class="keyword">this</span>-&gt;bookNo; }</span><br><span class="line"><span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> bookNo; }</span><br></pre></td></tr></tbody></table></figure>
<p>默认情况下，<code>this</code>的类型是指向类类型非常量版本的常量指针。<code>this</code>也遵循初始化规则，所以默认不能把<code>this</code>绑定到一个常量对象上，即不能在常量对象上调用普通的成员函数。</p>
	
	</div>
  <a type="button" href="/posts/88d3.html#more" class="btn btn-default more">阅读此文</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/posts/8bc5.html" >Chapter06 函数</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2020-04-15  </div>
		</div>
	</div>
	


			<!--
<div class="entry">
  <div class="row">
	
	
		<h2 id="函数基础function-basics"><a class="markdownIt-Anchor" href="#函数基础function-basics"></a> 函数基础（Function Basics）</h2>
<p>典型的函数定义包括返回类型（return type）、函数名字、由0个或多个形式参数（parameter，简称形参）组成的列表和函数体（function body）。函数执行的操作在函数体中指明。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// factorial of val is val * (val - 1) * (val - 2) . . . * ((val - (val - 1)) * 1)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fact</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">1</span>;    <span class="comment">// local variable to hold the result as we calculate it</span></span><br><span class="line">    <span class="keyword">while</span> (val &gt; <span class="number">1</span>)</span><br><span class="line">    ret *= val--;   <span class="comment">// assign ret * val to ret and decrement val</span></span><br><span class="line">    <span class="keyword">return</span> ret;     <span class="comment">// return the result</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>程序通过调用运算符（call operator）来执行函数。调用运算符的形式之一是一对圆括号<code>()</code>，作用于一个表达式，该表达式是函数或者指向函数的指针；圆括号内是一个用逗号隔开的实际参数（argument，简称实参）列表，用来初始化函数形参。调用表达式的类型就是函数的返回类型。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> j = <span class="built_in">fact</span>(<span class="number">5</span>);    <span class="comment">// j equals 120, i.e., the result of fact(5)</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"5! is "</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>函数调用完成两项工作：</p>
<ul>
<li>用实参初始化对应的形参。</li>
<li>将控制权从主调函数转移给被调函数。此时，主调函数（calling function）的执行被暂时中断，被调函数（called function）开始执行。</li>
</ul>
<p><code>return</code>语句结束函数的执行过程，完成两项工作：</p>
<ul>
<li>返回<code>return</code>语句中的值（可能没有值）。</li>
<li>将控制权从被调函数转移回主调函数，函数的返回值用于初始化调用表达式的结果。</li>
</ul>
<p>实参是形参的初始值，两者的顺序和类型必须一一对应。</p>
	

	</div>
  <a type="button" href="/posts/8bc5.html#more" class="btn btn-default more">阅读此文</a>
</div>

-->
<div class="entry">
  <div class="row">
	
	
		<h2 id="函数基础function-basics"><a class="markdownIt-Anchor" href="#函数基础function-basics"></a> 函数基础（Function Basics）</h2>
<p>典型的函数定义包括返回类型（return type）、函数名字、由0个或多个形式参数（parameter，简称形参）组成的列表和函数体（function body）。函数执行的操作在函数体中指明。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// factorial of val is val * (val - 1) * (val - 2) . . . * ((val - (val - 1)) * 1)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fact</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">1</span>;    <span class="comment">// local variable to hold the result as we calculate it</span></span><br><span class="line">    <span class="keyword">while</span> (val &gt; <span class="number">1</span>)</span><br><span class="line">    ret *= val--;   <span class="comment">// assign ret * val to ret and decrement val</span></span><br><span class="line">    <span class="keyword">return</span> ret;     <span class="comment">// return the result</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>程序通过调用运算符（call operator）来执行函数。调用运算符的形式之一是一对圆括号<code>()</code>，作用于一个表达式，该表达式是函数或者指向函数的指针；圆括号内是一个用逗号隔开的实际参数（argument，简称实参）列表，用来初始化函数形参。调用表达式的类型就是函数的返回类型。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> j = <span class="built_in">fact</span>(<span class="number">5</span>);    <span class="comment">// j equals 120, i.e., the result of fact(5)</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"5! is "</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>函数调用完成两项工作：</p>
<ul>
<li>用实参初始化对应的形参。</li>
<li>将控制权从主调函数转移给被调函数。此时，主调函数（calling function）的执行被暂时中断，被调函数（called function）开始执行。</li>
</ul>
<p><code>return</code>语句结束函数的执行过程，完成两项工作：</p>
<ul>
<li>返回<code>return</code>语句中的值（可能没有值）。</li>
<li>将控制权从被调函数转移回主调函数，函数的返回值用于初始化调用表达式的结果。</li>
</ul>
<p>实参是形参的初始值，两者的顺序和类型必须一一对应。</p>
	
	</div>
  <a type="button" href="/posts/8bc5.html#more" class="btn btn-default more">阅读此文</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/posts/3ea6.html" >Exercise of chapter 05</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2020-04-11  </div>
		</div>
	</div>
	


			<!--
<div class="entry">
  <div class="row">
	
	
		<h2 id="exercise_51"><a class="markdownIt-Anchor" href="#exercise_51"></a> exercise_5.1</h2>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    什么是空语句？什么时候会用到空语句？</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    只含义一个单独的分号的语句是空语句。如： ;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    如果在程序的某个地方，语法上需要一条语句但是逻辑上不需要，此时应该使用空语句。</span></span><br><span class="line"><span class="comment">    while (cin &gt;&gt; s &amp;&amp; s != sought)</span></span><br><span class="line"><span class="comment">	;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="exercise_52"><a class="markdownIt-Anchor" href="#exercise_52"></a> exercise_5.2</h2>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    什么是块？什么时候会用到块？</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    用花括号括起来的语句和声明的序列就是块。</span></span><br><span class="line"><span class="comment">    {</span></span><br><span class="line"><span class="comment">	    // ...</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment">    如果在程序的某个地方，语法上需要一条语句，而逻辑上需要多条语句，此时应该使用块</span></span><br><span class="line"><span class="comment">    while (val &lt;= 10) {</span></span><br><span class="line"><span class="comment">        sum += val;</span></span><br><span class="line"><span class="comment">        ++val;</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="exercise_53"><a class="markdownIt-Anchor" href="#exercise_53"></a> exercise_5.3</h2>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    使用逗号运算符重写1.4.1节的 while 循环，使它不再需要块，</span></span><br><span class="line"><span class="comment">    观察改写之后的代码可读性提高了还是降低了。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    while (val &lt;= 10)</span></span><br><span class="line"><span class="comment">    sum += val, ++val;.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    代码的可读性反而降低了。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="exercise_54"><a class="markdownIt-Anchor" href="#exercise_54"></a> exercise_5.4</h2>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    说明下列例子的含义，如果存在问题，试着修改它。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    (a) while (string::iterator iter != s.end()) {  . . .  }</span></span><br><span class="line"><span class="comment">    (b) while (bool status = find(word)) {  . . .  }</span></span><br><span class="line"><span class="comment">            if (!status) {  . . .  }</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    (a) 这个循环试图用迭代器遍历string，但是变量的定义应该放在循环的外面，目前每次循环都会重新定义一个变量，明显是错误的。</span></span><br><span class="line"><span class="comment">    (b) 这个循环的 while 和 if 是两个独立的语句，if 语句中无法访问 status 变量，正确的做法是应该将 if 语句包含在 while 里面，</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="exercise_55"><a class="markdownIt-Anchor" href="#exercise_55"></a> exercise_5.5</h2>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> score; cin &gt;&gt; score;)</span><br><span class="line">    {</span><br><span class="line">        vector&lt;string&gt; garden{<span class="string">"F"</span>, <span class="string">"D"</span>, <span class="string">"C"</span>, <span class="string">"B"</span>, <span class="string">"A"</span>, <span class="string">"A++"</span>};</span><br><span class="line"></span><br><span class="line">        string lettergrade;</span><br><span class="line">        <span class="keyword">if</span>(score&lt;<span class="number">60</span>)</span><br><span class="line">            lettergrade = garden[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span>{</span><br><span class="line">            lettergrade = garden[(score - <span class="number">50</span>) / <span class="number">10</span>];</span><br><span class="line">            <span class="keyword">if</span>(score!=<span class="number">100</span>)</span><br><span class="line">                lettergrade = score % <span class="number">10</span> &gt; <span class="number">7</span> ? <span class="string">"+"</span> : score % <span class="number">10</span> &lt; <span class="number">3</span> ? <span class="string">"-"</span> : <span class="string">""</span>;</span><br><span class="line">            cout &lt;&lt; lettergrade &lt;&lt; endl;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
	

	</div>
  <a type="button" href="/posts/3ea6.html#more" class="btn btn-default more">阅读此文</a>
</div>

-->
<div class="entry">
  <div class="row">
	
	
		<h2 id="exercise_51"><a class="markdownIt-Anchor" href="#exercise_51"></a> exercise_5.1</h2>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    什么是空语句？什么时候会用到空语句？</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    只含义一个单独的分号的语句是空语句。如： ;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    如果在程序的某个地方，语法上需要一条语句但是逻辑上不需要，此时应该使用空语句。</span></span><br><span class="line"><span class="comment">    while (cin &gt;&gt; s &amp;&amp; s != sought)</span></span><br><span class="line"><span class="comment">	;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="exercise_52"><a class="markdownIt-Anchor" href="#exercise_52"></a> exercise_5.2</h2>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    什么是块？什么时候会用到块？</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    用花括号括起来的语句和声明的序列就是块。</span></span><br><span class="line"><span class="comment">    {</span></span><br><span class="line"><span class="comment">	    // ...</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment">    如果在程序的某个地方，语法上需要一条语句，而逻辑上需要多条语句，此时应该使用块</span></span><br><span class="line"><span class="comment">    while (val &lt;= 10) {</span></span><br><span class="line"><span class="comment">        sum += val;</span></span><br><span class="line"><span class="comment">        ++val;</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="exercise_53"><a class="markdownIt-Anchor" href="#exercise_53"></a> exercise_5.3</h2>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    使用逗号运算符重写1.4.1节的 while 循环，使它不再需要块，</span></span><br><span class="line"><span class="comment">    观察改写之后的代码可读性提高了还是降低了。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    while (val &lt;= 10)</span></span><br><span class="line"><span class="comment">    sum += val, ++val;.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    代码的可读性反而降低了。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="exercise_54"><a class="markdownIt-Anchor" href="#exercise_54"></a> exercise_5.4</h2>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    说明下列例子的含义，如果存在问题，试着修改它。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    (a) while (string::iterator iter != s.end()) {  . . .  }</span></span><br><span class="line"><span class="comment">    (b) while (bool status = find(word)) {  . . .  }</span></span><br><span class="line"><span class="comment">            if (!status) {  . . .  }</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    (a) 这个循环试图用迭代器遍历string，但是变量的定义应该放在循环的外面，目前每次循环都会重新定义一个变量，明显是错误的。</span></span><br><span class="line"><span class="comment">    (b) 这个循环的 while 和 if 是两个独立的语句，if 语句中无法访问 status 变量，正确的做法是应该将 if 语句包含在 while 里面，</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="exercise_55"><a class="markdownIt-Anchor" href="#exercise_55"></a> exercise_5.5</h2>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> score; cin &gt;&gt; score;)</span><br><span class="line">    {</span><br><span class="line">        vector&lt;string&gt; garden{<span class="string">"F"</span>, <span class="string">"D"</span>, <span class="string">"C"</span>, <span class="string">"B"</span>, <span class="string">"A"</span>, <span class="string">"A++"</span>};</span><br><span class="line"></span><br><span class="line">        string lettergrade;</span><br><span class="line">        <span class="keyword">if</span>(score&lt;<span class="number">60</span>)</span><br><span class="line">            lettergrade = garden[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span>{</span><br><span class="line">            lettergrade = garden[(score - <span class="number">50</span>) / <span class="number">10</span>];</span><br><span class="line">            <span class="keyword">if</span>(score!=<span class="number">100</span>)</span><br><span class="line">                lettergrade = score % <span class="number">10</span> &gt; <span class="number">7</span> ? <span class="string">"+"</span> : score % <span class="number">10</span> &lt; <span class="number">3</span> ? <span class="string">"-"</span> : <span class="string">""</span>;</span><br><span class="line">            cout &lt;&lt; lettergrade &lt;&lt; endl;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
	
	</div>
  <a type="button" href="/posts/3ea6.html#more" class="btn btn-default more">阅读此文</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/posts/eada.html" >Chapter05 语句</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2020-04-10  </div>
		</div>
	</div>
	


			<!--
<div class="entry">
  <div class="row">
	
	
		<h2 id="简单语句simple-statements"><a class="markdownIt-Anchor" href="#简单语句simple-statements"></a> 简单语句（Simple Statements）</h2>
<p>如果在程序的某个地方，语法上需要一条语句但是逻辑上不需要，则应该使用空语句（null statement）。空语句中只含有一个单独的分号<code>;</code>。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// read until we hit end-of-file or find an input equal to sought</span></span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; s &amp;&amp; s != sought)</span><br><span class="line">    ;   <span class="comment">// null statement</span></span><br></pre></td></tr></tbody></table></figure>
<p>使用空语句时应该加上注释，从而令读这段代码的人知道该语句是有意省略的。</p>
<p>多余的空语句并非总是无害的。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// disaster: extra semicolon: loop body is this null statement</span></span><br><span class="line"><span class="keyword">while</span> (iter != svec.<span class="built_in">end</span>()) ;    <span class="comment">// the while body is the empty statement</span></span><br><span class="line">    ++iter;     <span class="comment">// increment is not part of the loop</span></span><br></pre></td></tr></tbody></table></figure>
<p>复合语句（compound statement）是指用花括号括起来的（可能为空）语句和声明的序列。复合语句也叫做块（block），一个块就是一个作用域。在块中引入的名字只能在块内部以及嵌套在块中的子块里访问。通常，名字在有限的区域内可见，该区域从名字定义处开始，到名字所在（最内层）块的结尾处为止。</p>
<p>语句块不以分号作为结束。</p>
<p>空块的作用等价于空语句。</p>
<h2 id="语句作用域statement-scope"><a class="markdownIt-Anchor" href="#语句作用域statement-scope"></a> 语句作用域（Statement Scope）</h2>
	

	</div>
  <a type="button" href="/posts/eada.html#more" class="btn btn-default more">阅读此文</a>
</div>

-->
<div class="entry">
  <div class="row">
	
	
		<h2 id="简单语句simple-statements"><a class="markdownIt-Anchor" href="#简单语句simple-statements"></a> 简单语句（Simple Statements）</h2>
<p>如果在程序的某个地方，语法上需要一条语句但是逻辑上不需要，则应该使用空语句（null statement）。空语句中只含有一个单独的分号<code>;</code>。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// read until we hit end-of-file or find an input equal to sought</span></span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; s &amp;&amp; s != sought)</span><br><span class="line">    ;   <span class="comment">// null statement</span></span><br></pre></td></tr></tbody></table></figure>
<p>使用空语句时应该加上注释，从而令读这段代码的人知道该语句是有意省略的。</p>
<p>多余的空语句并非总是无害的。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// disaster: extra semicolon: loop body is this null statement</span></span><br><span class="line"><span class="keyword">while</span> (iter != svec.<span class="built_in">end</span>()) ;    <span class="comment">// the while body is the empty statement</span></span><br><span class="line">    ++iter;     <span class="comment">// increment is not part of the loop</span></span><br></pre></td></tr></tbody></table></figure>
<p>复合语句（compound statement）是指用花括号括起来的（可能为空）语句和声明的序列。复合语句也叫做块（block），一个块就是一个作用域。在块中引入的名字只能在块内部以及嵌套在块中的子块里访问。通常，名字在有限的区域内可见，该区域从名字定义处开始，到名字所在（最内层）块的结尾处为止。</p>
<p>语句块不以分号作为结束。</p>
<p>空块的作用等价于空语句。</p>
<h2 id="语句作用域statement-scope"><a class="markdownIt-Anchor" href="#语句作用域statement-scope"></a> 语句作用域（Statement Scope）</h2>
	
	</div>
  <a type="button" href="/posts/eada.html#more" class="btn btn-default more">阅读此文</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/posts/5cc1.html" >Exercise of chapter 04</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2020-04-07  </div>
		</div>
	</div>
	


			<!--
<div class="entry">
  <div class="row">
	
	
		<h2 id="exercise_41"><a class="markdownIt-Anchor" href="#exercise_41"></a> Exercise_4.1</h2>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//表达式 5 + 10 * 20 / 2 的求值结果是多少？</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> t = <span class="number">5</span> + <span class="number">10</span> * <span class="number">20</span> / <span class="number">2</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"the result is  "</span> &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="exercise_42"><a class="markdownIt-Anchor" href="#exercise_42"></a> Exercise_4.2</h2>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    根据4.12节中的表，在下述表达式的合理位置添加括号，</span></span><br><span class="line"><span class="comment">    使得添加括号后运算对象的组合顺序与添加括号前一致。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    vector &lt;<span class="type">int</span>&gt; <span class="built_in">vec</span>(<span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> first1 = *(vec.<span class="built_in">begin</span>());</span><br><span class="line">    <span class="type">int</span> first2 = (*(vec.<span class="built_in">begin</span>())) + <span class="number">1</span>;</span><br><span class="line">    cout &lt;&lt; first1 &lt;&lt; <span class="string">"  "</span> &lt;&lt; first2;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="exercise_43"><a class="markdownIt-Anchor" href="#exercise_43"></a> Exercise_4.3</h2>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    C++语言没有明确规定大多数二元运算符的求值顺序，给编译器优化留下了余地。</span></span><br><span class="line"><span class="comment">    这种策略实际上是在代码生成效率和程序潜在缺陷之间进行了权衡，</span></span><br><span class="line"><span class="comment">    你认为这可以接受吗？请说出你的理由。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    可以接受。C++的设计思想是尽可能地“相信”程序员，将效率最大化。</span></span><br><span class="line"><span class="comment">    然而这种思想却有着潜在的危害，就是无法控制程序员自身引发的错误。</span></span><br><span class="line"><span class="comment">    因此 Java 的诞生也是必然，Java的思想就是尽可能地“不相信”程序员。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="exercise_44"><a class="markdownIt-Anchor" href="#exercise_44"></a> Exercise_4.4</h2>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    在下面的表达式中添加括号，说明其求值过程及最终结果。</span></span><br><span class="line"><span class="comment">    编写程序编译该（不加括号的）表达式并输出结果验证之前的推断。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> t= <span class="number">12</span> / <span class="number">3</span> * <span class="number">4</span> + <span class="number">5</span> * <span class="number">15</span> + <span class="number">24</span> % <span class="number">4</span> / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> s = ((<span class="number">12</span> / <span class="number">3</span>) * <span class="number">4</span>) + (<span class="number">5</span> * <span class="number">15</span>) + ((<span class="number">24</span> % <span class="number">4</span>) / <span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; t&lt;&lt;<span class="string">" "</span>&lt;&lt;s&lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="exercise_45"><a class="markdownIt-Anchor" href="#exercise_45"></a> Exercise_4.5</h2>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//写出下列表达式的求值结果。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">-30 * 3 + 21 / 5  // -90+4 = -86</span></span><br><span class="line"><span class="comment">-30 + 3 * 21 / 5  // -30+63/5 = -30+12 = -18</span></span><br><span class="line"><span class="comment">30 / 3 * 21 % 5   // 10*21%5 = 210%5 = 0</span></span><br><span class="line"><span class="comment">-30 / 3 * 21 % 4  // -10*21%4 = -210%4 = -2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure>
	

	</div>
  <a type="button" href="/posts/5cc1.html#more" class="btn btn-default more">阅读此文</a>
</div>

-->
<div class="entry">
  <div class="row">
	
	
		<h2 id="exercise_41"><a class="markdownIt-Anchor" href="#exercise_41"></a> Exercise_4.1</h2>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//表达式 5 + 10 * 20 / 2 的求值结果是多少？</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> t = <span class="number">5</span> + <span class="number">10</span> * <span class="number">20</span> / <span class="number">2</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"the result is  "</span> &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="exercise_42"><a class="markdownIt-Anchor" href="#exercise_42"></a> Exercise_4.2</h2>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    根据4.12节中的表，在下述表达式的合理位置添加括号，</span></span><br><span class="line"><span class="comment">    使得添加括号后运算对象的组合顺序与添加括号前一致。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    vector &lt;<span class="type">int</span>&gt; <span class="built_in">vec</span>(<span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> first1 = *(vec.<span class="built_in">begin</span>());</span><br><span class="line">    <span class="type">int</span> first2 = (*(vec.<span class="built_in">begin</span>())) + <span class="number">1</span>;</span><br><span class="line">    cout &lt;&lt; first1 &lt;&lt; <span class="string">"  "</span> &lt;&lt; first2;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="exercise_43"><a class="markdownIt-Anchor" href="#exercise_43"></a> Exercise_4.3</h2>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    C++语言没有明确规定大多数二元运算符的求值顺序，给编译器优化留下了余地。</span></span><br><span class="line"><span class="comment">    这种策略实际上是在代码生成效率和程序潜在缺陷之间进行了权衡，</span></span><br><span class="line"><span class="comment">    你认为这可以接受吗？请说出你的理由。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    可以接受。C++的设计思想是尽可能地“相信”程序员，将效率最大化。</span></span><br><span class="line"><span class="comment">    然而这种思想却有着潜在的危害，就是无法控制程序员自身引发的错误。</span></span><br><span class="line"><span class="comment">    因此 Java 的诞生也是必然，Java的思想就是尽可能地“不相信”程序员。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h2 id="exercise_44"><a class="markdownIt-Anchor" href="#exercise_44"></a> Exercise_4.4</h2>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    在下面的表达式中添加括号，说明其求值过程及最终结果。</span></span><br><span class="line"><span class="comment">    编写程序编译该（不加括号的）表达式并输出结果验证之前的推断。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> t= <span class="number">12</span> / <span class="number">3</span> * <span class="number">4</span> + <span class="number">5</span> * <span class="number">15</span> + <span class="number">24</span> % <span class="number">4</span> / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> s = ((<span class="number">12</span> / <span class="number">3</span>) * <span class="number">4</span>) + (<span class="number">5</span> * <span class="number">15</span>) + ((<span class="number">24</span> % <span class="number">4</span>) / <span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; t&lt;&lt;<span class="string">" "</span>&lt;&lt;s&lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="exercise_45"><a class="markdownIt-Anchor" href="#exercise_45"></a> Exercise_4.5</h2>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//写出下列表达式的求值结果。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">-30 * 3 + 21 / 5  // -90+4 = -86</span></span><br><span class="line"><span class="comment">-30 + 3 * 21 / 5  // -30+63/5 = -30+12 = -18</span></span><br><span class="line"><span class="comment">30 / 3 * 21 % 5   // 10*21%5 = 210%5 = 0</span></span><br><span class="line"><span class="comment">-30 / 3 * 21 % 4  // -10*21%4 = -210%4 = -2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure>
	
	</div>
  <a type="button" href="/posts/5cc1.html#more" class="btn btn-default more">阅读此文</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/posts/45e4.html" >Chapter04 表达式</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2020-04-07  </div>
		</div>
	</div>
	


			<!--
<div class="entry">
  <div class="row">
	
	
		<h1 id="第4章-表达式"><a class="markdownIt-Anchor" href="#第4章-表达式"></a> 第4章 表达式</h1>
<h2 id="基础fundamentals"><a class="markdownIt-Anchor" href="#基础fundamentals"></a> 基础（Fundamentals）</h2>
<p>表达式（expression）由一个或多个运算对象（operand）组成，对表达式求值将得到一个结果（result）。字面值和变量是最简单的表达式，其结果就是字面值和变量的值。</p>
<h3 id="基础概念basic-concepts"><a class="markdownIt-Anchor" href="#基础概念basic-concepts"></a> 基础概念（Basic Concepts）</h3>
<p>C++定义了一元运算符（unary operator）和二元运算符（binary operator）。除此之外，还有一个作用于三个运算对象的三元运算符。函数调用也是一种特殊的运算符，它对运算对象的数量没有限制。</p>
<p>表达式求值过程中，小整数类型（如<code>bool</code>、<code>char</code>、<code>short</code>等）通常会被提升（promoted）为较大的整数类型，主要是<code>int</code>。</p>
<p>C++定义了运算符作用于内置类型和复合类型的运算对象时所执行的操作。当运算符作用于类类型的运算对象时，用户可以自定义其含义，这被称作运算符重载（overloaded operator）。</p>
<p>C++的表达式分为右值（rvalue）和左值（lvalue）。<font color="red">当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值时，用的是对象的地址。需要右值的地方可以用左值代替，反之则不行。</font></p>
<ul>
<li>赋值运算符需要一个非常量左值作为其左侧运算对象，返回结果也是一个左值。</li>
<li>取地址符作用于左值运算对象，返回指向该运算对象的指针，该指针是一个右值。</li>
<li>内置解引用运算符、下标运算符、迭代器解引用运算符、<code>string</code>和<code>vector</code>的下标运算符都返回左值。</li>
<li>内置类型和迭代器的递增递减运算符作用于左值运算对象。前置版本返回左值，后置版本返回右值。</li>
</ul>
<p>如果<code>decltype</code>作用于一个求值结果是左值的表达式，会得到引用类型。</p>
	

	</div>
  <a type="button" href="/posts/45e4.html#more" class="btn btn-default more">阅读此文</a>
</div>

-->
<div class="entry">
  <div class="row">
	
	
		<h1 id="第4章-表达式"><a class="markdownIt-Anchor" href="#第4章-表达式"></a> 第4章 表达式</h1>
<h2 id="基础fundamentals"><a class="markdownIt-Anchor" href="#基础fundamentals"></a> 基础（Fundamentals）</h2>
<p>表达式（expression）由一个或多个运算对象（operand）组成，对表达式求值将得到一个结果（result）。字面值和变量是最简单的表达式，其结果就是字面值和变量的值。</p>
<h3 id="基础概念basic-concepts"><a class="markdownIt-Anchor" href="#基础概念basic-concepts"></a> 基础概念（Basic Concepts）</h3>
<p>C++定义了一元运算符（unary operator）和二元运算符（binary operator）。除此之外，还有一个作用于三个运算对象的三元运算符。函数调用也是一种特殊的运算符，它对运算对象的数量没有限制。</p>
<p>表达式求值过程中，小整数类型（如<code>bool</code>、<code>char</code>、<code>short</code>等）通常会被提升（promoted）为较大的整数类型，主要是<code>int</code>。</p>
<p>C++定义了运算符作用于内置类型和复合类型的运算对象时所执行的操作。当运算符作用于类类型的运算对象时，用户可以自定义其含义，这被称作运算符重载（overloaded operator）。</p>
<p>C++的表达式分为右值（rvalue）和左值（lvalue）。<font color="red">当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值时，用的是对象的地址。需要右值的地方可以用左值代替，反之则不行。</font></p>
<ul>
<li>赋值运算符需要一个非常量左值作为其左侧运算对象，返回结果也是一个左值。</li>
<li>取地址符作用于左值运算对象，返回指向该运算对象的指针，该指针是一个右值。</li>
<li>内置解引用运算符、下标运算符、迭代器解引用运算符、<code>string</code>和<code>vector</code>的下标运算符都返回左值。</li>
<li>内置类型和迭代器的递增递减运算符作用于左值运算对象。前置版本返回左值，后置版本返回右值。</li>
</ul>
<p>如果<code>decltype</code>作用于一个求值结果是左值的表达式，会得到引用类型。</p>
	
	</div>
  <a type="button" href="/posts/45e4.html#more" class="btn btn-default more">阅读此文</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/posts/87ea.html" >C++ getline()</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2020-04-04  </div>
		</div>
	</div>
	


			<!--
<div class="entry">
  <div class="row">
	
	
		<p>虽然可以使用 cin 和 &gt;&gt; 运算符来输入字符串，但它可能会导致一些需要注意的问题。</p>
<p>当 cin 读取数据时，它会传递并忽略任何前导白色空格字符（空格、制表符或换行符）。一旦它接触到第一个非空格字符即开始阅读，当它读取到下一个空白字符时，它将停止读取。以下面的语句为例：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">cin &gt;&gt; namel;</span><br></pre></td></tr></tbody></table></figure>
<p>可以输入 “Mark” 或 “Twain”，但不能输入 “Mark Twain”，因为 cin 不能输入包含嵌入空格的字符串。下面程序演示了这个问题：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// This program illustrates a problem that can occur if</span></span><br><span class="line"><span class="comment">// cin is used to read character data into a string object.</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span> <span class="comment">// Header file needed to use string objects</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    string name;</span><br><span class="line">    string city;</span><br><span class="line">    cout &lt;&lt; <span class="string">"Please enter your name: "</span>;</span><br><span class="line">    cin &gt;&gt; name;</span><br><span class="line">    cout &lt;&lt; <span class="string">"Enter the city you live in: "</span>;</span><br><span class="line">    cin &gt;&gt; city;</span><br><span class="line">    cout &lt;&lt; <span class="string">"Hello, "</span> &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"You live in "</span> &lt;&lt; city &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>程序输出结果：</p>
<blockquote>
<p>Please enter your name： John Doe<br>
Enter the city you live in: Hello, John<br>
You live in Doe</p>
</blockquote>
<p>请注意，在这个示例中，用户根本没有机会输入 city 城市名。因为在第一个输入语句中，当 cin 读取到 John 和 Doe 之间的空格时，它就会停止阅读，只存储 John 作为 name 的值。在第二个输入语句中， cin 使用键盘缓冲区中找到的剩余字符，并存储 Doe 作为 city 的值。</p>
<p>为了解决这个问题，可以使用一个叫做 getline 的 C++ 函数。此函数可读取整行，包括前导和嵌入的空格，并将其存储在字符串对象中。</p>
<p>getline 函数如下所示：</p>
	

	</div>
  <a type="button" href="/posts/87ea.html#more" class="btn btn-default more">阅读此文</a>
</div>

-->
<div class="entry">
  <div class="row">
	
	
		<p>虽然可以使用 cin 和 &gt;&gt; 运算符来输入字符串，但它可能会导致一些需要注意的问题。</p>
<p>当 cin 读取数据时，它会传递并忽略任何前导白色空格字符（空格、制表符或换行符）。一旦它接触到第一个非空格字符即开始阅读，当它读取到下一个空白字符时，它将停止读取。以下面的语句为例：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">cin &gt;&gt; namel;</span><br></pre></td></tr></tbody></table></figure>
<p>可以输入 “Mark” 或 “Twain”，但不能输入 “Mark Twain”，因为 cin 不能输入包含嵌入空格的字符串。下面程序演示了这个问题：</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// This program illustrates a problem that can occur if</span></span><br><span class="line"><span class="comment">// cin is used to read character data into a string object.</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span> <span class="comment">// Header file needed to use string objects</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    string name;</span><br><span class="line">    string city;</span><br><span class="line">    cout &lt;&lt; <span class="string">"Please enter your name: "</span>;</span><br><span class="line">    cin &gt;&gt; name;</span><br><span class="line">    cout &lt;&lt; <span class="string">"Enter the city you live in: "</span>;</span><br><span class="line">    cin &gt;&gt; city;</span><br><span class="line">    cout &lt;&lt; <span class="string">"Hello, "</span> &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"You live in "</span> &lt;&lt; city &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>程序输出结果：</p>
<blockquote>
<p>Please enter your name： John Doe<br>
Enter the city you live in: Hello, John<br>
You live in Doe</p>
</blockquote>
<p>请注意，在这个示例中，用户根本没有机会输入 city 城市名。因为在第一个输入语句中，当 cin 读取到 John 和 Doe 之间的空格时，它就会停止阅读，只存储 John 作为 name 的值。在第二个输入语句中， cin 使用键盘缓冲区中找到的剩余字符，并存储 Doe 作为 city 的值。</p>
<p>为了解决这个问题，可以使用一个叫做 getline 的 C++ 函数。此函数可读取整行，包括前导和嵌入的空格，并将其存储在字符串对象中。</p>
<p>getline 函数如下所示：</p>
	
	</div>
  <a type="button" href="/posts/87ea.html#more" class="btn btn-default more">阅读此文</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/posts/a5.html" >Exercise of chapter 3</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2020-04-04  </div>
		</div>
	</div>
	


			<!--
<div class="entry">
  <div class="row">
	
	
		<h2 id="exercise-32"><a class="markdownIt-Anchor" href="#exercise-32"></a> Exercise 3.2</h2>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   编写一段程序从标准输入中一次读入一行，然后修改该程序使其一次读入一个词。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    string s;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">getline</span>(cin,s))</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">	}      <span class="comment">//一次读入一行</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (cin &gt;&gt; s)</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">	}       <span class="comment">//一次读入一个词</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="exercise-33"><a class="markdownIt-Anchor" href="#exercise-33"></a> Exercise 3.3</h2>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   请说明string类的输入运算符和getline函数分别是如何处理空白字符的。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">/*******输入 " this is a string."************/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   类似 getline(is, s) 的读取，string对象</span></span><br><span class="line"><span class="comment">*   会从输入流中读取字符，直到遇见换行符为止。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    string s;  <span class="comment">// 输入 " this is a string."</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">getline</span>(cin,s))</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   类似 is &gt;&gt; s 的读取，string对象会忽略开头的空白</span></span><br><span class="line"><span class="comment">*   并从第一个真正的字符开始，直到遇见下一空白为止。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	<span class="keyword">while</span> (cin &gt;&gt; s)</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="exercise-34"><a class="markdownIt-Anchor" href="#exercise-34"></a> Exercise 3.4</h2>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   请说明string类的输入运算符和getline函数分别是如何处理空白字符的。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">/*******输入 " this is a string."************/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   类似 getline(is, s) 的读取，string对象</span></span><br><span class="line"><span class="comment">*   会从输入流中读取字符，直到遇见换行符为止。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    string s;  <span class="comment">// 输入 " this is a string."</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">getline</span>(cin,s))</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   类似 is &gt;&gt; s 的读取，string对象会忽略开头的空白</span></span><br><span class="line"><span class="comment">*   并从第一个真正的字符开始，直到遇见下一空白为止。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	<span class="keyword">while</span> (cin &gt;&gt; s)</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="exercise-35"><a class="markdownIt-Anchor" href="#exercise-35"></a> Exercise 3.5</h2>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*    编写一段程序从标准输入中读入多个字符串并将他们连接起来，</span></span><br><span class="line"><span class="comment">*    输出连接成的大字符串。然后修改上述程序，用空格把输入的多个字符串分割开来。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{   </span><br><span class="line">	string result, s;</span><br><span class="line">	<span class="keyword">while</span> (cin &gt;&gt; s)</span><br><span class="line">	{</span><br><span class="line">		result += s;</span><br><span class="line">	}</span><br><span class="line">	cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    string result, s;</span><br><span class="line">	<span class="keyword">while</span> (cin &gt;&gt; s)</span><br><span class="line">	{</span><br><span class="line">		result += s + <span class="string">" "</span>;</span><br><span class="line">	}</span><br><span class="line">	cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="exercise-36"><a class="markdownIt-Anchor" href="#exercise-36"></a> Exercise 3.6</h2>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">string <span class="title">line</span> <span class="params">(<span class="string">"this is a string."</span>)</span></span>;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c:line){</span><br><span class="line">       <span class="keyword">if</span>(<span class="built_in">isalpha</span>(c)){</span><br><span class="line">           c = <span class="string">'X'</span>;</span><br><span class="line">       }</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; line &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
	

	</div>
  <a type="button" href="/posts/a5.html#more" class="btn btn-default more">阅读此文</a>
</div>

-->
<div class="entry">
  <div class="row">
	
	
		<h2 id="exercise-32"><a class="markdownIt-Anchor" href="#exercise-32"></a> Exercise 3.2</h2>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   编写一段程序从标准输入中一次读入一行，然后修改该程序使其一次读入一个词。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    string s;</span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">getline</span>(cin,s))</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">	}      <span class="comment">//一次读入一行</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (cin &gt;&gt; s)</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">	}       <span class="comment">//一次读入一个词</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="exercise-33"><a class="markdownIt-Anchor" href="#exercise-33"></a> Exercise 3.3</h2>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   请说明string类的输入运算符和getline函数分别是如何处理空白字符的。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">/*******输入 " this is a string."************/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   类似 getline(is, s) 的读取，string对象</span></span><br><span class="line"><span class="comment">*   会从输入流中读取字符，直到遇见换行符为止。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    string s;  <span class="comment">// 输入 " this is a string."</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">getline</span>(cin,s))</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   类似 is &gt;&gt; s 的读取，string对象会忽略开头的空白</span></span><br><span class="line"><span class="comment">*   并从第一个真正的字符开始，直到遇见下一空白为止。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	<span class="keyword">while</span> (cin &gt;&gt; s)</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="exercise-34"><a class="markdownIt-Anchor" href="#exercise-34"></a> Exercise 3.4</h2>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   请说明string类的输入运算符和getline函数分别是如何处理空白字符的。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">/*******输入 " this is a string."************/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   类似 getline(is, s) 的读取，string对象</span></span><br><span class="line"><span class="comment">*   会从输入流中读取字符，直到遇见换行符为止。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    string s;  <span class="comment">// 输入 " this is a string."</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">getline</span>(cin,s))</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   类似 is &gt;&gt; s 的读取，string对象会忽略开头的空白</span></span><br><span class="line"><span class="comment">*   并从第一个真正的字符开始，直到遇见下一空白为止。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	<span class="keyword">while</span> (cin &gt;&gt; s)</span><br><span class="line">	{</span><br><span class="line">		cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="exercise-35"><a class="markdownIt-Anchor" href="#exercise-35"></a> Exercise 3.5</h2>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*    编写一段程序从标准输入中读入多个字符串并将他们连接起来，</span></span><br><span class="line"><span class="comment">*    输出连接成的大字符串。然后修改上述程序，用空格把输入的多个字符串分割开来。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{   </span><br><span class="line">	string result, s;</span><br><span class="line">	<span class="keyword">while</span> (cin &gt;&gt; s)</span><br><span class="line">	{</span><br><span class="line">		result += s;</span><br><span class="line">	}</span><br><span class="line">	cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    string result, s;</span><br><span class="line">	<span class="keyword">while</span> (cin &gt;&gt; s)</span><br><span class="line">	{</span><br><span class="line">		result += s + <span class="string">" "</span>;</span><br><span class="line">	}</span><br><span class="line">	cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="exercise-36"><a class="markdownIt-Anchor" href="#exercise-36"></a> Exercise 3.6</h2>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">string <span class="title">line</span> <span class="params">(<span class="string">"this is a string."</span>)</span></span>;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c:line){</span><br><span class="line">       <span class="keyword">if</span>(<span class="built_in">isalpha</span>(c)){</span><br><span class="line">           c = <span class="string">'X'</span>;</span><br><span class="line">       }</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; line &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
	
	</div>
  <a type="button" href="/posts/a5.html#more" class="btn btn-default more">阅读此文</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/posts/1d50.html" >Chapter03 字符串、向量和数组</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2020-04-03  </div>
		</div>
	</div>
	


			<!--
<div class="entry">
  <div class="row">
	
	
		<h2 id="命名空间的using声明namespace-using-declarations"><a class="markdownIt-Anchor" href="#命名空间的using声明namespace-using-declarations"></a> 命名空间的using声明（Namespace using Declarations）</h2>
<p>使用<code>using</code>声明后就无须再通过专门的前缀去获取所需的名字了。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> std::cout;</span><br></pre></td></tr></tbody></table></figure>
<p>程序中使用的每个名字都需要用独立的<code>using</code>声明引入。</p>
<p>头文件中通常不应该包含<code>using</code>声明。</p>
<h2 id="标准库类型stringlibrary-string-type"><a class="markdownIt-Anchor" href="#标准库类型stringlibrary-string-type"></a> 标准库类型string（Library string Type）</h2>
<p>标准库类型<code>string</code>表示可变长的字符序列，定义在头文件<em>string</em>中。</p>
<h3 id="定义和初始化string对象defining-and-initializing-strings"><a class="markdownIt-Anchor" href="#定义和初始化string对象defining-and-initializing-strings"></a> 定义和初始化string对象（Defining and Initializing strings）</h3>
<p>初始化<code>string</code>的方式：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200804211406.png" alt="3-1"></p>
	

	</div>
  <a type="button" href="/posts/1d50.html#more" class="btn btn-default more">阅读此文</a>
</div>

-->
<div class="entry">
  <div class="row">
	
	
		<h2 id="命名空间的using声明namespace-using-declarations"><a class="markdownIt-Anchor" href="#命名空间的using声明namespace-using-declarations"></a> 命名空间的using声明（Namespace using Declarations）</h2>
<p>使用<code>using</code>声明后就无须再通过专门的前缀去获取所需的名字了。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> std::cout;</span><br></pre></td></tr></tbody></table></figure>
<p>程序中使用的每个名字都需要用独立的<code>using</code>声明引入。</p>
<p>头文件中通常不应该包含<code>using</code>声明。</p>
<h2 id="标准库类型stringlibrary-string-type"><a class="markdownIt-Anchor" href="#标准库类型stringlibrary-string-type"></a> 标准库类型string（Library string Type）</h2>
<p>标准库类型<code>string</code>表示可变长的字符序列，定义在头文件<em>string</em>中。</p>
<h3 id="定义和初始化string对象defining-and-initializing-strings"><a class="markdownIt-Anchor" href="#定义和初始化string对象defining-and-initializing-strings"></a> 定义和初始化string对象（Defining and Initializing strings）</h3>
<p>初始化<code>string</code>的方式：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200804211406.png" alt="3-1"></p>
	
	</div>
  <a type="button" href="/posts/1d50.html#more" class="btn btn-default more">阅读此文</a>
</div>

		
			
	
	<!-- display as entry -->
<div class="row">
	<div class="col-md-8">
		<h3 class="title">
			<a href="/posts/2b89.html" >CVE-2019-6778</a>
		</h3>
		</div>
	<div class="col-md-4">
		<div class="date">post @ 2020-03-17  </div>
		</div>
	</div>
	


			<!--
<div class="entry">
  <div class="row">
	
	
		<h1 id="一切皆socket"><a class="markdownIt-Anchor" href="#一切皆socket"></a> 一切皆socket</h1>
<p>socket起源于UNIX,可以看出来socket完美的贴合了UNIX一切皆文件的编程思想.我们可以对socket描述符进行ORW的操作,类似普通文件.</p>
<p>在网络编程中,都是由socket实现的,在linux中,socket由上层的libc中的socket和内核中的socket两部分组成,当然为了和硬件交互,最后还需要控制网卡驱动,才是一个完整的体系.</p>
<p>这里我们可以进行一个完整流程的追踪,直接断在tcp_emu上.然后查看调用栈,回溯一下</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">#0  tcp_emu (so=0x7fffe0193ed0, m=0x7fffe0180e20) at /home/mozhucy/qemu-3.0.0/slirp/tcp_subr.c:617</span><br><span class="line">#1  0x0000555555bfc697 in tcp_input (m=0x7fffe0180e20, iphlen=20, inso=0x0, af=2) at /home/mozhucy/qemu-3.0.0/slirp/tcp_input.c:572</span><br><span class="line">#2  0x0000555555bf35c7 in ip_input (m=0x7fffe0180e20) at /home/mozhucy/qemu-3.0.0/slirp/ip_input.c:206</span><br><span class="line">#3  0x0000555555bf6a4a in slirp_input (slirp=0x55555680c500, pkt=0x7fffe02f2700 "RU\n", pkt_len=1334) at /home/mozhucy/qemu-3.0.0/slirp/slirp.c:874</span><br><span class="line">#4  0x0000555555bdf408 in net_slirp_receive (nc=0x55555680c350, buf=0x7fffe02f2700 "RU\n", size=1334) at /home/mozhucy/qemu-3.0.0/net/slirp.c:121</span><br><span class="line">#5  0x0000555555bd5117 in nc_sendv_compat (nc=0x55555680c350, iov=0x7fffeedc3310, iovcnt=1, flags=0) at /home/mozhucy/qemu-3.0.0/net/net.c:701</span><br><span class="line">#6  0x0000555555bd51d9 in qemu_deliver_packet_iov (sender=0x5555578b7d90, flags=0, iov=0x7fffeedc3310, iovcnt=1, opaque=0x55555680c350) at /home/mozhucy/qemu-3.0.0/net/net.c:728</span><br><span class="line">#7  0x0000555555bd7b08 in qemu_net_queue_deliver (queue=0x55555680c290, sender=0x5555578b7d90, flags=0, data=0x7fffe02f2700 "RU\n", size=1334) at /home/mozhucy/qemu-3.0.0/net/queue.c:164</span><br><span class="line">#8  0x0000555555bd7c24 in qemu_net_queue_send (queue=0x55555680c290, sender=0x5555578b7d90, flags=0, data=0x7fffe02f2700 "RU\n", size=1334, sent_cb=0x0) at /home/mozhucy/qemu-3.0.0/net/queue.c:199</span><br><span class="line">#9  0x0000555555bd4f7e in qemu_send_packet_async_with_flags (sender=0x5555578b7d90, flags=0, buf=0x7fffe02f2700 "RU\n", size=1334, sent_cb=0x0) at /home/mozhucy/qemu-3.0.0/net/net.c:655</span><br><span class="line">#10 0x0000555555bd4fb6 in qemu_send_packet_async (sender=0x5555578b7d90, buf=0x7fffe02f2700 "RU\n", size=1334, sent_cb=0x0) at /home/mozhucy/qemu-3.0.0/net/net.c:662</span><br><span class="line">#11 0x0000555555bd4fe3 in qemu_send_packet (nc=0x5555578b7d90, buf=0x7fffe02f2700 "RU\n", size=1334) at /home/mozhucy/qemu-3.0.0/net/net.c:668</span><br><span class="line">#12 0x0000555555aeb758 in rtl8139_transfer_frame (s=0x5555578b2d30, buf=0x7fffe02f2700 "RU\n", size=1334, do_interrupt=1, dot1q_buf=0x0) at /home/mozhucy/qemu-3.0.0/hw/net/rtl8139.c:1804</span><br><span class="line">#13 0x0000555555aecb73 in rtl8139_cplus_transmit_one (s=0x5555578b2d30) at /home/mozhucy/qemu-3.0.0/hw/net/rtl8139.c:2332</span><br><span class="line">#14 0x0000555555aecc31 in rtl8139_cplus_transmit (s=0x5555578b2d30) at /home/mozhucy/qemu-3.0.0/hw/net/rtl8139.c:2359</span><br><span class="line">#15 0x0000555555aed8a2 in rtl8139_io_writeb (opaque=0x5555578b2d30, addr=217 '\331', val=64) at /home/mozhucy/qemu-3.0.0/hw/net/rtl8139.c:2742</span><br><span class="line">#16 0x0000555555aee87f in rtl8139_ioport_write (opaque=0x5555578b2d30, addr=217, val=64, size=1) at /home/mozhucy/qemu-3.0.0/hw/net/rtl8139.c:3279</span><br><span class="line">#17 0x000055555585cbb6 in memory_region_write_accessor (mr=0x5555578b57c0, addr=217, value=0x7fffeedc37e8, size=1, shift=0, mask=255, attrs=...) at /home/mozhucy/qemu-3.0.0/memory.c:527</span><br><span class="line">#18 0x000055555585cdce in access_with_adjusted_size (addr=217, value=0x7fffeedc37e8, size=1, access_size_min=1, access_size_max=4, access_fn=0x55555585cacc &lt;memory_region_write_accessor&gt;, mr=0x5555578b57c0, attrs=...) at /home/mozhucy/qemu-3.0.0/memory.c:594</span><br><span class="line">#19 0x000055555585f9f6 in memory_region_dispatch_write (mr=0x5555578b57c0, addr=217, data=64, size=1, attrs=...) at /home/mozhucy/qemu-3.0.0/memory.c:1473</span><br><span class="line">#20 0x00005555557fba28 in flatview_write_continue (fv=0x7fffe017c000, addr=4273803481, attrs=..., buf=0x7ffff7ff0028 "@\020", len=1, addr1=217, l=1, mr=0x5555578b57c0) at /home/mozhucy/qemu-3.0.0/exec.c:3255</span><br><span class="line">#21 0x00005555557fbb72 in flatview_write (fv=0x7fffe017c000, addr=4273803481, attrs=..., buf=0x7ffff7ff0028 "@\020", len=1) at /home/mozhucy/qemu-3.0.0/exec.c:3294</span><br><span class="line">#22 0x00005555557fbe78 in address_space_write (as=0x5555566e6640 &lt;address_space_memory&gt;, addr=4273803481, attrs=..., buf=0x7ffff7ff0028 "@\020", len=1) at /home/mozhucy/qemu-3.0.0/exec.c:3384</span><br><span class="line">#23 0x00005555557fbec9 in address_space_rw (as=0x5555566e6640 &lt;address_space_memory&gt;, addr=4273803481, attrs=..., buf=0x7ffff7ff0028 "@\020", len=1, is_write=true) at /home/mozhucy/qemu-3.0.0/exec.c:3395</span><br><span class="line">#24 0x000055555587ac06 in kvm_cpu_exec (cpu=0x555556833070) at /home/mozhucy/qemu-3.0.0/accel/kvm/kvm-all.c:1979</span><br><span class="line">#25 0x0000555555841f35 in qemu_kvm_cpu_thread_fn (arg=0x555556833070) at /home/mozhucy/qemu-3.0.0/cpus.c:1215</span><br><span class="line">#26 0x0000555555d668d7 in qemu_thread_start (args=0x555556854b30) at /home/mozhucy/qemu-3.0.0/util/qemu-thread-posix.c:504</span><br><span class="line">#27 0x00007ffff62526ba in start_thread (arg=0x7fffeedc4700) at pthread_create.c:333</span><br><span class="line">#28 0x00007ffff5f8841d in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:109</span><br></pre></td></tr></tbody></table></figure>
<p>可以看到还是很多的调用流程,不过大概可以梳理出一个流程,28-24属于kvm/多CPU初始化的过程,23-17属于内存的处理过程,16-12属于网卡虚拟化内部的数据流处理流程,11-0属于qemu对于数据包的底层调用,也就是qemu网络的后端实现</p>
<p>There are two parts to networking within QEMU:</p>
<ul>
<li>the virtual network device that is provided to the guest (e.g. a PCI network card).</li>
<li>the network backend that interacts with the emulated NIC (e.g. puts packets onto the host’s network).</li>
</ul>
<p>slirp_input函数作为入口</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">net_slirp_receive</span><span class="params">(NetClientState *nc, <span class="type">const</span> <span class="type">uint8_t</span> *buf, <span class="type">size_t</span> size)</span></span><br><span class="line">{</span><br><span class="line">    SlirpState *s = DO_UPCAST(SlirpState, nc, nc);</span><br><span class="line"></span><br><span class="line">    slirp_input(s-&gt;slirp, buf, size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
	

	</div>
  <a type="button" href="/posts/2b89.html#more" class="btn btn-default more">阅读此文</a>
</div>

-->
<div class="entry">
  <div class="row">
	
	
		<h1 id="一切皆socket"><a class="markdownIt-Anchor" href="#一切皆socket"></a> 一切皆socket</h1>
<p>socket起源于UNIX,可以看出来socket完美的贴合了UNIX一切皆文件的编程思想.我们可以对socket描述符进行ORW的操作,类似普通文件.</p>
<p>在网络编程中,都是由socket实现的,在linux中,socket由上层的libc中的socket和内核中的socket两部分组成,当然为了和硬件交互,最后还需要控制网卡驱动,才是一个完整的体系.</p>
<p>这里我们可以进行一个完整流程的追踪,直接断在tcp_emu上.然后查看调用栈,回溯一下</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">#0  tcp_emu (so=0x7fffe0193ed0, m=0x7fffe0180e20) at /home/mozhucy/qemu-3.0.0/slirp/tcp_subr.c:617</span><br><span class="line">#1  0x0000555555bfc697 in tcp_input (m=0x7fffe0180e20, iphlen=20, inso=0x0, af=2) at /home/mozhucy/qemu-3.0.0/slirp/tcp_input.c:572</span><br><span class="line">#2  0x0000555555bf35c7 in ip_input (m=0x7fffe0180e20) at /home/mozhucy/qemu-3.0.0/slirp/ip_input.c:206</span><br><span class="line">#3  0x0000555555bf6a4a in slirp_input (slirp=0x55555680c500, pkt=0x7fffe02f2700 "RU\n", pkt_len=1334) at /home/mozhucy/qemu-3.0.0/slirp/slirp.c:874</span><br><span class="line">#4  0x0000555555bdf408 in net_slirp_receive (nc=0x55555680c350, buf=0x7fffe02f2700 "RU\n", size=1334) at /home/mozhucy/qemu-3.0.0/net/slirp.c:121</span><br><span class="line">#5  0x0000555555bd5117 in nc_sendv_compat (nc=0x55555680c350, iov=0x7fffeedc3310, iovcnt=1, flags=0) at /home/mozhucy/qemu-3.0.0/net/net.c:701</span><br><span class="line">#6  0x0000555555bd51d9 in qemu_deliver_packet_iov (sender=0x5555578b7d90, flags=0, iov=0x7fffeedc3310, iovcnt=1, opaque=0x55555680c350) at /home/mozhucy/qemu-3.0.0/net/net.c:728</span><br><span class="line">#7  0x0000555555bd7b08 in qemu_net_queue_deliver (queue=0x55555680c290, sender=0x5555578b7d90, flags=0, data=0x7fffe02f2700 "RU\n", size=1334) at /home/mozhucy/qemu-3.0.0/net/queue.c:164</span><br><span class="line">#8  0x0000555555bd7c24 in qemu_net_queue_send (queue=0x55555680c290, sender=0x5555578b7d90, flags=0, data=0x7fffe02f2700 "RU\n", size=1334, sent_cb=0x0) at /home/mozhucy/qemu-3.0.0/net/queue.c:199</span><br><span class="line">#9  0x0000555555bd4f7e in qemu_send_packet_async_with_flags (sender=0x5555578b7d90, flags=0, buf=0x7fffe02f2700 "RU\n", size=1334, sent_cb=0x0) at /home/mozhucy/qemu-3.0.0/net/net.c:655</span><br><span class="line">#10 0x0000555555bd4fb6 in qemu_send_packet_async (sender=0x5555578b7d90, buf=0x7fffe02f2700 "RU\n", size=1334, sent_cb=0x0) at /home/mozhucy/qemu-3.0.0/net/net.c:662</span><br><span class="line">#11 0x0000555555bd4fe3 in qemu_send_packet (nc=0x5555578b7d90, buf=0x7fffe02f2700 "RU\n", size=1334) at /home/mozhucy/qemu-3.0.0/net/net.c:668</span><br><span class="line">#12 0x0000555555aeb758 in rtl8139_transfer_frame (s=0x5555578b2d30, buf=0x7fffe02f2700 "RU\n", size=1334, do_interrupt=1, dot1q_buf=0x0) at /home/mozhucy/qemu-3.0.0/hw/net/rtl8139.c:1804</span><br><span class="line">#13 0x0000555555aecb73 in rtl8139_cplus_transmit_one (s=0x5555578b2d30) at /home/mozhucy/qemu-3.0.0/hw/net/rtl8139.c:2332</span><br><span class="line">#14 0x0000555555aecc31 in rtl8139_cplus_transmit (s=0x5555578b2d30) at /home/mozhucy/qemu-3.0.0/hw/net/rtl8139.c:2359</span><br><span class="line">#15 0x0000555555aed8a2 in rtl8139_io_writeb (opaque=0x5555578b2d30, addr=217 '\331', val=64) at /home/mozhucy/qemu-3.0.0/hw/net/rtl8139.c:2742</span><br><span class="line">#16 0x0000555555aee87f in rtl8139_ioport_write (opaque=0x5555578b2d30, addr=217, val=64, size=1) at /home/mozhucy/qemu-3.0.0/hw/net/rtl8139.c:3279</span><br><span class="line">#17 0x000055555585cbb6 in memory_region_write_accessor (mr=0x5555578b57c0, addr=217, value=0x7fffeedc37e8, size=1, shift=0, mask=255, attrs=...) at /home/mozhucy/qemu-3.0.0/memory.c:527</span><br><span class="line">#18 0x000055555585cdce in access_with_adjusted_size (addr=217, value=0x7fffeedc37e8, size=1, access_size_min=1, access_size_max=4, access_fn=0x55555585cacc &lt;memory_region_write_accessor&gt;, mr=0x5555578b57c0, attrs=...) at /home/mozhucy/qemu-3.0.0/memory.c:594</span><br><span class="line">#19 0x000055555585f9f6 in memory_region_dispatch_write (mr=0x5555578b57c0, addr=217, data=64, size=1, attrs=...) at /home/mozhucy/qemu-3.0.0/memory.c:1473</span><br><span class="line">#20 0x00005555557fba28 in flatview_write_continue (fv=0x7fffe017c000, addr=4273803481, attrs=..., buf=0x7ffff7ff0028 "@\020", len=1, addr1=217, l=1, mr=0x5555578b57c0) at /home/mozhucy/qemu-3.0.0/exec.c:3255</span><br><span class="line">#21 0x00005555557fbb72 in flatview_write (fv=0x7fffe017c000, addr=4273803481, attrs=..., buf=0x7ffff7ff0028 "@\020", len=1) at /home/mozhucy/qemu-3.0.0/exec.c:3294</span><br><span class="line">#22 0x00005555557fbe78 in address_space_write (as=0x5555566e6640 &lt;address_space_memory&gt;, addr=4273803481, attrs=..., buf=0x7ffff7ff0028 "@\020", len=1) at /home/mozhucy/qemu-3.0.0/exec.c:3384</span><br><span class="line">#23 0x00005555557fbec9 in address_space_rw (as=0x5555566e6640 &lt;address_space_memory&gt;, addr=4273803481, attrs=..., buf=0x7ffff7ff0028 "@\020", len=1, is_write=true) at /home/mozhucy/qemu-3.0.0/exec.c:3395</span><br><span class="line">#24 0x000055555587ac06 in kvm_cpu_exec (cpu=0x555556833070) at /home/mozhucy/qemu-3.0.0/accel/kvm/kvm-all.c:1979</span><br><span class="line">#25 0x0000555555841f35 in qemu_kvm_cpu_thread_fn (arg=0x555556833070) at /home/mozhucy/qemu-3.0.0/cpus.c:1215</span><br><span class="line">#26 0x0000555555d668d7 in qemu_thread_start (args=0x555556854b30) at /home/mozhucy/qemu-3.0.0/util/qemu-thread-posix.c:504</span><br><span class="line">#27 0x00007ffff62526ba in start_thread (arg=0x7fffeedc4700) at pthread_create.c:333</span><br><span class="line">#28 0x00007ffff5f8841d in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:109</span><br></pre></td></tr></tbody></table></figure>
<p>可以看到还是很多的调用流程,不过大概可以梳理出一个流程,28-24属于kvm/多CPU初始化的过程,23-17属于内存的处理过程,16-12属于网卡虚拟化内部的数据流处理流程,11-0属于qemu对于数据包的底层调用,也就是qemu网络的后端实现</p>
<p>There are two parts to networking within QEMU:</p>
<ul>
<li>the virtual network device that is provided to the guest (e.g. a PCI network card).</li>
<li>the network backend that interacts with the emulated NIC (e.g. puts packets onto the host’s network).</li>
</ul>
<p>slirp_input函数作为入口</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">net_slirp_receive</span><span class="params">(NetClientState *nc, <span class="type">const</span> <span class="type">uint8_t</span> *buf, <span class="type">size_t</span> size)</span></span><br><span class="line">{</span><br><span class="line">    SlirpState *s = DO_UPCAST(SlirpState, nc, nc);</span><br><span class="line"></span><br><span class="line">    slirp_input(s-&gt;slirp, buf, size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
	
	</div>
  <a type="button" href="/posts/2b89.html#more" class="btn btn-default more">阅读此文</a>
</div>

		

		</div>

		<!-- pagination -->
		<div>
  		<center>
		<div class="pagination">

   
    
     <a href="/" type="button" class="btn btn-default"><i class="fa fa-arrow-circle-o-left"></i> 上一页</a>
      

        <a href="/" type="button" class="btn btn-default"><i class="fa fa-home"></i>Home</a>
 
          <a type="button" class="btn btn-default disabled">下一页<i class="fa fa-arrow-circle-o-right"></i></a>
        

  
</div>

  		</center>
		</div>

		
		
	</div> <!-- col-md-9 -->

	
		<div class="col-md-3">
	<div id="sidebar">
	
			
  <div id="site_search">
   <div class="form-group">
    <input type="text" id="local-search-input" name="q" results="0" placeholder="搜索" class="st-search-input st-default-search-input form-control"/>
   </div>  
  <div id="local-search-result"></div>
  </div>


		
			
	<div class="widget">
		<h4>分类</h4>
		<ul class="tag_box inline list-unstyled">
		
			<li><a href="/categories/Algorithm/">Algorithm<span>2</span></a></li>
		
			<li><a href="/categories/Blog/">Blog<span>1</span></a></li>
		
			<li><a href="/categories/PWN/">PWN<span>1</span></a></li>
		
			<li><a href="/categories/Reverse/">Reverse<span>5</span></a></li>
		
			<li><a href="/categories/System/">System<span>1</span></a></li>
		
			<li><a href="/categories/kernel/">kernel<span>6</span></a></li>
		
			<li><a href="/categories/language/">language<span>14</span></a></li>
		
			<li><a href="/categories/tools/">tools<span>4</span></a></li>
		
		</ul>
	</div>

		
			
	<div class="widget">
		<h4>标签云</h4>
		<ul class="tag_box inline list-unstyled">		
		
			<li><a href="/tags/VS-Code/">VS Code<span>1</span></a></li>
		
			<li><a href="/tags/matery/">matery<span>1</span></a></li>
		
			<li><a href="/tags/Markdown/">Markdown<span>1</span></a></li>
		
			<li><a href="/tags/kernel-programm/">kernel programm<span>6</span></a></li>
		
			<li><a href="/tags/C/">C++<span>12</span></a></li>
		
			<li><a href="/tags/Data-Structure/">Data Structure<span>2</span></a></li>
		
			<li><a href="/tags/Hexo/">Hexo<span>1</span></a></li>
		
			<li><a href="/tags/Crack/">Crack<span>2</span></a></li>
		
			<li><a href="/tags/Python/">Python<span>1</span></a></li>
		
			<li><a href="/tags/Reverse/">Reverse<span>3</span></a></li>
		
			<li><a href="/tags/LaTex/">LaTex<span>1</span></a></li>
		
			<li><a href="/tags/Shelling-method/">Shelling method<span>1</span></a></li>
		
			<li><a href="/tags/get/">get<span>2</span></a></li>
		
		 
		</ul>
	</div>


		
			
<div class="widget">
  <h4>最新文章</h4>
  <ul class="entry list-unstyled">
    
      <li>
        <a href="/posts/8998.html" ><i class="fa fa-file-o"></i>Python字符串</a>
      </li>
    
      <li>
        <a href="/posts/d40c.html" ><i class="fa fa-file-o"></i>微信电脑版多开、防撤回破解</a>
      </li>
    
      <li>
        <a href="/posts/aecd.html" ><i class="fa fa-file-o"></i>注册表</a>
      </li>
    
      <li>
        <a href="/posts/d839.html" ><i class="fa fa-file-o"></i>对象与句柄</a>
      </li>
    
      <li>
        <a href="/posts/16c1.html" ><i class="fa fa-file-o"></i>C/C++ volatile</a>
      </li>
    
  </ul>
</div>

		
			
<div class="widget">
	<h4>链接</h4>
	<ul class="blogroll list-unstyled">
	
		<li><i class="false"></i><a href="https://github.com/Ares-X/hexo-theme-freemind.bithack" title="" target="_blank"]);">hexo-theme-bithack</a></li>
	
	</ul>
</div>


		
	</div> <!-- sidebar -->
</div> <!-- col-md-3 -->

	
	
</div> <!-- row-fluid -->
	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  
  &copy; 2022 Heisenberg Lee's Blog
  
      powered by <a href="http://hexo.io/" target="_blank">Hexo</a>.Theme <a href="https://github.com/Ares-X/hexo-theme-freemind.bithack" target="_blank">freemind.bithack</a>  
</p>
 </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>⬆︎TOP</span>
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>


        <script src="//cdn.jsdelivr.net/npm/js-base64/base64.min.js"></script>
        <script>
        $('a').each(function() {
          const $this = $(this);
          const href = $this.attr('href');
          if (href && href.match('^((http|https|thunder|qqdl|ed2k|Flashget|qbrowser|ftp|rtsp|mms)://)')) {
            const strs = href.split('/');
            if (strs.length >= 3) {
                const host = strs[2];
                if (host !== 'tlhg.top' || window.location.host) {
                    $this.attr('href', '/go.html?u='+Base64.encode(href)+'').attr('rel', 'external nofollow noopener noreferrer');
                    if (true) {
                        $this.attr('target', '_blank');
                    }
                }
            }
          }
        });
        </script></body>
   </html>
