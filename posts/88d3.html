<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="pragma" content="no-cache">
  <meta http-equiv="cache-control" content="no-cache">
  <meta http-equiv="expires" content="0">
  
  <title>Chapter07-类.md | tlhg&#39;s Blog|</title>
  <meta name="author" content="Heisenberg Lee">
  
  <meta name="description" content="学习记录。">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="Chapter07-类.md"/>
  <meta property="og:site_name" content="tlhg&#39;s Blog|"/>

  
    <meta property="og:image" content="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200803213512.png" />
  

  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-70812759-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-70812759-1');
</script>






<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="tlhg's Blog|" type="application/atom+xml">
</head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">tlhg&#39;s Blog|</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class=""></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class=""></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/tags" title="All the tags.">
			  <i class=""></i>Tags
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class=""></i>About
			</a>
		  </li>
		  
		  <li>
			<a href="/atom.xml" title="Subscribe me.">
			  <i class=""></i>RSS
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 


	
		<div class="page-header">
			<h1> Chapter07-类.md</h1>
		</div>
	



<div class="row post">
	<!-- cols -->
	
	<div id="top_meta"></div>
	<div class="col-md-9">
	

	<!-- content -->
	<div class="mypage">		
	  		

	  <p>类的基本思想是数据抽象（data abstraction）和封装（encapsulation）。数据抽象是一种依赖于接口（interface）和实现（implementation）分离的编程及设计技术。类的接口包括用户所能执行的操作；类的实现包括类的数据成员、负责接口实现的函数体以及其他私有函数。</p>
<h2 id="定义抽象数据类型defining-abstract-data-types"><a class="markdownIt-Anchor" href="#定义抽象数据类型defining-abstract-data-types"></a> 定义抽象数据类型（Defining Abstract Data Types）</h2>
<h3 id="设计sales_data类designing-the-sales_data-class"><a class="markdownIt-Anchor" href="#设计sales_data类designing-the-sales_data-class"></a> 设计Sales_data类（Designing the Sales_data Class）</h3>
<p>类的用户是程序员，而非应用程序的最终使用者。</p>
<h3 id="定义改进的sales_data类defining-the-revised-sales_data-class"><a class="markdownIt-Anchor" href="#定义改进的sales_data类defining-the-revised-sales_data-class"></a> 定义改进的Sales_data类（Defining the Revised Sales_data Class）</h3>
<p>成员函数（member function）的声明必须在类的内部，定义则既可以在类的内部也可以在类的外部。定义在类内部的函数是隐式的内联函数。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Sales_data</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// new members: operations on Sales_data objects</span></span><br><span class="line">    <span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> bookNo; }</span><br><span class="line">    <span class="function">Sales_data&amp; <span class="title">combine</span><span class="params">(<span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">avg_price</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// data members</span></span><br><span class="line">    std::string bookNo;</span><br><span class="line">    <span class="type">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>成员函数通过一个名为<code>this</code>的隐式额外参数来访问调用它的对象。<code>this</code>参数是一个常量指针，被初始化为调用该函数的对象地址。在函数体内可以显式使用<code>this</code>指针。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">total.<span class="built_in">isbn</span>()</span><br><span class="line"><span class="comment">// pseudo-code illustration of how a call to a member function is translated</span></span><br><span class="line">Sales_data::<span class="built_in">isbn</span>(&amp;total)</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> <span class="keyword">this</span>-&gt;bookNo; }</span><br><span class="line"><span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> bookNo; }</span><br></pre></td></tr></tbody></table></figure>
<p>默认情况下，<code>this</code>的类型是指向类类型非常量版本的常量指针。<code>this</code>也遵循初始化规则，所以默认不能把<code>this</code>绑定到一个常量对象上，即不能在常量对象上调用普通的成员函数。</p>
<p>C++允许在成员函数的参数列表后面添加关键字<code>const</code>，表示<code>this</code>是一个指向常量的指针。使用关键字<code>const</code>的成员函数被称作常量成员函数（const member function）。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// pseudo-code illustration of how the implicit this pointer is used</span></span><br><span class="line"><span class="comment">// this code is illegal: we may not explicitly define the this pointer ourselves</span></span><br><span class="line"><span class="comment">// note that this is a pointer to const because isbn is a const member</span></span><br><span class="line"><span class="function">std::string <span class="title">Sales_data::isbn</span><span class="params">(<span class="type">const</span> Sales_data *<span class="type">const</span> <span class="keyword">this</span>)</span></span></span><br><span class="line"><span class="function"></span>{ </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;isbn;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>常量对象和指向常量对象的引用或指针都只能调用常量成员函数。</p>
<p>类本身就是一个作用域，成员函数的定义嵌套在类的作用域之内。编译器处理类时，会先编译成员声明，再编译成员函数体（如果有的话），因此成员函数可以随意使用类的其他成员而无须在意这些成员的出现顺序。</p>
<p>在类的外部定义成员函数时，成员函数的定义必须与它的声明相匹配。如果成员函数被声明为常量成员函数，那么它的定义也必须在参数列表后面指定<code>const</code>属性。同时，类外部定义的成员名字必须包含它所属的类名。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">Sales_data::avg_price</span><span class="params">()</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (units_sold)</span><br><span class="line">        <span class="keyword">return</span> revenue / units_sold;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>可以定义返回<code>this</code>对象的成员函数。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">Sales_data&amp; <span class="title">Sales_data::combine</span><span class="params">(<span class="type">const</span> Sales_data &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    units_sold += rhs.units_sold;   <span class="comment">// add the members of rhs into</span></span><br><span class="line">    revenue += rhs.revenue;     <span class="comment">// the members of 'this' object</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;       <span class="comment">// return the object on which the function was called</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="定义类相关的非成员函数defining-nonmember-class-related-functions"><a class="markdownIt-Anchor" href="#定义类相关的非成员函数defining-nonmember-class-related-functions"></a> 定义类相关的非成员函数（Defining Nonmember Class-Related Functions）</h3>
<p>类的作者通常会定义一些辅助函数，尽管这些函数从概念上来说属于类接口的组成部分，但实际上它们并不属于类本身。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// input transactions contain ISBN, number of copies sold, and sales price</span></span><br><span class="line"><span class="function">istream &amp;<span class="title">read</span><span class="params">(istream &amp;is, Sales_data &amp;item)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">double</span> price = <span class="number">0</span>;</span><br><span class="line">    is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price;</span><br><span class="line">    item.revenue = price * item.units_sold;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="type">const</span> Sales_data &amp;item)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    os &lt;&lt; item.<span class="built_in">isbn</span>() &lt;&lt; <span class="string">" "</span> &lt;&lt; item.units_sold &lt;&lt; <span class="string">" "</span></span><br><span class="line">        &lt;&lt; item.revenue &lt;&lt; <span class="string">" "</span> &lt;&lt; item.<span class="built_in">avg_price</span>();</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>如果非成员函数是类接口的组成部分，则这些函数的声明应该与类放在同一个头文件中。</p>
<p>一般来说，执行输出任务的函数应该尽量减少对格式的控制。</p>
<h3 id="构造函数constructors"><a class="markdownIt-Anchor" href="#构造函数constructors"></a> 构造函数（Constructors）</h3>
<p>类通过一个或几个特殊的成员函数来控制其对象的初始化操作，这些函数被称作构造函数。只要类的对象被创建，就会执行构造函数。</p>
<p>构造函数的名字和类名相同，没有返回类型，且不能被声明为<code>const</code>函数。构造函数在<code>const</code>对象的构造过程中可以向其写值。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Sales_data</span> </span><br><span class="line">{</span><br><span class="line">    <span class="comment">// constructors added</span></span><br><span class="line">    <span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="type">const</span> std::string &amp;s): <span class="built_in">bookNo</span>(s) { }</span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="type">const</span> std::string &amp;s, <span class="type">unsigned</span> n, <span class="type">double</span> p):</span><br><span class="line">        <span class="built_in">bookNo</span>(s), <span class="built_in">units_sold</span>(n), <span class="built_in">revenue</span>(p*n) { }</span><br><span class="line">    <span class="built_in">Sales_data</span>(std::istream &amp;);</span><br><span class="line">    <span class="comment">// other members as before</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>类通过默认构造函数（default constructor）来控制默认初始化过程，默认构造函数无须任何实参。</p>
<p>如果类没有显式地定义构造函数，则编译器会为类隐式地定义一个默认构造函数，该构造函数也被称为合成的默认构造函数（synthesized default constructor）。对于大多数类来说，合成的默认构造函数初始化数据成员的规则如下：</p>
<ul>
<li>如果存在类内初始值，则用它来初始化成员。</li>
<li>否则默认初始化该成员。</li>
</ul>
<p>某些类不能依赖于合成的默认构造函数。</p>
<ul>
<li>只有当类没有声明任何构造函数时，编译器才会自动生成默认构造函数。一旦类定义了其他构造函数，那么除非再显式地定义一个默认的构造函数，否则类将没有默认构造函数。</li>
<li>如果类包含内置类型或者复合类型的成员，则只有当这些成员全部存在类内初始值时，这个类才适合使用合成的默认构造函数。否则用户在创建类的对象时就可能得到未定义的值。</li>
<li>编译器不能为某些类合成默认构造函数。例如类中包含一个其他类类型的成员，且该类型没有默认构造函数，那么编译器将无法初始化该成员。</li>
</ul>
<p>在C++11中，如果类需要默认的函数行为，可以通过在参数列表后面添加<code>=default</code>来要求编译器生成构造函数。其中<code>=default</code>既可以和函数声明一起出现在类的内部，也可以作为定义出现在类的外部。和其他函数一样，如果<code>=default</code>在类的内部，则默认构造函数是内联的。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>构造函数初始值列表（constructor initializer list）负责为新创建对象的一个或几个数据成员赋初始值。形式是每个成员名字后面紧跟括号括起来的（或者在花括号内的）成员初始值，不同成员的初始值通过逗号分隔。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">Sales_data</span>(<span class="type">const</span> std::string &amp;s): <span class="built_in">bookNo</span>(s) { }</span><br><span class="line"><span class="built_in">Sales_data</span>(<span class="type">const</span> std::string &amp;s, <span class="type">unsigned</span> n, <span class="type">double</span> p):</span><br><span class="line">    <span class="built_in">bookNo</span>(s), <span class="built_in">units_sold</span>(n), <span class="built_in">revenue</span>(p*n) { }</span><br></pre></td></tr></tbody></table></figure>
<p>当某个数据成员被构造函数初始值列表忽略时，它会以与合成默认构造函数相同的方式隐式初始化。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// has the same behavior as the original constructor defined above</span></span><br><span class="line"><span class="built_in">Sales_data</span>(<span class="type">const</span> std::string &amp;s):</span><br><span class="line">    <span class="built_in">bookNo</span>(s), <span class="built_in">units_sold</span>(<span class="number">0</span>), <span class="built_in">revenue</span>(<span class="number">0</span>) { }</span><br></pre></td></tr></tbody></table></figure>
<p>构造函数不应该轻易覆盖掉类内初始值，除非新值与原值不同。如果编译器不支持类内初始值，则所有构造函数都应该显式初始化每个内置类型的成员。</p>
<h3 id="拷贝-赋值和析构copy-assignmentand-destruction"><a class="markdownIt-Anchor" href="#拷贝-赋值和析构copy-assignmentand-destruction"></a> 拷贝、赋值和析构（Copy、Assignment，and Destruction）</h3>
<p>编译器能合成拷贝、赋值和析构函数，但是对于某些类来说合成的版本无法正常工作。特别是当类需要分配类对象之外的资源时，合成的版本通常会失效。</p>
<h2 id="访问控制与封装access-control-and-encapsulation"><a class="markdownIt-Anchor" href="#访问控制与封装access-control-and-encapsulation"></a> 访问控制与封装（Access Control and Encapsulation）</h2>
<p>使用访问说明符（access specifier）可以加强类的封装性：</p>
<ul>
<li>定义在<code>public</code>说明符之后的成员在整个程序内都可以被访问。<code>public</code>成员定义类的接口。</li>
<li>定义在<code>private</code>说明符之后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问。<code>private</code>部分封装了类的实现细节。</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span> </span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>: <span class="comment">// access specifier added</span></span><br><span class="line">    <span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="type">const</span> std::string &amp;s, <span class="type">unsigned</span> n, <span class="type">double</span> p):</span><br><span class="line">    <span class="built_in">bookNo</span>(s), <span class="built_in">units_sold</span>(n), <span class="built_in">revenue</span>(p*n) { }</span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="type">const</span> std::string &amp;s): <span class="built_in">bookNo</span>(s) { }</span><br><span class="line">    <span class="built_in">Sales_data</span>(std::istream&amp;);</span><br><span class="line">    <span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> bookNo; }</span><br><span class="line">    <span class="function">Sales_data &amp;<span class="title">combine</span><span class="params">(<span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>: <span class="comment">// access specifier added</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">avg_price</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> units_sold ? revenue/units_sold : <span class="number">0</span>; }   </span><br><span class="line">    std::string bookNo;</span><br><span class="line">    <span class="type">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>一个类可以包含零或多个访问说明符，每个访问说明符指定了接下来的成员的访问级别，其有效范围到出现下一个访问说明符或类的结尾处为止。</p>
<p>使用关键字<code>struct</code>定义类时，定义在第一个访问说明符之前的成员是<code>public</code>的；而使用关键字<code>class</code>时，这些成员是<code>private</code>的。二者唯一的区别就是默认访问权限不同。</p>
<h3 id="友元friends"><a class="markdownIt-Anchor" href="#友元friends"></a> 友元（Friends）</h3>
<p>类可以允许其他类或函数访问它的非公有成员，方法是使用关键字<code>friend</code>将其他类或函数声明为它的友元。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span> </span><br><span class="line">{</span><br><span class="line">    <span class="comment">// friend declarations for nonmember Sales_data operations added</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> Sales_data <span class="title">add</span><span class="params">(<span class="type">const</span> Sales_data&amp;, <span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> std::istream &amp;<span class="title">read</span><span class="params">(std::istream&amp;, Sales_data&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> std::ostream &amp;<span class="title">print</span><span class="params">(std::ostream&amp;, <span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// other members and access specifiers as before</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="type">const</span> std::string &amp;s, <span class="type">unsigned</span> n, <span class="type">double</span> p):</span><br><span class="line">    <span class="built_in">bookNo</span>(s), <span class="built_in">units_sold</span>(n), <span class="built_in">revenue</span>(p*n) { }</span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="type">const</span> std::string &amp;s): <span class="built_in">bookNo</span>(s) { }</span><br><span class="line">    <span class="built_in">Sales_data</span>(std::istream&amp;);</span><br><span class="line">    <span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> bookNo; }</span><br><span class="line">    <span class="function">Sales_data &amp;<span class="title">combine</span><span class="params">(<span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string bookNo;</span><br><span class="line">    <span class="type">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// declarations for nonmember parts of the Sales_data interface</span></span><br><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="type">const</span> Sales_data&amp;, <span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="function">std::istream &amp;<span class="title">read</span><span class="params">(std::istream&amp;, Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="function">std::ostream &amp;<span class="title">print</span><span class="params">(std::ostream&amp;, <span class="type">const</span> Sales_data&amp;)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>友元声明只能出现在类定义的内部，具体位置不限。友元不是类的成员，也不受它所在区域访问级别的约束。</p>
<p>通常情况下，最好在类定义开始或结束前的位置集中声明友元。</p>
<p>封装的好处：</p>
<ul>
<li>确保用户代码不会无意间破坏封装对象的状态。</li>
<li>被封装的类的具体实现细节可以随时改变，而无须调整用户级别的代码。</li>
</ul>
<p>友元声明仅仅指定了访问权限，而并非一个通常意义上的函数声明。如果希望类的用户能调用某个友元函数，就必须在友元声明之外再专门对函数进行一次声明（部分编译器没有该限制）。</p>
<p>为了使友元对类的用户可见，通常会把友元的声明（类的外部）与类本身放在同一个头文件中。</p>
<h2 id="类的其他特性additional-class-features"><a class="markdownIt-Anchor" href="#类的其他特性additional-class-features"></a> 类的其他特性（Additional Class Features）</h2>
<h3 id="类成员再探class-members-revisited"><a class="markdownIt-Anchor" href="#类成员再探class-members-revisited"></a> 类成员再探（Class Members Revisited）</h3>
<p>由类定义的类型名字和其他成员一样存在访问限制，可以是<code>public</code>或<code>private</code>中的一种。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span> </span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// alternative way to declare a type member using a type alias</span></span><br><span class="line">    <span class="keyword">using</span> pos = std::string::size_type;</span><br><span class="line">    <span class="comment">// other members as before</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>与普通成员不同，用来定义类型的成员必须先定义后使用。类型成员通常位于类起始处。</p>
<p>定义在类内部的成员函数是自动内联的。</p>
<p>如果需要显式声明内联成员函数，建议只在类外部定义的位置说明<code>inline</code>。</p>
<p><code>inline</code>成员函数该与类定义在同一个头文件中。</p>
<p>使用关键字<code>mutable</code>可以声明可变数据成员（mutable data member）。可变数据成员永远不会是<code>const</code>的，即使它在<code>const</code>对象内。因此<code>const</code>成员函数可以修改可变成员的值。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span> </span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">some_member</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">size_t</span> access_ctr;  <span class="comment">// may change even in a const object</span></span><br><span class="line">    <span class="comment">// other members as before</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Screen::some_member</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    ++access_ctr;   <span class="comment">// keep a count of the calls to any member function</span></span><br><span class="line">    <span class="comment">// whatever other work this member needs to do</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>提供类内初始值时，必须使用<code>=</code>或花括号形式。</p>
<h3 id="返回this的成员函数functions-that-return-this"><a class="markdownIt-Anchor" href="#返回this的成员函数functions-that-return-this"></a> 返回*this的成员函数（Functions That Return *this）</h3>
<p><code>const</code>成员函数如果以引用形式返回<code>*this</code>，则返回类型是常量引用。</p>
<p>通过区分成员函数是否为<code>const</code>的，可以对其进行重载。在常量对象上只能调用<code>const</code>版本的函数；在非常量对象上，尽管两个版本都能调用，但会选择非常量版本。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span> </span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// display overloaded on whether the object is const or not</span></span><br><span class="line">    <span class="function">Screen &amp;<span class="title">display</span><span class="params">(std::ostream &amp;os)</span></span></span><br><span class="line"><span class="function">    </span>{ <span class="built_in">do_display</span>(os); <span class="keyword">return</span> *<span class="keyword">this</span>; }</span><br><span class="line">    <span class="function"><span class="type">const</span> Screen &amp;<span class="title">display</span><span class="params">(std::ostream &amp;os)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>{ <span class="built_in">do_display</span>(os); <span class="keyword">return</span> *<span class="keyword">this</span>; }</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// function to do the work of displaying a Screen</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">do_display</span><span class="params">(std::ostream &amp;os)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>{ os &lt;&lt; contents; }</span><br><span class="line">    <span class="comment">// other members as before</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function">Screen <span class="title">myScreen</span><span class="params">(<span class="number">5</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">const</span> Screen <span class="title">blank</span><span class="params">(<span class="number">5</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">myScreen.<span class="built_in">set</span>(<span class="string">'#'</span>).<span class="built_in">display</span>(cout);    <span class="comment">// calls non const version</span></span><br><span class="line">blank.<span class="built_in">display</span>(cout);    <span class="comment">// calls const version</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="类类型class-types"><a class="markdownIt-Anchor" href="#类类型class-types"></a> 类类型（Class Types）</h3>
<p>每个类定义了唯一的类型。即使两个类的成员列表完全一致，它们也是不同的类型。</p>
<p>可以仅仅声明一个类而暂时不定义它。这种声明被称作前向声明（forward declaration），用于引入类的名字。在类声明之后定义之前都是一个不完全类型（incomplete type）。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span>;   <span class="comment">// declaration of the Screen class</span></span><br></pre></td></tr></tbody></table></figure>
<p>可以定义指向不完全类型的指针或引用，也可以声明（不能定义）以不完全类型作为参数或返回类型的函数。</p>
<p>只有当类全部完成后才算被定义，所以一个类的成员类型不能是该类本身。但是一旦类的名字出现，就可以被认为是声明过了，因此类可以包含指向它自身类型的引用或指针。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Link_screen</span></span><br><span class="line">{</span><br><span class="line">    Screen window;</span><br><span class="line">    Link_screen *next;</span><br><span class="line">    Link_screen *prev;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h3 id="友元再探friendship-revisited"><a class="markdownIt-Anchor" href="#友元再探friendship-revisited"></a> 友元再探（Friendship Revisited）</h3>
<p>除了普通函数，类还可以把其他类或其他类的成员函数声明为友元。友元类的成员函数可以访问此类包括非公有成员在内的所有成员。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span> </span><br><span class="line">{</span><br><span class="line">    <span class="comment">// Window_mgr members can access the private parts of class Screen</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Window_mgr</span>;</span><br><span class="line">    <span class="comment">// ... rest of the Screen class</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>友元函数可以直接定义在类的内部，这种函数是隐式内联的。但是必须在类外部提供相应声明令函数可见。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>{ <span class="comment">/* friend function can be defined in the class body */</span> }</span><br><span class="line">    <span class="built_in">X</span>() { <span class="built_in">f</span>(); }   <span class="comment">// error: no declaration for f</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">h</span><span class="params">()</span></span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">X::g</span><span class="params">()</span> </span>{ <span class="keyword">return</span> <span class="built_in">f</span>(); }     <span class="comment">// error: f hasn't been declared</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;   <span class="comment">// declares the function defined inside X</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">X::h</span><span class="params">()</span> </span>{ <span class="keyword">return</span> <span class="built_in">f</span>(); }     <span class="comment">// ok: declaration for f is now in scope</span></span><br></pre></td></tr></tbody></table></figure>
<p>友元关系不存在传递性。</p>
<p>把其他类的成员函数声明为友元时，必须明确指定该函数所属的类名。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// Window_mgr::clear must have been declared before class Screen</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">Window_mgr::clear</span><span class="params">(ScreenIndex)</span></span>;</span><br><span class="line">    <span class="comment">// ... rest of the Screen class</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>如果类想把一组重载函数声明为友元，需要对这组函数中的每一个分别声明。</p>
<h2 id="类的作用域class-scope"><a class="markdownIt-Anchor" href="#类的作用域class-scope"></a> 类的作用域（Class Scope）</h2>
<p>当成员函数定义在类外时，返回类型中使用的名字位于类的作用域之外，此时返回类型必须指明它是哪个类的成员。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Window_mgr</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// add a Screen to the window and returns its index</span></span><br><span class="line">    <span class="function">ScreenIndex <span class="title">addScreen</span><span class="params">(<span class="type">const</span> Screen&amp;)</span></span>;</span><br><span class="line">    <span class="comment">// other members as before</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// return type is seen before we're in the scope of Window_mgr</span></span><br><span class="line"><span class="function">Window_mgr::ScreenIndex <span class="title">Window_mgr::addScreen</span><span class="params">(<span class="type">const</span> Screen &amp;s)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    screens.<span class="built_in">push_back</span>(s);</span><br><span class="line">    <span class="keyword">return</span> screens.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="名字查找与作用域name-lookup-and-class-scope"><a class="markdownIt-Anchor" href="#名字查找与作用域name-lookup-and-class-scope"></a> 名字查找与作用域（Name Lookup and Class Scope）</h3>
<p>成员函数体直到整个类可见后才会被处理，因此它能使用类中定义的任何名字。</p>
<p>声明中使用的名字，包括返回类型或参数列表，都必须确保使用前可见。</p>
<p>如果类的成员使用了外层作用域的某个名字，而该名字表示一种类型，则类不能在之后重新定义该名字。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> Money;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Money <span class="title">balance</span><span class="params">()</span> </span>{ <span class="keyword">return</span> bal; } <span class="comment">// uses Money from the outer scop</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">double</span> Money; <span class="comment">// error: cannot redefine Money</span></span><br><span class="line">    Money bal;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>类型名定义通常出现在类起始处，这样能确保所有使用该类型的成员都位于类型名定义之后。</p>
<p>成员函数中名字的解析顺序：</p>
<ul>
<li>在成员函数内查找该名字的声明，只有在函数使用之前出现的声明才会被考虑。</li>
<li>如果在成员函数内没有找到，则会在类内继续查找，这时会考虑类的所有成员。</li>
<li>如果类内也没有找到，会在成员函数定义之前的作用域查找。</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// it is generally a bad idea to use the same name for a parameter and a member</span></span><br><span class="line"><span class="type">int</span> height;   <span class="comment">// defines a name subsequently used inside Screen</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> std::string::size_type pos;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dummy_fcn</span><span class="params">(pos height)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        cursor = width * height;  <span class="comment">// which height? the parameter</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    pos cursor = <span class="number">0</span>;</span><br><span class="line">    pos height = <span class="number">0</span>, width = <span class="number">0</span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>可以通过作用域运算符<code>::</code>或显式<code>this</code>指针来强制访问被隐藏的类成员。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// bad practice: names local to member functions shouldn't hide member names</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Screen::dummy_fcn</span><span class="params">(pos height)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cursor = width * <span class="keyword">this</span>-&gt;height;  <span class="comment">// member height</span></span><br><span class="line">    <span class="comment">// alternative way to indicate the member</span></span><br><span class="line">    cursor = width * Screen::height;  <span class="comment">// member height</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// good practice: don't use a member name for a parameter or other local variable</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Screen::dummy_fcn</span><span class="params">(pos ht)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cursor = width * height;  <span class="comment">// member height</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="构造函数再探constructors-revisited"><a class="markdownIt-Anchor" href="#构造函数再探constructors-revisited"></a> 构造函数再探（Constructors Revisited）</h2>
<h3 id="构造函数初始值列表constructor-initializer-list"><a class="markdownIt-Anchor" href="#构造函数初始值列表constructor-initializer-list"></a> 构造函数初始值列表（Constructor Initializer List）</h3>
<p>如果没有在构造函数初始值列表中显式初始化成员，该成员会在构造函数体之前执行默认初始化。</p>
<p>如果成员是<code>const</code>、引用，或者是某种未定义默认构造函数的类类型，必须在初始值列表中将其初始化。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConstRef</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConstRef</span>(<span class="type">int</span> ii);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> ci;</span><br><span class="line">    <span class="type">int</span> &amp;ri;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// ok: explicitly initialize reference and const members</span></span><br><span class="line">ConstRef::<span class="built_in">ConstRef</span>(<span class="type">int</span> ii): <span class="built_in">i</span>(ii), <span class="built_in">ci</span>(ii), <span class="built_in">ri</span>(i) { }</span><br></pre></td></tr></tbody></table></figure>
<p>最好令构造函数初始值的顺序与成员声明的顺序一致，并且尽量避免使用某些成员初始化其他成员。</p>
<p>如果一个构造函数为所有参数都提供了默认实参，则它实际上也定义了默认构造函数。</p>
<h3 id="委托构造函数delegating-constructors"><a class="markdownIt-Anchor" href="#委托构造函数delegating-constructors"></a> 委托构造函数（Delegating Constructors）</h3>
<p>C++11扩展了构造函数初始值功能，可以定义委托构造函数。委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// defines the default constructor as well as one that takes a string argument</span></span><br><span class="line">    <span class="built_in">Sales_data</span>(std::string s = <span class="string">""</span>): <span class="built_in">bookNo</span>(s) { }</span><br><span class="line">    <span class="comment">// remaining constructors unchanged</span></span><br><span class="line">    <span class="built_in">Sales_data</span>(std::string s, <span class="type">unsigned</span> cnt, <span class="type">double</span> rev):</span><br><span class="line">        <span class="built_in">bookNo</span>(s), <span class="built_in">units_sold</span>(cnt), <span class="built_in">revenue</span>(rev*cnt) { }</span><br><span class="line">    <span class="built_in">Sales_data</span>(std::istream &amp;is) { <span class="built_in">read</span>(is, *<span class="keyword">this</span>); }</span><br><span class="line">    <span class="comment">// remaining members as before</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="默认构造函数的作用the-role-of-the-default-constructor"><a class="markdownIt-Anchor" href="#默认构造函数的作用the-role-of-the-default-constructor"></a> 默认构造函数的作用（The Role of the Default Constructor）</h3>
<p>当对象被默认初始化或值初始化时会自动执行默认构造函数。</p>
<p>默认初始化的发生情况：</p>
<ul>
<li>在块作用域内不使用初始值定义非静态变量或数组。</li>
<li>类本身含有类类型的成员且使用合成默认构造函数。</li>
<li>类类型的成员没有在构造函数初始值列表中显式初始化。</li>
</ul>
<p>值初始化的发生情况：</p>
<ul>
<li>数组初始化时提供的初始值数量少于数组大小。</li>
<li>不使用初始值定义局部静态变量。</li>
<li>通过<code>T()</code>形式（<em>T</em>为类型）的表达式显式地请求值初始化。</li>
</ul>
<p>类必须包含一个默认构造函数。</p>
<p>如果想定义一个使用默认构造函数进行初始化的对象，应该去掉对象名后的空括号对。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">Sales_data <span class="title">obj</span><span class="params">()</span></span>;   <span class="comment">// oops! declares a function, not an object</span></span><br><span class="line">Sales_data obj2;    <span class="comment">// ok: obj2 is an object, not a function</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="隐式的类类型转换implicit-class-type-conversions"><a class="markdownIt-Anchor" href="#隐式的类类型转换implicit-class-type-conversions"></a> 隐式的类类型转换（Implicit Class-Type Conversions）</h3>
<p>如果构造函数只接受一个实参，则它实际上定义了转换为此类类型的隐式转换机制。这种构造函数被称为转换构造函数（converting constructor）。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">string null_book = <span class="string">"9-999-99999-9"</span>;</span><br><span class="line"><span class="comment">// constructs a temporary Sales_data object</span></span><br><span class="line"><span class="comment">// with units_sold and revenue equal to 0 and bookNo equal to null_book</span></span><br><span class="line">item.<span class="built_in">combine</span>(null_book);</span><br></pre></td></tr></tbody></table></figure>
<p>编译器只会自动执行一步类型转换。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// error: requires two user-defined conversions:</span></span><br><span class="line"><span class="comment">//   (1) convert "9-999-99999-9" to string</span></span><br><span class="line"><span class="comment">//   (2) convert that (temporary) string to Sales_data</span></span><br><span class="line">item.<span class="built_in">combine</span>(<span class="string">"9-999-99999-9"</span>);</span><br><span class="line"><span class="comment">// ok: explicit conversion to string, implicit conversion to Sales_data</span></span><br><span class="line">item.<span class="built_in">combine</span>(<span class="built_in">string</span>(<span class="string">"9-999-99999-9"</span>));</span><br><span class="line"><span class="comment">// ok: implicit conversion to string, explicit conversion to Sales_data</span></span><br><span class="line">item.<span class="built_in">combine</span>(<span class="built_in">Sales_data</span>(<span class="string">"9-999-99999-9"</span>));</span><br></pre></td></tr></tbody></table></figure>
<p>在要求隐式转换的程序上下文中，可以通过将构造函数声明为<code>explicit</code>的加以阻止。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="type">const</span> std::string &amp;s, <span class="type">unsigned</span> n, <span class="type">double</span> p):</span><br><span class="line">        <span class="built_in">bookNo</span>(s), <span class="built_in">units_sold</span>(n), <span class="built_in">revenue</span>(p*n) { }</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Sales_data</span><span class="params">(<span class="type">const</span> std::string &amp;s)</span>: bookNo(s) {</span> }</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Sales_data</span><span class="params">(std::istream&amp;)</span></span>;</span><br><span class="line">    <span class="comment">// remaining members as before</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p><code>explicit</code>关键字只对接受一个实参的构造函数有效。</p>
<p>只能在类内声明构造函数时使用<code>explicit</code>关键字，在类外定义时不能重复。</p>
<p>执行拷贝初始化时（使用<code>=</code>）会发生隐式转换，所以<code>explicit</code>构造函数只能用于直接初始化。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">Sales_data <span class="title">item1</span> <span class="params">(null_book)</span></span>;   <span class="comment">// ok: direct initialization</span></span><br><span class="line"><span class="comment">// error: cannot use the copy form of initialization with an explicit constructor</span></span><br><span class="line">Sales_data item2 = null_book;</span><br></pre></td></tr></tbody></table></figure>
<p>可以使用<code>explicit</code>构造函数显式地强制转换类型。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// ok: the argument is an explicitly constructed Sales_data object</span></span><br><span class="line">item.<span class="built_in">combine</span>(<span class="built_in">Sales_data</span>(null_book));</span><br><span class="line"><span class="comment">// ok: static_cast can use an explicit constructor</span></span><br><span class="line">item.<span class="built_in">combine</span>(<span class="built_in">static_cast</span>&lt;Sales_data&gt;(cin));</span><br></pre></td></tr></tbody></table></figure>
<h3 id="聚合类aggregate-classes"><a class="markdownIt-Anchor" href="#聚合类aggregate-classes"></a> 聚合类（Aggregate Classes）</h3>
<p>聚合类满足如下条件：</p>
<ul>
<li>所有成员都是<code>public</code>的。</li>
<li>没有定义任何构造函数。</li>
<li>没有类内初始值。</li>
<li>没有基类。</li>
<li>没有虚函数。</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Data</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> ival;</span><br><span class="line">    string s;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>可以使用一个用花括号包围的成员初始值列表初始化聚合类的数据成员。初始值顺序必须与声明顺序一致。如果初始值列表中的元素个数少于类的成员个数，则靠后的成员被值初始化。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// val1.ival = 0; val1.s = string("Anna")</span></span><br><span class="line">Data val1 = { <span class="number">0</span>, <span class="string">"Anna"</span> };</span><br></pre></td></tr></tbody></table></figure>
<h3 id="字面值常量类literal-classes"><a class="markdownIt-Anchor" href="#字面值常量类literal-classes"></a> 字面值常量类（Literal Classes）</h3>
<p>数据成员都是字面值类型的聚合类是字面值常量类。或者一个类不是聚合类，但符合下列条件，则也是字面值常量类：</p>
<ul>
<li>数据成员都是字面值类型。</li>
<li>类至少含有一个<code>constexpr</code>构造函数。</li>
<li>如果数据成员含有类内初始值，则内置类型成员的初始值必须是常量表达式。如果成员属于类类型，则初始值必须使用成员自己的<code>constexpr</code>构造函数。</li>
<li>类必须使用析构函数的默认定义。</li>
</ul>
<p><code>constexpr</code>构造函数用于生成<code>constexpr</code>对象以及<code>constexpr</code>函数的参数或返回类型。</p>
<p><code>constexpr</code>构造函数必须初始化所有数据成员，初始值使用<code>constexpr</code>构造函数或常量表达式。</p>
<h2 id="类的静态成员static-class-members"><a class="markdownIt-Anchor" href="#类的静态成员static-class-members"></a> 类的静态成员（static Class Members）</h2>
<p>使用关键字<code>static</code>可以声明类的静态成员。静态成员存在于任何对象之外，对象中不包含与静态成员相关的数据。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">calculate</span><span class="params">()</span> </span>{ amount += amount * interestRate; }</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">rate</span><span class="params">()</span> </span>{ <span class="keyword">return</span> interestRate; }</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">rate</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string owner;</span><br><span class="line">    <span class="type">double</span> amount;</span><br><span class="line">    <span class="type">static</span> <span class="type">double</span> interestRate;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">initRate</span><span class="params">()</span></span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>由于静态成员不与任何对象绑定，因此静态成员函数不能声明为<code>const</code>的，也不能在静态成员函数内使用<code>this</code>指针。</p>
<p>用户代码可以使用作用域运算符访问静态成员，也可以通过类对象、引用或指针访问。类的成员函数可以直接访问静态成员。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">double</span> r;</span><br><span class="line">r = Account::<span class="built_in">rate</span>(); <span class="comment">// access a static member using the scope operator</span></span><br><span class="line"></span><br><span class="line">Account ac1;</span><br><span class="line">Account *ac2 = &amp;ac1;</span><br><span class="line"><span class="comment">// equivalent ways to call the static member rate function</span></span><br><span class="line">r = ac1.<span class="built_in">rate</span>(); <span class="comment">// through an Account object or reference</span></span><br><span class="line">r = ac2-&gt;<span class="built_in">rate</span>(); <span class="comment">// through a pointer to an Account object</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">calculate</span><span class="params">()</span> </span>{ amount += amount * interestRate; }</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">double</span> interestRate;</span><br><span class="line">    <span class="comment">// remaining members as before</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>在类外部定义静态成员时，不能重复<code>static</code>关键字，其只能用于类内部的声明语句。</p>
<p>由于静态数据成员不属于类的任何一个对象，因此它们并不是在创建类对象时被定义的。通常情况下，不应该在类内部初始化静态成员。而必须在类外部定义并初始化每个静态成员。一个静态成员只能被定义一次。一旦它被定义，就会一直存在于程序的整个生命周期中。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// define and initialize a static class member</span></span><br><span class="line"><span class="type">double</span> Account::interestRate = <span class="built_in">initRate</span>();</span><br></pre></td></tr></tbody></table></figure>
<p>建议把静态数据成员的定义与其他非内联函数的定义放在同一个源文件中，这样可以确保对象只被定义一次。</p>
<p>尽管在通常情况下，不应该在类内部初始化静态成员。但是可以为静态成员提供<code>const</code>整数类型的类内初始值，不过要求静态成员必须是字面值常量类型的<code>constexpr</code>。初始值必须是常量表达式。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">rate</span><span class="params">()</span> </span>{ <span class="keyword">return</span> interestRate; }</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">rate</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> period = <span class="number">30</span>;  <span class="comment">// period is a constant</span></span><br><span class="line">    <span class="type">double</span> daily_tbl[period];</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>静态数据成员的类型可以是它所属的类类型。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">static</span> Bar mem1;   <span class="comment">// ok: static member can have incomplete type</span></span><br><span class="line">    Bar *mem2;    <span class="comment">// ok: pointer member can have incomplete type</span></span><br><span class="line">    Bar mem3;   <span class="comment">// error: data members must have complete type</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>可以使用静态成员作为函数的默认实参。</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// bkground refers to the static member</span></span><br><span class="line">    <span class="comment">// declared later in the class definition</span></span><br><span class="line">    <span class="function">Screen&amp; <span class="title">clear</span><span class="params">(<span class="type">char</span> = bkground)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">char</span> bkground;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
	  <div class="article-footer-copyright">

    本博客采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议(CC BY-NC-SA 4.0) 发布.</a>
</div>

	</div>

	
	<span id="/posts/88d3.html" class="leancloud-visitors view" data-flag-title="Chapter07-类.md">
		<em class="post-meta-item-text"> Page View </em> <i class="leancloud-visitors-count"></i>
	</span>
	
	<div>
  	<center>

	<div class="pagination">

    
    
    <a href="/posts/fef1.html" type="button" class="btn btn-default"><i
                class="fa fa-arrow-circle-o-left"></i> 上一页</a>
    

    <a href="/" type="button" class="btn btn-default"><i class="fa fa-home"></i>Home</a>
    
    <a href="/posts/8bc5.html" type="button" class="btn btn-default ">下一页<i
                class="fa fa-arrow-circle-o-right"></i></a>
    

    
</div>


    </center>
	</div>
	
	<!-- comment -->
	<!--
<section id="comment">
    <h2 class="title">留言</h2>

    
</section>

-->
	
		<section id="comments" class="comments">
			<style>
			.comments{margin:30px;padding:10px;background:rgb(0, 0, 0)}
			@media screen and (max-width:800px){.comments{margin:auto;padding:10px;background:#000}}
			</style>
			<div id="vcomment" class="comment"></div>
<script src='//unpkg.com/valine/dist/Valine.min.js'></script>
<script src="https://cdnjs.loli.net/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
<script>
var valineConfig = {"enable":true,"appId":"AA9eNAftQgfjEcK3l0j71rDS-gzGzoHsz","appKey":"E1r06kyXdl3RxWbXxaUQ6tPg","placeholder":"提交评论时留下邮箱收到回复后将自动通知","visitor":true,"avatar":"monsterid","requiredFields":["nick","mail"]}
valineConfig.el='#vcomment';
new Valine(valineConfig);
    // new Valine({
    //     el: '#vcomment',
    //     appId: "",
    //     appKey: "",
    //     placeholder: "提交评论时留下邮箱收到回复后将自动通知",
    //     avatar:"monsterid",
    //     visitor: "true",
    //     requiredFields: "nick,mail".split(','),
    // });
</script>

		</section>
	
	</div> <!-- col-md-9/col-md-12 -->


	
	<div id="side_meta">
		<div class="col-md-3" id="post_meta"> 

	<!-- date -->
	
	<div class="meta-widget">
	<i class="fa fa-clock-o"></i>
	2020-04-25 
	</div>
	

	<!-- categories -->
    
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#categorys"><i class="fa fa-folder"></i></a>	
    <ul id="categorys" class="tag_box list-unstyled collapse in">
          
  <li>
    <li><a href="/categories/language/">language<span>13</span></a></li>
  </li>

    </ul>
	</div>
	

	<!-- tags -->
	
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#tags"><i class="fa fa-tags"></i></a>		  
    <ul id="tags" class="tag_box list-unstyled collapse in">	  
	    
  <li><a href="/tags/C/">C++<span>12</span></a></li>
    </ul>
	</div>
		

	<!-- toc -->
	<div class="meta-widget">
	
	</div>
	
    <hr>
	
</div><!-- col-md-3 -->

		

	</div>
	
		

</div><!-- row -->

<!--
 -->



	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  
  &copy; 2022 Heisenberg Lee's Blog
  
      powered by <a href="http://hexo.io/" target="_blank">Hexo</a>.Theme <a href="https://github.com/Ares-X/hexo-theme-freemind.bithack" target="_blank">freemind.bithack</a>  
</p>
 </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>⬆︎TOP</span>
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>


        <script src="//cdn.jsdelivr.net/npm/js-base64/base64.min.js"></script>
        <script>
        $('a').each(function() {
          const $this = $(this);
          const href = $this.attr('href');
          if (href && href.match('^((http|https|thunder|qqdl|ed2k|Flashget|qbrowser|ftp|rtsp|mms)://)')) {
            const strs = href.split('/');
            if (strs.length >= 3) {
                const host = strs[2];
                if (host !== 'tlhg.top' || window.location.host) {
                    $this.attr('href', '/go.html?u='+Base64.encode(href)+'').attr('rel', 'external nofollow noopener noreferrer');
                    if (true) {
                        $this.attr('target', '_blank');
                    }
                }
            }
          }
        });
        </script></body>
   </html>
