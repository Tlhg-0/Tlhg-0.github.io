<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="pragma" content="no-cache">
  <meta http-equiv="cache-control" content="no-cache">
  <meta http-equiv="expires" content="0">
  
  <title>git | tlhg&#39;s Blog|</title>
  <meta name="author" content="Heisenberg Lee">
  
  <meta name="description" content="学习记录。">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="git"/>
  <meta property="og:site_name" content="tlhg&#39;s Blog|"/>

  
    <meta property="og:image" content="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20201004182605.jpg" />
  

  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  
  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-70812759-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-70812759-1');
</script>






<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="tlhg's Blog|" type="application/atom+xml">
</head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">tlhg&#39;s Blog|</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class=""></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class=""></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/tags" title="All the tags.">
			  <i class=""></i>Tags
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class=""></i>About
			</a>
		  </li>
		  
		  <li>
			<a href="/atom.xml" title="Subscribe me.">
			  <i class=""></i>RSS
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 


	
		<div class="page-header">
			<h1> git</h1>
		</div>
	



<div class="row post">
	<!-- cols -->
	
	<div id="top_meta"></div>
	<div class="col-md-9">
	

	<!-- content -->
	<div class="mypage">		
	  		

	  <h2 id="创建版本库"><a class="markdownIt-Anchor" href="#创建版本库"></a> 创建版本库</h2>
<ol>
<li>选择一个合适的地方，创建一个空目录：</li>
</ol>
<figure class="highlight plaintext"><figcaption><span>bash</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">$ mkdir learngit</span><br><span class="line">$ cd learngit</span><br><span class="line">$ pwd</span><br><span class="line">/Users/michael/learngit</span><br></pre></td></tr></tbody></table></figure>
<ol start="2">
<li>通过<code>git init</code>命令把这个目录变成Git可以管理的仓库：</li>
</ol>
<figure class="highlight plaintext"><figcaption><span>bash</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository in /Users/michael/learngit/.git/</span><br></pre></td></tr></tbody></table></figure>
<p>在文件夹目录下面会出现一个 .git 的目录，这个目录的作用是Git来跟踪版本管理库的，对于该文件夹下面的文件修改要慎重，盲目修改可能会导致版本库出现问题。<br>
如果你没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见。<br>
也不一定必须在空目录下创建Git仓库，选择一个已经有东西的目录也是可以的。</p>
<p><strong>将文件提交到仓库的步骤</strong></p>
<ol>
<li>用命令<code>git add</code>告诉Git，把文件添加到仓库：</li>
</ol>
<figure class="highlight plaintext"><figcaption><span>bash</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">$ git add readme.txt</span><br></pre></td></tr></tbody></table></figure>
<p>执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。</p>
<ol>
<li>用命令<code>git commit</code>告诉Git，把文件提交到仓库</li>
</ol>
<figure class="highlight plaintext"><figcaption><span>bash</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">$ git commit -m "wrote a readme file"</span><br><span class="line">[master (root-commit) eaadf4e] wrote a readme file</span><br><span class="line"> 1 file changed, 2 in</span><br><span class="line"> sertions(+)</span><br><span class="line"> create mode 100644 readme.txt</span><br></pre></td></tr></tbody></table></figure>
<p><code>git commit</code>命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。<br>
<code>git commit</code>命令执行成功后会告诉你，1 file changed：1个文件被改动（我们新添加的readme.txt文件）；2 insertions：插入了两行内容（readme.txt有两行内容）。</p>
<p>为什么Git添加文件需要add，commit一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如：</p>
<figure class="highlight plaintext"><figcaption><span>bash</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">$ git add file1.txt</span><br><span class="line">$ git add file2.txt file3.txt</span><br><span class="line">$ git commit -m "add 3 files."</span><br></pre></td></tr></tbody></table></figure>
<h2 id="版本回退"><a class="markdownIt-Anchor" href="#版本回退"></a> 版本回退</h2>
<p><code>git status</code><br>
git status  命令可以让我们时刻掌握仓库当前的状态</p>
<figure class="highlight plaintext"><figcaption><span>bash</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use "git add &lt;file&gt;..." to update what will be committed)</span><br><span class="line">  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">	modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use "git add" and/or "git commit -a")</span><br></pre></td></tr></tbody></table></figure>
<p>上面的命令输出告诉我们，readme.txt被修改过了，但还没有准备提交的修改。</p>
<p><code>git diff</code><br>
<code>git diff</code>顾名思义就是查看difference，显示的格式正是Unix通用的diff格式.</p>
<figure class="highlight plaintext"><figcaption><span>bash</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">$ git diff readme.txt</span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">index 013b5bc..2ec0ed2 100644</span><br><span class="line">--- a/readme.txt</span><br><span class="line">+++ b/readme.txt</span><br><span class="line">@@ -1,2 +1,2 @@</span><br><span class="line">-Git is a distributed version control system.</span><br><span class="line">+Git is a perfect distributed version control system.</span><br><span class="line"> Git is free software.</span><br><span class="line">\ No newline at end of file</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>从上面的命令可以看出。我们在第一行中添加了一个单词 perfect<br>
当知道了对readme.txt作了什么修改后，再把它提交到仓库就放心多了。</p>
<p>提交修改和提交新文件是一样的两步：<br>
第一步是git add：</p>
<figure class="highlight plaintext"><figcaption><span>bash</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">$ git add readme.txt</span><br></pre></td></tr></tbody></table></figure>
<p>命令在执行之后同样没有任何提示。不过我们可以通过 <code>git status</code> 命令来了解到当前仓库的存在。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">$ git status  </span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use "git reset HEAD &lt;file&gt;..." to unstage)</span><br><span class="line"></span><br><span class="line">	modified:   readme.txt</span><br></pre></td></tr></tbody></table></figure>
<p>提交后，我们再用git status命令看看仓库的当前状态：</p>
<figure class="highlight plaintext"><figcaption><span>bash</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></tbody></table></figure>
<p>Git告诉我们当前没有需要提交的修改，而且，工作目录是干净（working tree clean）的。</p>
<p><code>git log</code><br>
<code>git log</code>命令显示从最近到最远的提交日志，我们可以看到3次提交，最近的一次是<code>append GPL</code>，上一次是<code>add distributed</code>，最早的一次是<code>wrote a readme file</code>。<br>
加上–pretty=oneline参数： 可以减少输出信息。</p>
<figure class="highlight plaintext"><figcaption><span>bash</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">$ git log --pretty=oneline</span><br><span class="line">d304540b814243a41ce9ce1c2ad802326dde7b7b (HEAD -&gt; master) append GPL</span><br><span class="line">ba4ce482d04b936b123b31e0152174241f53f2d5 succeed in deleting lhg.txt and t</span><br><span class="line">lhg.top.txt</span><br><span class="line">9a4d1e5895a6f8485c54bf9010f097bf7742989f add perfect distributed and delet</span><br><span class="line">e tlhg.top.txt</span><br><span class="line">94d7ce607d4e75423ab46b49ef25f495c733e898 wrote a tlhg.top file</span><br><span class="line">98cfd639681054d4a790a28b758f7c125f423a3a wrote a readme file</span><br></pre></td></tr></tbody></table></figure>
<p>git log 的退出方法： 输入字母Q即可退出.</p>
<p><code>git reset</code><br>
git reset命令：把当前版本回退到上一个版本add distributed.</p>
<figure class="highlight plaintext"><figcaption><span>bash</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">$ git reset --hard ba4ce482d04b</span><br><span class="line">HEAD is now at ba4ce48 succeed in deleting lhg.txt and tlhg.top.txt</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><code>git reflog</code><br>
Git提供了一个命令git reflog用来记录你的每一次命令：  想恢复到新版本,可以通过<code>git reflog</code> 找到新版本的commit id</p>
<figure class="highlight plaintext"><figcaption><span>bash</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">$  git reflog</span><br><span class="line">ba4ce48 (HEAD -&gt; master) HEAD@{0}: reset: moving to ba4ce482d04b</span><br><span class="line">d304540 HEAD@{1}: commit: append GPL</span><br><span class="line">ba4ce48 (HEAD -&gt; master) HEAD@{2}: commit: succeed in deleting lhg.txt and tlhg.top.t</span><br><span class="line">xt</span><br><span class="line">9a4d1e5 HEAD@{3}: commit: add perfect distributed and delete tlhg.top.txt</span><br><span class="line">94d7ce6 HEAD@{4}: commit: wrote a tlhg.top file</span><br><span class="line">98cfd63 HEAD@{5}: commit (initial): wrote a readme file</span><br></pre></td></tr></tbody></table></figure>
<p>总结：</p>
<p>HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id。</p>
<p>穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。</p>
<p>要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。</p>
<h2 id="工作区和暂存区"><a class="markdownIt-Anchor" href="#工作区和暂存区"></a> 工作区和暂存区</h2>
<p>工作区（Working Directory）<br>
就是你在电脑里能看到的目录，比如我的learngit文件夹就是一个工作区：</p>
<p>版本库（Repository）<br>
工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。</p>
<p>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。<br>
<img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20201002161857" alt=""></p>
<p>把文件往Git版本库里添加的时候，是分两步执行的：</p>
<p>第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；</p>
<p>第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当 前分支。</p>
<p>因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。</p>
<p>现在测试一下：</p>
<ol>
<li>先对readme.txt做个修改，比如加上一行内容：</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br></pre></td></tr></tbody></table></figure>
<ol start="2">
<li>然后，在工作区新增一个LICENSE文本文件（内容随便写）。<br>
先用git status查看一下状态：</li>
</ol>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use "git add &lt;file&gt;..." to update what will be committed)</span><br><span class="line">  (use "git restore &lt;file&gt;..." to discard changes in working directory)</span><br><span class="line">        modified:   readme.txt</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use "git add &lt;file&gt;..." to include in what will be committed)</span><br><span class="line">        LICENSE</span><br><span class="line"></span><br><span class="line">no changes added to commit (use "git add" and/or "git commit -a")</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>Git非常清楚地告诉我们，readme.txt被修改了，而LICENSE还从来没有被添加过，所以它的状态是Untracked。</p>
<p>现在，使用两次命令git add，把readme.txt和LICENSE都添加后，用git status再查看一下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use "git restore --staged &lt;file&gt;..." to unstage)</span><br><span class="line">        new file:   LICENSE</span><br><span class="line">        modified:   readme.txt</span><br></pre></td></tr></tbody></table></figure>
<p>现在，暂存区的状态就变成这样了：<br>
<img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20201002165019" alt=""></p>
<p>所以，git add命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行git commit就可以一次性把暂存区的所有修改提交到分支。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">$ git commit -m "understand how stage works"</span><br><span class="line">[master acc5181] understand how stage works</span><br><span class="line"> 2 files changed, 3 insertions(+), 1 deletion(-)</span><br><span class="line"> create mode 100644 LICENSE</span><br></pre></td></tr></tbody></table></figure>
<p>一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></tbody></table></figure>
<p>现在版本库变成了这样，暂存区就没有任何内容了：<br>
<img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20201002165119" alt=""></p>
<h2 id="撤销修改"><a class="markdownIt-Anchor" href="#撤销修改"></a> 撤销修改</h2>
<p><code>git checkout = git switch + git restore</code></p>
<p><code>git checkout -- file</code> 可以撤销修改，丢弃在工作区的修存在两种情况。</p>
<ol>
<li>
<p>一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p>
</li>
<li>
<p>一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p>
</li>
</ol>
<p>总之，就是让这个文件回到最近一次git commit或git add时的状态。</p>
<p>现在举例说明上述两种情况：</p>
<p>第一种情况：文件修改后还没有被放到暂存区</p>
<p>修改过的文件(添加了最后一行)：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">$ cat readme.txt</span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br><span class="line">My stupid boss still prefers SVN.</span><br></pre></td></tr></tbody></table></figure>
<p><code>git status</code> 观察一下情况 (修改后)</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use "git add &lt;file&gt;..." to update what will be committed)</span><br><span class="line">  (use "git restore &lt;file&gt;..." to discard changes in working directory)</span><br><span class="line">        modified:   readme.txt</span><br></pre></td></tr></tbody></table></figure>
<p>现在让我们测试一下撤销修改的命令</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">$ git checkout -- readme.txt</span><br></pre></td></tr></tbody></table></figure>
<p><code>git status</code> 观察一下情况(撤销后)</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">撤销后文件内容(添加的最后一行被删除)：  </span><br></pre></td></tr></tbody></table></figure>
<p>$ cat readme.txt<br>
Git is a distributed version control system.<br>
Git is free software distributed under the GPL.<br>
Git has a mutable index called stage.<br>
Git tracks changes of files.</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">第一种情况：文件修改后还已经被放到暂存区  </span><br><span class="line"></span><br><span class="line">修改过的文件(添加了最后一行)：  </span><br></pre></td></tr></tbody></table></figure>
<p>$ cat readme.txt<br>
Git is a distributed version control system.<br>
Git is free software distributed under the GPL.<br>
Git has a mutable index called stage.<br>
Git tracks changes of files.<br>
My stupid boss still prefers SVN.</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">将修改的文件提交到暂存区：  </span><br></pre></td></tr></tbody></table></figure>
<p>git add readme.txt</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">`git status` 查看(在 `commit` 之前)  </span><br></pre></td></tr></tbody></table></figure>
<p>$ git status<br>
On branch master<br>
Changes to be committed:<br>
(use “git restore --staged <file>…” to unstage)<br>
modified:   readme.txt</file></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">可以看到，修改只是提交到了暂存区，还没有提交。  </span><br><span class="line"></span><br><span class="line">现在让我们测试一下撤销修改的命令  </span><br></pre></td></tr></tbody></table></figure>
<p>$ git reset HEAD readme.txt<br>
Unstaged changes after reset:<br>
M	readme.txt</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">`git reset`命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。  </span><br><span class="line"></span><br><span class="line">`git status` 观察一下情况(撤销后)  </span><br></pre></td></tr></tbody></table></figure>
<p>$ git status<br>
On branch master<br>
Changes not staged for commit:<br>
(use “git add <file>…” to update what will be committed)<br>
(use “git restore <file>…” to discard changes in working directory)<br>
modified:   readme.txt</file></file></p>
<p>no changes added to commit (use “git add” and/or “git commit -a”)</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">现在暂存区是干净的，工作区有修改：  </span><br><span class="line"></span><br><span class="line">之后撤销工作区的修改：  </span><br></pre></td></tr></tbody></table></figure>
<p>$ git checkout – readme.txt</p>
<p>$ git status<br>
On branch master<br>
nothing to commit, working tree clean</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">使用`git status`查看,发现工作目录是干净的。  </span><br><span class="line"></span><br><span class="line">总结：  </span><br><span class="line">场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file。</span><br><span class="line"></span><br><span class="line">场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD &lt;file&gt;，就回到了场景1，第二步按场景1操作。</span><br><span class="line"></span><br><span class="line">场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 删除文件</span><br><span class="line"></span><br><span class="line">在Git中，删除也是一个修改操作，我们实战一下，先添加一个新文件test.txt到Git并且提交：</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>$ git commit -m “add test.txt”<br>
[master 4b29612] add test.txt<br>
1 file changed, 0 insertions(+), 0 deletions(-)<br>
create mode 100644 test.txt</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了：</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>$ git status<br>
On branch master<br>
Changes not staged for commit:<br>
(use “git add/rm <file>…” to update what will be committed)<br>
(use “git restore <file>…” to discard changes in working directory)<br>
deleted:    test.txt</file></file></p>
<p>no changes added to commit (use “git add” and/or “git commit -a”)</p>
<pre class="highlight"><code class=""></code></pre>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
	  <div class="article-footer-copyright">

    本博客采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议(CC BY-NC-SA 4.0) 发布.</a>
</div>

	</div>

	
	<span id="/posts/a89f.html" class="leancloud-visitors view" data-flag-title="git">
		<em class="post-meta-item-text"> Page View </em> <i class="leancloud-visitors-count"></i>
	</span>
	
	<div>
  	<center>

	<div class="pagination">

    
    
    <a href="/posts/1a06.html" type="button" class="btn btn-default"><i
                class="fa fa-arrow-circle-o-left"></i> 上一页</a>
    

    <a href="/" type="button" class="btn btn-default"><i class="fa fa-home"></i>Home</a>
    
    <a href="/posts/6d4d.html" type="button" class="btn btn-default ">下一页<i
                class="fa fa-arrow-circle-o-right"></i></a>
    

    
</div>


    </center>
	</div>
	
	<!-- comment -->
	<!--
<section id="comment">
    <h2 class="title">留言</h2>

    
</section>

-->
	
		<section id="comments" class="comments">
			<style>
			.comments{margin:30px;padding:10px;background:rgb(0, 0, 0)}
			@media screen and (max-width:800px){.comments{margin:auto;padding:10px;background:#000}}
			</style>
			<div id="vcomment" class="comment"></div>
<script src='//unpkg.com/valine/dist/Valine.min.js'></script>
<script src="https://cdnjs.loli.net/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
<script>
var valineConfig = {"enable":true,"appId":"AA9eNAftQgfjEcK3l0j71rDS-gzGzoHsz","appKey":"E1r06kyXdl3RxWbXxaUQ6tPg","placeholder":"提交评论时留下邮箱收到回复后将自动通知","visitor":true,"avatar":"monsterid","requiredFields":["nick","mail"]}
valineConfig.el='#vcomment';
new Valine(valineConfig);
    // new Valine({
    //     el: '#vcomment',
    //     appId: "",
    //     appKey: "",
    //     placeholder: "提交评论时留下邮箱收到回复后将自动通知",
    //     avatar:"monsterid",
    //     visitor: "true",
    //     requiredFields: "nick,mail".split(','),
    // });
</script>

		</section>
	
	</div> <!-- col-md-9/col-md-12 -->


	
	<div id="side_meta">
		<div class="col-md-3" id="post_meta"> 

	<!-- date -->
	
	<div class="meta-widget">
	<i class="fa fa-clock-o"></i>
	2020-09-27 
	</div>
	

	<!-- categories -->
    
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#categorys"><i class="fa fa-folder"></i></a>	
    <ul id="categorys" class="tag_box list-unstyled collapse in">
          
  <li>
    <li><a href="/categories/tools/">tools<span>4</span></a></li>
  </li>

    </ul>
	</div>
	

	<!-- tags -->
	
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#tags"><i class="fa fa-tags"></i></a>		  
    <ul id="tags" class="tag_box list-unstyled collapse in">	  
	    
  <li><a href="/tags/get/">get<span>2</span></a></li>
    </ul>
	</div>
		

	<!-- toc -->
	<div class="meta-widget">
	
	</div>
	
    <hr>
	
</div><!-- col-md-3 -->

		

	</div>
	
		

</div><!-- row -->

<!--
 -->



	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  
  &copy; 2022 Heisenberg Lee's Blog
  
      powered by <a href="http://hexo.io/" target="_blank">Hexo</a>.Theme <a href="https://github.com/Ares-X/hexo-theme-freemind.bithack" target="_blank">freemind.bithack</a>  
</p>
 </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>⬆︎TOP</span>
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>


        <script src="//cdn.jsdelivr.net/npm/js-base64/base64.min.js"></script>
        <script>
        $('a').each(function() {
          const $this = $(this);
          const href = $this.attr('href');
          if (href && href.match('^((http|https|thunder|qqdl|ed2k|Flashget|qbrowser|ftp|rtsp|mms)://)')) {
            const strs = href.split('/');
            if (strs.length >= 3) {
                const host = strs[2];
                if (host !== 'tlhg.top' || window.location.host) {
                    $this.attr('href', '/go.html?u='+Base64.encode(href)+'').attr('rel', 'external nofollow noopener noreferrer');
                    if (true) {
                        $this.attr('target', '_blank');
                    }
                }
            }
          }
        });
        </script></body>
   </html>
