<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>微信电脑版多开、防撤回破解</title>
      <link href="/posts/d40c.html"/>
      <url>/posts/d40c.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>网上有一堆 微信电脑版多开、防撤回等<strong>破解补丁</strong>，可以实现类似的功能，但是微信是比较<strong>涉及个人隐私</strong>的社交软件，所以网上公开的补丁基本都不敢用，<strong>万一自带木马后门</strong>什么的就惨了。所以在这里教大家纯手工修改方法。</p><h1 id="准备工作"><a class="markdownIt-Anchor" href="#准备工作"></a> 准备工作</h1><p>1. OllyDbg 或 OllyICE(OllyDbg 爱好者二次开发升级版本) 等反汇编软件。</p><p>2. 安装好微信电脑版，提取安装路径文件夹中的 WeChatWin.dll 备用。</p><p>使用 OllyDbg 纯手工修改微信电脑版 WeChatWin.dll 的汇编代码，<strong>实现无限多开和消息防撤回功能</strong>，并且有撤回提示。</p><p>该方法适用于微信电脑版（Windows PC 版）近几年的所有版本，甚至未来新版本。</p><p>有一定的技术门槛，需要了解基本的反汇编破解知识，如果不能熟练掌握 OllyDbg 等反汇编软件，那么底下内容就可以不用看了。</p><h1 id="破解流程"><a class="markdownIt-Anchor" href="#破解流程"></a> 破解流程</h1><h2 id="解除多开限制"><a class="markdownIt-Anchor" href="#解除多开限制"></a> 解除多开限制</h2><p>微信启动后，会先尝试<strong>创建互斥体</strong>，如果创建成功则直接启动微信，否则依次判断 <strong>WeChatMainWndForPC</strong> 和 <strong>WeChatLoginWndForPC</strong> 两个窗口是否存在，如果存在则使用 BringWindowToTop 函数将其<strong>置顶并弹出</strong>，如果不存在则启动微信。</p><p>上述两个窗口分别代表的是微信的<strong>主界面窗口和登陆界面窗口</strong>，如果一个微信实例已经存在，则势必处于这两种状态之一。</p><p>微信判断是否重复启动运行的条件：</p><p>1.如果互斥体创建成功，则直接启动微信。</p><p>2.如果互斥体创建失败，如果查找微信相关窗口，找到则置顶并退出，未找到则启动微信。</p><p>用<strong>伪代码</strong>表示一下<strong>判断逻辑</strong>：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">// 尝试创建互斥体</span><br><span class="line">if (CreateMutex() == SUCCESS) {</span><br><span class="line">    // 创建成功则启动微信</span><br><span class="line">} else {</span><br><span class="line">    // 创建失败则尝试查找窗口</span><br><span class="line">    if (FindWindow() == SUCCESS) {</span><br><span class="line">        // 找到微信窗口，则将已有窗口置顶，然后结束程序</span><br><span class="line">    } else {</span><br><span class="line">         // 未找到微信窗口，则启动微信</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>所以破解思路就很简单了，首先使用 OllyDbg 查找所有参考文本字符串：</p><p><strong>WeChatMainWndForPC</strong> 或 <strong>WeChatLoginWndForPC</strong></p><p>然后找到以下这段代码并修改（<strong>看右侧的注释说明，需要修改 1 处星标的行</strong>）：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">5B36F8B0  /$  E8 6B000000   call WeChatWi.5B36F920                                                      创建互斥体</span><br><span class="line">5B36F8B5      84C0          test al,al                                                                  判断互斥体是否创建成功</span><br><span class="line">5B36F8B7  |.  74 56         je short WeChatWi.5B36F90F                                                  ★ je 改为 jmp，不管是否创建成功都强制跳转，并且跳过底下的窗口查找判断</span><br><span class="line">5B36F8B9  |.  56            push esi</span><br><span class="line">5B36F8BA  |.  6A 00         push 0x0                                 ; /Title = NULL</span><br><span class="line">5B36F8BC  |.  68 2819105C   push WeChatWi.5C101928                   ; |Class = "WeChatMainWndForPC"</span><br><span class="line">5B36F8C1  |.  FF15 1CD8F15B call dword ptr ds:[&lt;&amp;USER32.FindWindowW&gt;&gt;; \FindWindowW</span><br><span class="line">5B36F8C7  |.  8BF0          mov esi,eax                              ;  WeChatWi.5A960000</span><br><span class="line">5B36F8C9  |.  85F6          test esi,esi</span><br><span class="line">5B36F8CB  |.  75 12         jnz short WeChatWi.5B36F8DF                                                 &gt; 如果找到窗口 WeChatMainWndForPC 则将该窗口切换到顶层然后退出（按理说修改这个字符串也可以实现绕过多开检测）</span><br><span class="line">5B36F8CD  |.  50            push eax                                 ; /Title = "婍?"</span><br><span class="line">5B36F8CE  |.  68 9C0D105C   push WeChatWi.5C100D9C                   ; |Class = "WeChatLoginWndForPC"</span><br><span class="line">5B36F8D3  |.  FF15 1CD8F15B call dword ptr ds:[&lt;&amp;USER32.FindWindowW&gt;&gt;; \FindWindowW</span><br><span class="line">5B36F8D9  |.  8BF0          mov esi,eax                              ;  WeChatWi.5A960000</span><br><span class="line">5B36F8DB  |.  85F6          test esi,esi</span><br><span class="line">5B36F8DD  |.  74 2B         je short WeChatWi.5B36F90A                                                  &gt; 如果找到窗口 微信:WeChatLoginWndForPC 则将该窗口切换到顶层然后退出（按理说修改这个字符串也可以实现绕过多开检测）</span><br><span class="line">5B36F8DF  |&gt;  6A 01         push 0x1</span><br><span class="line">5B36F8E1  |.  56            push esi</span><br><span class="line">5B36F8E2  |.  FF15 88D7F15B call dword ptr ds:[&lt;&amp;USER32.SwitchToThis&gt;;  user32.SwitchToThisWindow       以下代码为置顶已登录的窗口</span><br><span class="line">5B36F8E8  |.  56            push esi                                 ; /hWnd = 00000001</span><br><span class="line">5B36F8E9  |.  FF15 8CD7F15B call dword ptr ds:[&lt;&amp;USER32.BringWindowT&gt;; \BringWindowToTop</span><br><span class="line">5B36F8EF  |.  6A 00         push 0x0                                 ; /pResult = NULL</span><br><span class="line">5B36F8F1  |.  68 E8030000   push 0x3E8                               ; |Timeout = 1000. ms</span><br><span class="line">5B36F8F6  |.  6A 02         push 0x2                                 ; |Flags = SMTO_NORMAL|SMTO_ABORTIFHUNG</span><br><span class="line">5B36F8F8  |.  6A 00         push 0x0                                 ; |lParam = 0x0</span><br><span class="line">5B36F8FA  |.  6A 00         push 0x0                                 ; |wParam = 0x0</span><br><span class="line">5B36F8FC  |.  68 E00B0000   push 0xBE0                               ; |Message = MSG(0xBE0)</span><br><span class="line">5B36F901  |.  56            push esi                                 ; |hWnd = 00000001</span><br><span class="line">5B36F902  |.  FF15 74D9F15B call dword ptr ds:[&lt;&amp;USER32.SendMessageT&gt;; \SendMessageTimeoutW</span><br><span class="line">5B36F908  |.  85F6          test esi,esi</span><br><span class="line">5B36F90A  |&gt;  0f95c0        setne al</span><br><span class="line">5B36F90D  |.  5E            pop esi                                  ;  LoadDl_1.60001057</span><br><span class="line">5B36F90E  |.  C3            retn                                                                        函数返回（有多开时）</span><br><span class="line">5B36F90F  |&gt;  32C0          xor al,al                                                                   函数返回（没有多开时）</span><br><span class="line">5B36F911  \.  C3            retn</span><br></pre></td></tr></tbody></table></figure><h2 id="消息防撤回"><a class="markdownIt-Anchor" href="#消息防撤回"></a> 消息防撤回</h2><p><strong>消息防撤回，带对方撤回消息提示！</strong></p><p>和上边一样，先查找所有参考文本字符串：<strong>pStrMsgid value is null</strong></p><p>然后找到以下这段代码并修改（<strong>看右侧的注释说明，需要修改 1 处星标的行</strong>）：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">68E854DA  |&gt; \8B06          mov eax,dword ptr ds:[esi]</span><br><span class="line">68E854DC  |.  8BCE          mov ecx,esi</span><br><span class="line">68E854DE  |.  FF50 18       call dword ptr ds:[eax+0x18]</span><br><span class="line">68E854E1  |.  85C0          test eax,eax                             ;  WeChatWi.68B90000</span><br><span class="line">68E854E3  |.^ 74 9D         je short WeChatWi.68E85482</span><br><span class="line">68E854E5  |.  68 F4C7336A   push WeChatWi.6A33C7F4                   ;  ASCII "revokemsg"</span><br><span class="line">68E854EA  |.  8BC8          mov ecx,eax                              ;  WeChatWi.68B90000</span><br><span class="line">68E854EC  |.  E8 0F2F7700   call WeChatWi.695F8400</span><br><span class="line">68E854F1  |.  8BF0          mov esi,eax                              ;  WeChatWi.68B90000</span><br><span class="line">68E854F3  |.  85F6          test esi,esi</span><br><span class="line">68E854F5  |.^ 74 8B         je short WeChatWi.68E85482</span><br><span class="line">68E854F7  |.  68 F8D4336A   push WeChatWi.6A33D4F8                   ;  ASCII "newmsgid"</span><br><span class="line">68E854FC  |.  8BCE          mov ecx,esi</span><br><span class="line">68E854FE  |.  E8 FD2E7700   call WeChatWi.695F8400</span><br><span class="line">68E85503  |.  85C0          test eax,eax                             ;  WeChatWi.68B90000    ★ 修改为 xor eax,eax</span><br><span class="line">68E85505  |.  74 7B         je short WeChatWi.68E85582                                       &gt; PS：或者把 je 改为 jne 也可以？待测试！</span><br><span class="line">68E85507  |.  8BC8          mov ecx,eax                              ;  WeChatWi.68B90000</span><br><span class="line">68E85509  |.  E8 82377700   call WeChatWi.695F8C90</span><br><span class="line">68E8550E  |.  85C0          test eax,eax                             ;  WeChatWi.68B90000</span><br><span class="line">68E85510  |.  75 62         jnz short WeChatWi.68E85574</span><br><span class="line">68E85512  |.  0F1005 98F52B&gt;movups xmm0,dqword ptr ds:[0x6A2BF598]</span><br><span class="line">68E85519  |.  83EC 10       sub esp,0x10</span><br><span class="line">68E8551C  |.  BA C0C3336A   mov edx,WeChatWi.6A33C3C0                ;  ASCII "02_manager\ChatMgr.cpp"</span><br><span class="line">68E85521  |.  8BC4          mov eax,esp</span><br><span class="line">68E85523  |.  B9 02000000   mov ecx,0x2</span><br><span class="line">68E85528  |.  83EC 10       sub esp,0x10</span><br><span class="line">68E8552B  |.  0F1100        movups dqword ptr ds:[eax],xmm0</span><br><span class="line">68E8552E  |.  8BC4          mov eax,esp</span><br><span class="line">68E85530  |.  83EC 10       sub esp,0x10</span><br><span class="line">68E85533  |.  0F1100        movups dqword ptr ds:[eax],xmm0</span><br><span class="line">68E85536  |.  8BC4          mov eax,esp</span><br><span class="line">68E85538  |.  83EC 10       sub esp,0x10</span><br><span class="line">68E8553B  |.  0F1100        movups dqword ptr ds:[eax],xmm0</span><br><span class="line">68E8553E  |.  8BC4          mov eax,esp</span><br><span class="line">68E85540  |.  83EC 10       sub esp,0x10</span><br><span class="line">68E85543  |.  0F1100        movups dqword ptr ds:[eax],xmm0</span><br><span class="line">68E85546  |.  8BC4          mov eax,esp</span><br><span class="line">68E85548  |.  83EC 10       sub esp,0x10</span><br><span class="line">68E8554B  |.  0F1100        movups dqword ptr ds:[eax],xmm0</span><br><span class="line">68E8554E  |.  8BC4          mov eax,esp</span><br><span class="line">68E85550  |.  68 E0D4336A   push WeChatWi.6A33D4E0                   ;  ASCII "pStrMsgid value is null"</span><br><span class="line">68E85555  |.  68 F8C3336A   push WeChatWi.6A33C3F8                   ;  ASCII "ChatMgr"</span><br><span class="line">68E8555A  |.  68 C4D4336A   push WeChatWi.6A33D4C4                   ;  ASCII "ChatMgr::parseRevokeContent"</span><br><span class="line">68E8555F  |.  68 8B080000   push 0x88B</span><br><span class="line">68E85564  |.  0F1100        movups dqword ptr ds:[eax],xmm0</span><br><span class="line">68E85567  |.  E8 54732900   call WeChatWi.6911C8C0</span><br><span class="line">68E8556C  |.  83C4 70       add esp,0x70</span><br><span class="line">68E8556F  |.^ E9 0EFFFFFF   jmp WeChatWi.68E85482</span><br></pre></td></tr></tbody></table></figure><h1 id="破解完成"><a class="markdownIt-Anchor" href="#破解完成"></a> 破解完成</h1><p>复制所有修改并保存到文件，然后替换 WeChatWin.dll 原文件，重新运行微信即可。</p><h1 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h1><p><a href="https://user.guancha.cn/main/content?id=351956&amp;page=2">微信PC端多开的秘密</a></p><p><a href="http://vulsee.com/archives/vulsee_2021/0302_13882.html">微信PC段防撤回DLL（WeChatWin.dll）修改测试</a></p><p><a href="https://jishuin.proginn.com/p/763bfbd28ba4">深扒微信多开的秘密后，我竟然发现了个 bug</a></p><p><a href="https://www.ghxi.com/pcwechat.html">微信 最新 电脑版 绿色修改版</a>，和官方同步更新，有现成破解补丁下载，<strong>安全性自测！</strong></p><p><a href="http://www.qiuquan.cc/chat/wechat.html">微信 最新 电脑版 正式版+测试版+开发版（多开+防撤回,带撤回提示）</a>，和官方同步更新，有现成破解补丁下载，<strong>安全性自测！</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Reverse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>注册表</title>
      <link href="/posts/aecd.html"/>
      <url>/posts/aecd.html</url>
      
        <content type="html"><![CDATA[<h1 id="注册表的打开与关闭"><a class="markdownIt-Anchor" href="#注册表的打开与关闭"></a> 注册表的打开与关闭</h1><p>注册表是一个巨大的树形结构。操作一般都是打开某个子键。子键下有若干个值可以获得。每一个值有一个名字。值有不同的类型。一般需要查询才能获得其类型。</p><p>应用程序编程：需要提供一个根子键的句柄。</p><p>驱动：全部用路径表示。</p><p>应用编程中对应的子键 驱动编程中的路径写法：</p><table><thead><tr><th><strong>HKEY_LOCAL_MACHINE</strong></th><th><strong>\Registry\Machine</strong></th></tr></thead><tbody><tr><td>HKEY_USERS</td><td>\Registry\User</td></tr><tr><td>HKEY_CLASSES_ROOT</td><td>没有对应的路径</td></tr><tr><td>HKEY_CURRENT_USER</td><td>没有简单的对应路径，但是可以求得</td></tr></tbody></table><p>实际上应用程序和驱动程序很大的一个不同在于应用程序总是由某个“当前用户”启动的。因此可以直接读取HKEY_CLASSES_ROOT和HKEY_CURRENT_USER。而驱动程序和用户无关，所以直接去打开HKEY_CURRENT_USER也就不符合逻辑了。</p><p>打开注册表键使用函数ZwOpenKey。新建或者打开则使用ZwCreateKey。一般在驱动编程中，使用ZwOpenKey的情况比较多见。</p><h2 id="zwopenkey-函数"><a class="markdownIt-Anchor" href="#zwopenkey-函数"></a> <strong>ZwOpenKey</strong> 函数</h2><p><strong>ZwOpenKey</strong> 函数（打开注册表键），函数原型如下：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">NTSTATUS <span class="title function_">ZwOpenKey</span><span class="params">(</span></span><br><span class="line"><span class="params">    PHANDLE  KeyHandle,</span></span><br><span class="line"><span class="params">    ACCESS_MASK  DesiredAccess,</span></span><br><span class="line"><span class="params">    POBJECT_ATTRIBUTES  ObjectAttributes</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></tbody></table></figure><p>这个函数和ZwCreateFile是类似的。它并不接受直接传入一个字符串来表示一个子键。而是要求输入一个OBJECT_ATTRIBUTES的指针。</p><p><strong>KeyHandle</strong> 参数是一个PAHDNLE类型，即句柄的指针，这个参数是一个返回参数，ZwOpenKey成功打开或创建注册表键后，KeyHandle保存注册表键的句柄。</p><p><strong>DesiredAccess</strong>  参数表示权限，这个权限值需要根据后面具体的操作来决定，具体的参数可以查看下表。</p><ul><li>KEY_QUERY_VALUE：读取键下的值。</li><li>KEY_SET_VALUE：设置键下的值。</li><li>KEY_CREATE_SUB_KEY：生成子键。</li><li>KEY_ENUMERATE_SUB_KEYS：枚举子键。</li></ul><p>实际上可以用  KEY_READ  来做为通用的读权限组合。这是一个组合宏。此外对应的有KEY_WRITE。</p><p>如果需要获得全部的权限，可以使用KEY_ALL_ACCESS。</p><p>下面的例子是 读取注册表中保存的Windows 系统目录（Windows 目录）的位置，只打开子键，不读取值。</p><p>Windows目录的位置被称为SystemRoot，这一值保存在注册表中，路径是“HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion”。当然，请注意注意在驱动编程中的写法有所不同。下面的代码初始化一个OBJECT_ATTRIBUTES。</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">HANDLE my_key = <span class="literal">NULL</span>;</span><br><span class="line">NTSTATUS status;</span><br><span class="line"><span class="comment">// 定义要获取的路径    </span></span><br><span class="line">UNICODE_STRING my_key_path = </span><br><span class="line">    RTL_CONSTANT_STRING(L” \\ Registry\\Machine\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion”);</span><br><span class="line">OBJECT_ATTRIBUTE my_obj_attr = { <span class="number">0</span> };</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化OBJECT_ATTRIBUTE</span></span><br><span class="line">InitializeObjectAttributes(</span><br><span class="line">    &amp;my_obj_attr,</span><br><span class="line">    &amp;my_key_path,</span><br><span class="line">    OBJ_CASE_INSENSITIVE,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// 接下来是打开Key</span></span><br><span class="line">status = ZwOpenKey(&amp;my_key,KEY_READ,&amp;my_obj_attr);</span><br><span class="line"><span class="keyword">if</span>(!NT_SUCCESS(status))</span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 失败处理</span></span><br><span class="line">    ……</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上面的代码得到了my_key。子键已经打开。然后的步骤是读取下面的SystemRoot值。这里省略。</p><h2 id="zwcreatekey-函数"><a class="markdownIt-Anchor" href="#zwcreatekey-函数"></a> <strong>ZwCreateKey</strong> 函数</h2><p><strong>ZwCreateKey</strong> 函数（新建或者打开注册表 ），函数原型如下：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">NTSTATUS <span class="title function_">ZwCreateKey</span><span class="params">(</span></span><br><span class="line"><span class="params">PHANDLE KeyHandle,</span></span><br><span class="line"><span class="params">ACCESS_MASKDesireAccess,</span></span><br><span class="line"><span class="params">POBJECT_ATTRIBUTES ObjectAttributes,</span></span><br><span class="line"><span class="params">ULONGTitleIndex,</span></span><br><span class="line"><span class="params">PUNICODE_STRING Class,</span></span><br><span class="line"><span class="params">ULONGCreateOptions,</span></span><br><span class="line"><span class="params">PULONGDisposition</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></tbody></table></figure><p><strong>KeyHandle</strong> 参数是一个PAHDNLE类型，即句柄的指针，这个参数是一个返回参数，ZwCreateKey成功打开或创建注册表键后，KeyHandle保存注册表键的句柄。</p><p><strong>DesiredAccess</strong>  参数表示权限，这个权限值需要根据后面具体的操作来决定。</p><p>如果需要获得全部的权限，可以使用KEY_ALL_ACCESS。</p><p><strong>ObjectAttributes</strong>  参数在上一小节已经介绍过，表示对象的属性。ZwCreateKey函数第四个参数与第五个参数可以设置成NULL。</p><p><strong>CreateOptions</strong> 参数 表示打开或创建注册表键的选项，常用的选项有：</p><ul><li>REG_OPTION_VOLATILE 表示新建的注册表键在系统重启后不保留</li><li>REG_OPTION_NON_VOLATILE 表示新建的注册表键在系统重启后依然保留。</li></ul><p><strong>Disposition</strong>  参数是一个返回的参数，为ULONG指针，函数成功执行后，Disposition 等于 REG_CREATED_NEW_KEY或REG_OPENED_EXISTING_KEY，前者表示 ZwCreateKey 函数创建了一个新的注册表键，后者表示打开了一个已存在的注册表键。ZwCreateKey返回STATUS_SUCCESS则表示成功，否则返回一个错误码，对于内核大多数API，返回STATUS_SUCCESS则表示成功。</p><p>ZwCreateKey 函数的用法：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(PDRIVER_OBJECT Driverobject, PUNICODE_STRING RegistryPath)</span></span><br><span class="line">{</span><br><span class="line">OBJECT_ATTRIBUTES ObjAttr = { <span class="number">0</span> };</span><br><span class="line">HANDLE hKey = <span class="literal">NULL</span>;</span><br><span class="line">ULONG ulDisposition = <span class="number">0</span>;</span><br><span class="line">NTSTATUS nStatus = STATUS_SUCCESS；</span><br><span class="line">UNREFERENCED_PARAMETER ( DriverObject );</span><br><span class="line">InitializeObjectAttributes(</span><br><span class="line">&amp;ObjAttr,</span><br><span class="line">RegistryPath,</span><br><span class="line">OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line"><span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">nStatus = ZwCreateKey(</span><br><span class="line">&amp;hKey,</span><br><span class="line">KEY_WRITE,</span><br><span class="line">&amp;ObjAttr,</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">REG_OPTION_NON_VOLATILE,</span><br><span class="line">&amp;ulDisposition);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (hKey != <span class="literal">NULL</span>)</span><br><span class="line">{</span><br><span class="line">ZwClose(hKey);</span><br><span class="line">hKey = <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line">DriverObject-&gt;DriverUnload = DriverUnload;</span><br><span class="line"><span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码中使用了InitializeObjectAttributes宏来初始化OBJECT_ATTRIBUTES结构体。</p><p>宏的每一个参数都对应着结构体中的一项成员。代码在调用InitializeObjectAttributes时，第三个参数传递的是OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE，表示使用内核句柄以及对象名字不区分大小写。</p><h1 id="注册表的读"><a class="markdownIt-Anchor" href="#注册表的读"></a> 注册表的读</h1><h2 id="zwqueryvaluekey-函数"><a class="markdownIt-Anchor" href="#zwqueryvaluekey-函数"></a> <strong>ZwQueryValueKey</strong> 函数</h2><p>ZwQueryValueKey这个函数的原型如下：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">NTSTATUS <span class="title function_">ZwQueryValueKey</span><span class="params">(</span></span><br><span class="line"><span class="params">     HANDLE  KeyHandle,</span></span><br><span class="line"><span class="params">     PUNICODE_STRING  ValueName,</span></span><br><span class="line"><span class="params">     KEY_VALUE_INFORMATION_CLASS  KeyValueInformationClass,</span></span><br><span class="line"><span class="params">     PVOID  KeyValueInformation,</span></span><br><span class="line"><span class="params">     ULONG  Length,</span></span><br><span class="line"><span class="params">     PULONG  ResultLength</span></span><br><span class="line"><span class="params">    )</span>;</span><br></pre></td></tr></tbody></table></figure><p><strong>KeyHandle</strong>：这是用ZwCreateKey或者ZwOpenKey所打开的一个注册表键句柄。</p><p><strong>ValueName</strong>：UNICODE_STRING指针，要读取的值的名字。</p><p><strong>KeyValueInformationClass</strong>：本次查询所需要查询的信息类型。</p><p>这有如下的三种可能：</p><ul><li><strong>KeyValueBasicInformation</strong>：获得基础信息，包含值名和类型。</li><li><strong>KeyValueFullInformation</strong>：获得完整信息。包含值名、类型和值的数据。</li><li><strong>KeyValuePartialInformation</strong>：获得局部信息。包含类型和值数据。</li></ul><p>很容易看出实际上名字是已知的，获得基础信息是多此一举。同样获得完整信息也是浪费内存空间。因为调用ZwQueryValueKey的目的是为了得到类型和值数据。因此使用KeyValuePartialInformation最常见。当采用KeyValuePartialInformation的时候，一个类型为KEY_VALUE_PARTIAL_INFORMATION的结构将被返回到参数KeyValueInformation所指向的内存中。</p><p><strong>KeyValueInformation</strong>：当KeyValueInformationClass被设置为KeyValuePartialInformation时，KEY_VALUE_PARTIAL_INFORMATION结构将被返回到这个指针所指内存中。下面是结构KEY_VALUE_PARTIAL_INFORMATION的原型。</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KEY_VALUE_PARTIAL_INFORMATION</span> {</span></span><br><span class="line">    ULONG  TitleIndex;          <span class="comment">// 请忽略这个成员</span></span><br><span class="line">    ULONG  Type;                <span class="comment">// 数据类型</span></span><br><span class="line">    ULONG  DataLength;          <span class="comment">// 数据长度</span></span><br><span class="line">    UCHAR  Data[<span class="number">1</span>];             <span class="comment">// 可变长度的数据</span></span><br><span class="line">}KEY_VALUE_PARTIAL_INFORMATION,*PKEY_VALUE_PARTIAL_INFORMATIO;</span><br></pre></td></tr></tbody></table></figure><p>数据类型Type有很多种可能，但是最常见的几种如下：</p><ul><li>REG_BINARY：十六进制数据。</li><li>REG_DWORD：四字节整数。</li><li>REG_SZ：以空结束的Unicode字符串。</li><li>Length：用户传入的输出空间KeyValueInformation的长度。</li><li>ResultLength：返回实际需要的长度。</li><li>返回值：如果说实际需要的长度比Length要大，那么返回STATUS_BUFFER_OVERFLOW或者是STATUS_BUFFER_TOO_SMALL。如果成功读出了全部数据，那么返回STATUS_SUCCESS。其他的情况，返回一个错误码。</li></ul><p><strong>注意</strong>：</p><p>利用ResultLength参数以及STATUS_BUFFER_TOO_SMALL返回值，可以获取当前所查询键值信息大小，代码如下：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">NTSTATUS nStatus = STATUS_SUCCESS;</span><br><span class="line">UNICODE_STRING usValueName = { <span class="number">0</span> };</span><br><span class="line">ULONG ulRetSize = <span class="number">0</span>;</span><br><span class="line">RtlInitUnicodeString(&amp;usValueName, <span class="string">L"Start"</span>);</span><br><span class="line">nStatus = ZwQueryValueKey(</span><br><span class="line">hKey,</span><br><span class="line">&amp;usValueName,</span><br><span class="line">KeyValuePartialInformation,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">&amp;ulRetSize);</span><br><span class="line"><span class="keyword">if</span>(nStatus == STATUS_BUFFER_TOO_SMALL &amp;&amp; ulRetSize!= <span class="number">0</span>)</span><br><span class="line">(</span><br><span class="line"><span class="comment">//ulRetSize保存的是所需要获取的信息大小</span></span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p>上述代码ZwQueryValueKey函数的KeyValueInformation传递NULL，Length传递0，ZwQueryValueKey函数会由于空间不足返回STATUS_BUFFER_TOO_SMALL，并设置ResultLength为所需大小。另外ZwQueryValueKey函数的第三个参数为KeyValuePartialInformation，表示获取键值的内容这个结构体的Data数组保存键值的内容，Data是一个长度不固定的数组，长度由DataLength决定，也就是说KEY_VALUE_PARTIAL_INFORMATION是一个变长结构体，这就是为什么首先需要通过ResultLength参数以及STATUS_BUFFER_TOO_SMALL返回值确定键值信息大小。</p><p><strong>Length</strong>: KeyValueInformation缓冲区大小的，单位是字节。</p><p><strong>ResultLength</strong>: 是一个返回参数，函数执行成功后，ResultLength返回的是KeyValueInformation缓冲区中实际键值信息大小，单位是字节</p><p>下面代码展示了完整的获取键值的过程：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(PDRIVER_OBJECT Driverobject, PUNICODE_STRING RegistryPath)</span></span><br><span class="line">{</span><br><span class="line">OBJECT_ATTRIBUTES ObjAttr = { <span class="number">0</span> };</span><br><span class="line">HANDLE hKey = <span class="literal">NULL</span>;</span><br><span class="line">ULONG ulDisposition = <span class="number">0</span>;</span><br><span class="line">NTSTATUS nStatus = STATUS_SUCCESS;</span><br><span class="line">UNREFERENCED_PARAMETER(DriverObject);</span><br><span class="line">InitializeObjectAttributes(</span><br><span class="line">&amp;ObjAttr,</span><br><span class="line">RegistryPath,</span><br><span class="line">OB3_KERNEL_HANDLE | OB3_CASE_INSENSITIVE,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line"><span class="literal">NULL</span>);</span><br><span class="line">nStatus = ZwCreateKey(</span><br><span class="line">&amp;hKey,</span><br><span class="line">KEY_WRITE,</span><br><span class="line">&amp;ObjAttr,</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">REG_OPTION_NON_VOLATILE,</span><br><span class="line">&amp;ulDisposition);</span><br><span class="line"><span class="keyword">if</span> (hKey != <span class="literal">NULL</span>)</span><br><span class="line">{</span><br><span class="line">UNICODE_STRING usValueName = { <span class="number">0</span> };</span><br><span class="line">ULONG ulRetSize = <span class="number">0</span>;</span><br><span class="line">RtlInitUnicodeString(&amp;usValueName, <span class="string">L"Start"</span>);</span><br><span class="line"><span class="comment">//第一次查询获取所需长度</span></span><br><span class="line">nStatus = ZwQueryValueKey(</span><br><span class="line">hKey,</span><br><span class="line">&amp;usValueName,</span><br><span class="line">KeyValuePartialInformation,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">&amp;ulRetSize);</span><br><span class="line"><span class="keyword">if</span> (nStatus == STATUS_BUFFER_TOO_SMALL &amp;&amp; ulRetSize != <span class="number">0</span>)</span><br><span class="line">{</span><br><span class="line"><span class="comment">//ulRetSize保存的是所需要获取的信息大小</span></span><br><span class="line">ULONG ulStartValue = <span class="number">0</span>;</span><br><span class="line">PKEY_VALUE_PARTIAL_INFORMATION pData = (PKEY_VALUE_PARTIAL_INFORMATION)</span><br><span class="line">ExAllocatePoolWithTag(PagedPool, ulRetSize, <span class="string">'DriF'</span>);</span><br><span class="line"><span class="keyword">if</span> (pData != <span class="literal">NULL</span>)</span><br><span class="line">{</span><br><span class="line"><span class="built_in">memset</span>(pData &gt; <span class="number">0</span>, ulRetSize);</span><br><span class="line"><span class="comment">//再次查询</span></span><br><span class="line">nStatus = ZwQueryValueKey(</span><br><span class="line">hKey,</span><br><span class="line">&amp;usValueName,</span><br><span class="line">KeyValuePartialInformation,</span><br><span class="line">(PVOID)pData,</span><br><span class="line">ulRetSize,</span><br><span class="line">&amp;ulRetSize);</span><br><span class="line"><span class="keyword">if</span> (nStatus == STATUS_SUCCESS)</span><br><span class="line">{</span><br><span class="line"><span class="comment">//获取Start的值</span></span><br><span class="line">ulStartValue = *((ULONG*)pData-&gt;Data);</span><br><span class="line">DbgPrint(<span class="string">"Key:%wZ,ValueName:%wZ,Value:%u\n"</span>,</span><br><span class="line">RegistryPath, &amp;usValueName, ulStartValue);</span><br><span class="line">}</span><br><span class="line">ExFreePoolWithTag(pData, <span class="string">'DriF'</span>);</span><br><span class="line">pData = <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line">ZwClose(hKey);</span><br><span class="line">hKey = <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line">Driverobject-&gt;DriverUnload = DriverUnload;</span><br><span class="line"><span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> kernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kernel programm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象与句柄</title>
      <link href="/posts/d839.html"/>
      <url>/posts/d839.html</url>
      
        <content type="html"><![CDATA[<h1 id="句柄的定义"><a class="markdownIt-Anchor" href="#句柄的定义"></a> 句柄的定义</h1><p>每个进程都有一个表，这个表中的每一项保存着需要访问的内核对象信息，系统为用户态应用程序提供一个“句柄”值，这个句柄值实际上是这个表的某种索引，通过这个值，可以在表中定位到具体需要访问的内核对象信息。用户态程序通过API创建或打开一个内核对象时，这个表中的信息会增加一项，用来描述这个内核对象的信息，并产生一个相应的句柄值，用户态程序把这个句柄传递到相应API，API进入内核后，通过这个句柄值定位到需要操作的内核对象，对内核对象进行相应的操作。</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> *HANDLE;</span><br><span class="line"><span class="keyword">typedef</span> HANDLE *PHANDLE</span><br></pre></td></tr></tbody></table></figure><h1 id="内核对象的引用计数"><a class="markdownIt-Anchor" href="#内核对象的引用计数"></a> 内核对象的引用计数</h1><p>每个内核对象存在两个计数，一个称为“句柄计数”，另一个称为“指针计数”，句柄计数是指这个内核对象被多少个句柄值所指向，如在用户态中创建一个命名的EVENT对象，获取到一个句柄，那么这个EVENT的句柄计数就是1，当其他程序通过该EVENT名字打开该EVENT时，会获取到另外一个句柄，这时候，句柄计数等于2。指针计数是在句柄计数基础上递增的计数，在刚才所提的例子中，句柄计数等于2，指针计数也等于2，句柄计数的增加，会相应导致指针计数增加，同理，句柄计数的减少，会相应导致指针计数减少，但指针计数可以独立增加与减少而不影响句柄计数。当一个对象的指针计数等于0的时候，这个对象会被系统释放。请注意，不同操作系统，系统对引用计数值的管理稍有不同。</p><h1 id="句柄操作code"><a class="markdownIt-Anchor" href="#句柄操作code"></a> 句柄操作CODE</h1><h2 id="code"><a class="markdownIt-Anchor" href="#code"></a> ＣＯＤＥ</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">BOOLEAN <span class="title function_">EventOperationSample</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">BOOLEAN bSucc = FALSE;</span><br><span class="line">HANDLEhCreateEvent = <span class="literal">NULL</span>;</span><br><span class="line">PVOIDpCrateEventObject = <span class="literal">NULL</span>;</span><br><span class="line">HANDLEhOpenEvent = <span class="literal">NULL</span>;</span><br><span class="line">PVOIDpOpenEventObject = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">{</span><br><span class="line">OBJECT_ATTRIBUTES ObjAttr = { <span class="number">0</span> };</span><br><span class="line">UNICODE_STRING uNameString = { <span class="number">0</span> };</span><br><span class="line">RtlInitUnicodeString(&amp;uNameString, <span class="string">L"\\BaseNameObjects\\TestEvent"</span>);</span><br><span class="line">InitializeObjectAttributes(&amp;ObjAttr, &amp;uNameString, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">ZwCreateEvent(&amp;hCreateEvent, EVENT_ALL_ACCESS, &amp;ObjAttr, SynchronizationEvent, FALSE);</span><br><span class="line"><span class="keyword">if</span> (hCreateEvent == <span class="literal">NULL</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">ObReferenceObjectByHandle(hCreateEvent, EVENT_ALL_ACCESS, *ExEventObjectType, KernelMode, &amp;pCrateEventObject, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (hOpenEvent == <span class="literal">NULL</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">ObReferenceObjectByHandle(hOpenEvent, EVENT_ALL_ACCESS, *ExEventObjectType, KernelMode, &amp;pCrateEventObject, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pOpenEventObject == <span class="literal">NULL</span>)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">DbgPrint(<span class="string">"Create Handle: %p, Create Pointer = %p\n"</span>, hCreateEvent, pCrateEventObject);</span><br><span class="line">DbgPrint(<span class="string">"Open Handle: %p, Open Pointer = %p\n"</span>, hOpenEvent, pOpenEventObject);</span><br><span class="line">bSucc = TRUE;</span><br><span class="line">} <span class="keyword">while</span> (FALSE);</span><br><span class="line"><span class="keyword">if</span> (pCrateEventObject != <span class="literal">NULL</span>)</span><br><span class="line">{</span><br><span class="line">ObDereferenceObject(pCrateEventObject);</span><br><span class="line">pCrateEventObject = <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (hCreateEvent != <span class="literal">NULL</span>)</span><br><span class="line">{</span><br><span class="line">ZwClose(hCreateEvent);</span><br><span class="line">hCreateEvent = <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pOpenEventObject != <span class="literal">NULL</span>)</span><br><span class="line">{</span><br><span class="line">ObDereferenceObject(pOpenEventObject);</span><br><span class="line">pOpenEventObject = <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (hOpenEvent != <span class="literal">NULL</span>)</span><br><span class="line">{</span><br><span class="line">ZwClose(hOpenEvent);</span><br><span class="line">hOpenEvent = <span class="literal">NULL</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> bSucc;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="逻辑分析"><a class="markdownIt-Anchor" href="#逻辑分析"></a> 逻辑分析</h2><p>ZwCreateEvent成功后，句柄会保存在hCreateEvent变量中，这个句柄是一个内核句柄。接着代码中调用ObReferenceObåjectByHandle函数，获取hCreateEvent句柄对应的EVENT对象指针。</p><p>例子代码在调用ObReferenceObjectByHandle函数成功后，使用ZwOpenEvent函数再次打开刚才创建的EVENT并获取一个句柄，保存在hOpenEvent变量中；接着通过hOpenEvent的值，使用ObReferenceObjectByHandle获取EVENT的对象指针，保存在pOpenEventObject变量中。</p><p>所以最后会产生两个句柄以及两个对象指针。代码通过DbgPrint函数把这些信息输出：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">Create Handle : FFFFFFFF80000B90, Create Pointer = FFFFD1898059C260</span><br><span class="line">Open Handle : FFFFFFFF800003648, Create Pointer = FFFFD1898059C260</span><br></pre></td></tr></tbody></table></figure><h2 id="zwcreateevent-函数"><a class="markdownIt-Anchor" href="#zwcreateevent-函数"></a> ZwCreateEvent 函数</h2><p>ZwCreateEvent  函数创建对象 EVENT 对象</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">NASTATUS <span class="title function_">ZwCreateEvent</span><span class="params">(</span></span><br><span class="line"><span class="params">PHANDLE EventHandle,</span></span><br><span class="line"><span class="params">ACCESS_MASKDesiredAccess,</span></span><br><span class="line"><span class="params">POBJECT_ATTRIBUTES objectAttributes,</span></span><br><span class="line"><span class="params">EVENT_TYPE EventType,</span></span><br><span class="line"><span class="params">BOOLEAN InitialState</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></tbody></table></figure><p><strong>EventHandle</strong> 参数用于保存EVENT的句柄；</p><p><strong>DesiredAccess</strong> 参数 表示EVENT的权限；</p><p><strong>ObjectAttributes</strong>  参数表示创建EVENT的属性信息；</p><p><strong>EventType</strong>  参数表示EVENT的类型，取值为SynchronizationEvent或者NotificationEvent，分别表示同步类型EVENT以及通告类型的EVENT；</p><p><strong>InitialState</strong> 参数 表示EVENT的初始状态，TRUE表示EVENT被创建后的状态为“有信号”，否则为“无信号”。</p><p><strong>注意</strong> ：ObjectAttributes参数的用法最为重要，ObjectAttributes描述了需要打开或创建的内核对象属性，大部分涉及打开或创建内核对象的API都会有ObjectAttributes参数。</p><h2 id="object_attributes-结构体"><a class="markdownIt-Anchor" href="#object_attributes-结构体"></a> OBJECT_ATTRIBUTES 结构体</h2><p>OBJECT_ATTRIBUTES 结构描述内核对象的属性；属性包括对象的名字，根目录</p><p>的句柄，对象的安全描述。</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OBJECT_ATTRIBUTES</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">ULONG length;</span><br><span class="line">HANDLE RootDirectory;</span><br><span class="line">PUNICODE_STRING ObjectName;</span><br><span class="line">ULONG Attributes;</span><br><span class="line">PVOID SecurityDescriptor;</span><br><span class="line">PVOID SecurityQuakityofService;</span><br><span class="line">} OBJECT_ATTRIBUTES, * POBJECT_ATTRIBUTES;</span><br></pre></td></tr></tbody></table></figure><p><strong>Length</strong> 成员表示结构体的大小，一般等于sizeof(OBJECT_ATTRIBUTES)，<strong>RootDirectory</strong> 表示对象的根目录句柄，可以为NULL。</p><p><strong>ObjectName</strong> 是一个UNICODE_STRING的指针，表示对象的路径或名字，<strong>RootDirectory</strong> 与 <strong>ObjectName</strong> 共同组成了一个完整的对象全路径名字。<strong>Attributes</strong> 表示对象打开或创建时的具体属性，常见的有：</p><ul><li>OBJ_INHERIT 表示内核对象的句柄可以被继承</li><li>OBJ_CASE_INSENSITIVE 表示内核对象的名字不区分大小写。</li><li>OBJ_KERNEL_HANDLE 表示使用内核句柄，即句柄存在于系统句柄表中。</li><li>SecurityDescriptor以及SecurityQualityOfService与安全性相关，可以暂设置成NULL。</li></ul><h2 id="obreferenceobjectbyhandle-函数"><a class="markdownIt-Anchor" href="#obreferenceobjectbyhandle-函数"></a> <strong>ObReferenceObjectByHandle</strong> 函数</h2><p><strong>ObReferenceObjectByHandle</strong> 函数用于获取句柄对应的对象的指针。</p><p><strong>ObReferenceObjectByHandle</strong> 函数成功则返回STATUS_SUCCESS，失败则返回错误码。函数原型如下：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">NTSTATUS <span class="title function_">ObReferenceObjectByHandle</span><span class="params">(</span></span><br><span class="line"><span class="params">HANDLE Handle,</span></span><br><span class="line"><span class="params">ACCESS_MASKDesiredAccess,</span></span><br><span class="line"><span class="params">POBJECT_TYPEObjectType,</span></span><br><span class="line"><span class="params">KPROCESSOR_MODE AccessMode,</span></span><br><span class="line"><span class="params">PVOID* object,</span></span><br><span class="line"><span class="params">POBJECT_HANDLE_INFORMATION HandleInformation</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></tbody></table></figure><p><strong>Handle</strong> 参数表示句柄值。</p><p><strong>DesiredAccess</strong> 参数表示需要获取此对象的权限，针对不同类型的对象，这个权限的值不同，对于本例的EVENT对象来说，这个值可以传递EVENT_ALL_ACCESS，表示EVENT的所有权限。</p><p><strong>ObjectType</strong> 参数 表示对象的类型，不同的对象用不同的“对象类型”来表示，</p><p><strong>AccessMode</strong>  参数表示访问模式，可以是KernelMode或UserMode，分别表示用户态与内核态。如果参数Handle是内核句柄，则应该传递KernelMode。参数Object是返回参数，若函数执行成功则该参数保存对象的指针。<strong>HandleInformation</strong> 参数暂时没用，可以设置为NULL。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> kernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kernel programm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++ volatile</title>
      <link href="/posts/16c1.html"/>
      <url>/posts/16c1.html</url>
      
        <content type="html"><![CDATA[<p><em>原文地址：<a href="https://www.cnblogs.com/yc_sunniwell/archive/2010/07/14/1777432.html">https://www.cnblogs.com/yc_sunniwell/archive/2010/07/14/1777432.html</a></em></p><p>近日在读操作系统导论，看到书中的代码里面有volatile 关键字，找到了一篇不错的文章，所以转载了过来。</p><h1 id="为什么用volatile"><a class="markdownIt-Anchor" href="#为什么用volatile"></a> 为什么用volatile?</h1><p>C/C++ 中的 volatile 关键字和 const 对应，用来修饰变量，通常用于建立语言级别的 memory barrier。这是 BS 在 “The C++ Programming Language” 对 volatile 修饰词的说明：</p><p>​<em>A volatile specifier is a hint to a compiler that an object may change its value in ways not specified by the language so that aggressive optimizations must be avoided.</em></p><p>volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。声明时语法：<strong>int volatile vInt;</strong> 当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。</p><p>例如：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> i=<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a = i;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 其他代码，并未明确告诉编译器，对 i 进行过操作</span></span><br><span class="line"><span class="type">int</span> b = i;</span><br></pre></td></tr></tbody></table></figure><p>volatile 指出 i 是随时可能发生变化的，每次使用它的时候必须从 i的地址中读取，因而编译器生成的汇编代码会重新从i的地址读取数据放在 b 中。而优化做法是，由于编译器发现两次从 i读数据的代码之间的代码没有对 i 进行过操作，它会自动把上次读的数据放在 b 中。而不是重新从 i 里面读。这样以来，如果 i是一个寄存器变量或者表示一个端口数据就容易出错，所以说 volatile 可以保证对特殊地址的稳定访问。注意，在 VC 6 中，一般调试模式没有进行代码优化，所以这个关键字的作用看不出来。下面通过插入汇编代码，测试有无 volatile 关键字，对程序最终代码的影响，输入下面的代码：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> a = i;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"i = %d"</span>, a);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 下面汇编语句的作用就是改变内存中 i 的值</span></span><br><span class="line">    <span class="comment">// 但是又不让编译器知道</span></span><br><span class="line">    __asm {</span><br><span class="line">        mov dword ptr [ebp<span class="number">-4</span>], <span class="number">20</span>h</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> b = i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"i = %d"</span>, b);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>然后，在 Debug 版本模式运行程序，输出结果如下：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">i = <span class="number">10</span></span><br><span class="line">i = <span class="number">32</span></span><br></pre></td></tr></tbody></table></figure><p>然后，在 Release 版本模式运行程序，输出结果如下：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">i = <span class="number">10</span></span><br><span class="line">i = <span class="number">10</span></span><br></pre></td></tr></tbody></table></figure><p>输出的结果明显表明，Release 模式下，编译器对代码进行了优化，第二次没有输出正确的 i 值。下面，我们把 i 的声明加上 volatile 关键字，看看有什么变化：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> a = i;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"i = %d"</span>, a);</span><br><span class="line">    __asm {</span><br><span class="line">        mov dword ptr [ebp<span class="number">-4</span>], <span class="number">20</span>h</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span> b = i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"i = %d"</span>, b);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>分别在 Debug 和 Release 版本运行程序，输出都是：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">i = <span class="number">10</span></span><br><span class="line">i = <span class="number">32</span></span><br></pre></td></tr></tbody></table></figure><p>这说明这个 volatile 关键字发挥了它的作用。其实不只是内嵌汇编操纵栈"这种方式属于编译无法识别的变量改变，另外更多的可能是多线程并发访问共享变量时，一个线程改变了变量的值，怎样让改变后的值对其它线程 visible。一般说来，volatile用在如下的几个地方：</p><ol><li><p>中断服务程序中修改的供其它程序检测的变量需要加 volatile；</p></li><li><p>多任务环境下各任务间共享的标志应该加 volatile；</p></li><li><p>存储器映射的硬件寄存器通常也要加 volatile 说明，因为每次对它的读写都可能由不同意义；</p></li></ol><h1 id="volatile-指针"><a class="markdownIt-Anchor" href="#volatile-指针"></a> volatile 指针</h1><p>和 const 修饰词类似，const 有常量指针和指针常量的说法，volatile 也有相应的概念：</p><p>修饰由指针指向的对象、数据是 const 或 volatile 的：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* cpch;</span><br><span class="line"><span class="keyword">volatile</span> <span class="type">char</span>* vpch;</span><br></pre></td></tr></tbody></table></figure><p>注意：对于 VC，这个特性实现在 VC 8 之后才是安全的。</p><p>指针自身的值——一个代表地址的整数变量，是 const 或 volatile 的：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="type">const</span> pchc;</span><br><span class="line"><span class="type">char</span>* <span class="keyword">volatile</span> pchv;</span><br></pre></td></tr></tbody></table></figure><p><strong>注意：</strong></p><ol><li><p>把一个非volatile int赋给volatile int，但是不能把非volatile对象赋给一个volatile对象。</p></li><li><p>除了基本类型外，对用户定义类型也可以用volatile类型进行修饰。</p></li><li><p>C++中一个有volatile标识符的类只能访问它接口的子集，一个由类的实现者控制的子集。用户只能用const_cast来获得对类型接口的完全访问。此外，volatile向const一样会从类传递到它的成员。</p></li></ol><h1 id="多线程下的volatile"><a class="markdownIt-Anchor" href="#多线程下的volatile"></a> 多线程下的volatile</h1><p>有些变量是用 volatile 关键字声明的。当两个线程都要用到某一个变量且该变量的值会被改变时，应该用 volatile 声明，该关键字的作用是防止优化编译器把变量从内存装入 CPU 寄存器中。如果变量被装入寄存器，那么两个线程有可能一个使用内存中的变量，一个使用寄存器中的变量，这会造成程序的错误执行。volatile 的意思是让编译器每次操作该变量时一定要从内存中真正取出，而不是使用已经存在寄存器中的值，如下：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span>  BOOL  bStop  =  FALSE;</span><br></pre></td></tr></tbody></table></figure><p>(1) 在一个线程中：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(  !bStop  )  {  ...  }  </span><br><span class="line">bStop  =  FALSE;  </span><br><span class="line"><span class="keyword">return</span>;  </span><br></pre></td></tr></tbody></table></figure><p>(2) 在另外一个线程中，要终止上面的线程循环：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">bStop  =  TRUE;  </span><br><span class="line"><span class="keyword">while</span>(  bStop  );  <span class="comment">//等待上面的线程终止，如果bStop不使用volatile申明，那么这个循环将是一个死循环，因为bStop已经读取到了寄存器中，寄存器中bStop的值永远不会变成FALSE，加上volatile，程序在执行时，每次均从内存中读出bStop的值，就不会死循环了。</span></span><br></pre></td></tr></tbody></table></figure><p>这个关键字是用来设定某个对象的存储位置在内存中，而不是寄存器中。因为一般的对象编译器可能会将其的拷贝放在寄存器中用以加快指令的执行速度，例如下段代码中：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">...  </span><br><span class="line"><span class="type">int</span>  nMyCounter  =  <span class="number">0</span>;  </span><br><span class="line"><span class="keyword">for</span>(;  nMyCounter&lt;<span class="number">100</span>;nMyCounter++)  </span><br><span class="line">{  </span><br><span class="line">...  </span><br><span class="line">}  </span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure><p>在此段代码中，nMyCounter 的拷贝可能存放到某个寄存器中（循环中，对 nMyCounter 的测试及操作总是对此寄存器中的值进行），但是另外又有段代码执行了这样的操作：<strong>nMyCounter -= 1;</strong> 这个操作中，对 nMyCounter 的改变是对内存中的 nMyCounter 进行操作，于是出现了这样一个现象：nMyCounter 的改变不同步。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内存分配</title>
      <link href="/posts/9fa6.html"/>
      <url>/posts/9fa6.html</url>
      
        <content type="html"><![CDATA[<h1 id="内存分配与回收"><a class="markdownIt-Anchor" href="#内存分配与回收"></a> 内存分配与回收</h1><h2 id="内存分配"><a class="markdownIt-Anchor" href="#内存分配"></a> 内存分配</h2><p>ExAllocatePoolWithTag(内存分配函数)</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">PVOID <span class="title function_">ExAllocatePoolWithTag</span><span class="params">(</span></span><br><span class="line"><span class="params">POOL_TYPE PoolType,</span></span><br><span class="line"><span class="params">    SIZE_T NumberOfBytes,</span></span><br><span class="line"><span class="params">    ULONG Tag</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></tbody></table></figure><p><strong>PoolType</strong> 为 POOL_TYPE 枚举类型，表示需要申请何种类型的内存。</p><p>常用的值是 NonPagedPool 与 PagedPool，NonPagedPool表示非分页内存，PagedPool表示分页内存。</p><p><strong>注意</strong>： 非分页内存是指这块内存的内容不会被置换到磁盘上，非分页内存非常宝贵，一般用于高IRQL（大于等于DISPATCH_LEVEL）的代码中。</p><p>两个类型：NonPagedPoolExecute  与  NonPagedPoolNx<br>NonPagedPoolNx类型是指分配出来的非分页内存不具备“可执行”属性。对非分页内存进行读写而不需要进行代码或指令执行，那么可以使用NonPagedPoolNx类型的内存</p><p>NonPagedPoolExecute 类型与 NonPagedPool 类型等价。</p><p><strong>NumberOfBytes</strong>参数表示需要申请内存大小，单位是字节。</p><p><strong>Tag</strong>参数是一个4个字节的标志，一般每个驱动程序定义一个自己的内存标记。也可以在每个模块中定义单独的内存标记。内存标记是随意的32位数字。即使冲突也不会有什么问题，这个Tag一般用于问题排查，如内存泄露，系统蓝屏等。</p><p><strong>注意</strong>： ExAllocatePoolWithTag 函数成功执行后返回分配内存的首地址，失败返回NULL。使用过程中务必对该函数返回值进行判断。</p><p>下的例子，是把一个字符串src拷贝到字符串dst。</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个内存分配标记</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_TAG    ‘MyTt’</span></span><br><span class="line"><span class="comment">// 目标字符串，接下来它需要分配空间。</span></span><br><span class="line">UNICODE_STRING dst = { <span class="number">0</span> };</span><br><span class="line"><span class="comment">// 分配空间给目标字符串。根据源字符串的长度。</span></span><br><span class="line">dst.Buffer = (PWCHAR)ExAllocatePoolWithTag(NonpagedPool,src-&gt;Length,MEM_TAG);</span><br><span class="line"><span class="keyword">if</span>(dst.Buffer == <span class="literal">NULL</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">// 错误处理</span></span><br><span class="line">    status = STATUS_INSUFFICIENT_RESOUCRES;</span><br><span class="line">    ……</span><br><span class="line">}</span><br><span class="line">dst.Length = dst.MaximumLength = src-&gt;Length;</span><br><span class="line">status = RtlCopyUnicodeString(&amp;dst,&amp;src);</span><br><span class="line">ASSERT(status == STATUS_SUCCESS);</span><br></pre></td></tr></tbody></table></figure><h2 id="内存释放"><a class="markdownIt-Anchor" href="#内存释放"></a> 内存释放</h2><p>ExFreePoolWithTag(内存释放函数)</p><p>ExAllocatePool这个函数已经废弃不用了，所以内核中最常见的分配内存的方法就是调用ExAllocatePoolWithTag函数。ExAllocatePoolWithTag的原型如下：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">VOID <span class="title function_">ExFreePoolWithTag</span><span class="params">(PVOID P,ULONG Tag)</span>;</span><br></pre></td></tr></tbody></table></figure><p><strong>P</strong> 参数表示需要释放的内存块地址</p><p><strong>Tag</strong> 参数对应内存申请时的标记</p><p><strong>注意</strong>：</p><ol><li>内存分配和释放函数要配套使用，分配内存使用ExAllocatePool函数，释放使用相应的ExFreePool函数。</li><li>ExAllocatePoolWithTag分配的内存可以使用ExFreePool来释放。如果不释放，则永远泄漏。并不像用户进程关闭后自动释放所有分配的空间。即使驱动程序动态卸载，也不能释放空间。唯一的办法是重启计算机。</li></ol><h1 id="旁视列表"><a class="markdownIt-Anchor" href="#旁视列表"></a> 旁视列表</h1><h2 id="旁视列表的原理"><a class="markdownIt-Anchor" href="#旁视列表的原理"></a> <strong>旁视列表的原理</strong>：</h2><p>开发者首先初始化一个“旁视列表”对象，初始化时设置“旁视列表”中内存块的大小，在需要使用内存的时候，直接向“旁视列表”对象申请内存(申请的内存的大小为初始值申请值)，在内存使用完毕后，需要通过“旁视列表”对象来回收这些内存；最后，当不再需要使用“旁视列表”对象时将其删除。</p><h2 id="旁视列表内存机制"><a class="markdownIt-Anchor" href="#旁视列表内存机制"></a> <strong>旁视列表内存机制</strong>：</h2><p>旁视列表  对象内部会维护内存的使用状态，一块内存使用结束后，会释放回“旁视列表”对象内，但这块内存不会马上被释放到操作系统的Pool中。如果这个时候开发者向“旁视列表”对象申请内存，“旁视列表”对象会把刚才回收的内存块返回给申请者。</p><p>这种类似“缓存”的机制，“旁视列表”对象对内存进行了二次管理，减少了向系统Pool申请或释放的次数，提高了性能。</p><h2 id="旁视列表-初始化"><a class="markdownIt-Anchor" href="#旁视列表-初始化"></a> “旁视列表” 初始化</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ExinitializeNPagedLookadideList</span><span class="params">(</span></span><br><span class="line"><span class="params">PANPAGED_LOOKASIDE_LIST Lookaside,</span></span><br><span class="line"><span class="params">    PANLLOCATE_FUNCTION Allocate,</span></span><br><span class="line"><span class="params">    PFREE_FUNCTIONFree,</span></span><br><span class="line"><span class="params">    ULONGFlages,</span></span><br><span class="line"><span class="params">    SIZE_TSize,</span></span><br><span class="line"><span class="params">    ULONGTag,</span></span><br><span class="line"><span class="params">    USHORTDepth</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></tbody></table></figure><p><strong>Lookaside</strong> 参数表示被初始化的“旁视列表”对象的指针，在64位系统下，这个指针必须以16字节对齐。</p><p><strong>Allocate</strong> 参数是一个函数指针，从已初始化的“旁视列表”对象分配内存时，系统会调用开发者设置的 Allocate 函数。</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">PVOID <span class="title function_">XxxAllocate</span><span class="params">(</span></span><br><span class="line"><span class="params">POOL_TYPE PoolType,</span></span><br><span class="line"><span class="params">    SIZE_T NumberOfBytes,</span></span><br><span class="line"><span class="params">    ULONG Tag</span></span><br><span class="line"><span class="params">)</span>;<span class="comment">//Allocate函数的原型</span></span><br></pre></td></tr></tbody></table></figure><p>设置Allocate参数为NULL，系统则使用默认的内存分配函数</p><p>**Free **参数是一个函数指针，删除从“旁视列表”对象中申请出来的内存块时，系统就会调用 Free 参数指向的函数</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">VOID <span class="title function_">XxxFree</span><span class="params">(PVOID Buffer)</span>;</span><br></pre></td></tr></tbody></table></figure><p>设置 Free 参数为NULL，在这种情况下，系统使用默认的释放函数。</p><p><strong>Flags</strong> 参数控制“旁视列表”对象的内存分配行为，这个参数只有在Windows 8以及后续系统中才有意义。</p><p><strong>POOL_NX_ALLOCATION</strong>：表示分配的非分页内存的属性为“不可执行”，类似上一节介绍的NonPagedPoolNx标志。</p><p><strong>POOL_RAISE_IF_ALLOCATION_FAILURE</strong>：表示如果内存失败，将抛出一个异常。</p><p>如果没有特殊要求，可以把Flags参数设置为0。</p><p><strong>Size</strong> 参数表示每次从“旁视列表”对象中申请内存的固定大小，单位是字节，这个值不能小于LOOKASIDE_MINIMUM_BLOCK_SIZE。</p><p>LOOKASIDE_MINIMUM_BLOCK_SIZE是WDK定义的一个宏，定义如下：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LOOKASIDE_MINIMUM_BLOCK_SIZE (RTL_SIZEOF_THROUGH_FIELD (SLIST_ENTRY,Next))</span></span><br></pre></td></tr></tbody></table></figure><p>RTL_SIZEOF_THROUGH_FIELD定义如下：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RTL_SIZEOF_THROUGH_FIELD(type,field) \</span></span><br><span class="line"><span class="meta">(FIELD_OFFSET(type,field)+RTL_FIELD_SIZE(type,field))</span></span><br><span class="line"></span><br><span class="line">FIELD_OFFSET 以及 RTL_FIELD_SIZE 的定义</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RTl_FIELD_SIZE(type,field) (sizeof(((type *)0)-&gt;field))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIELD_OFFSET(type,field)   (LONG)(LONG_PTR)&amp;(((type *)-&gt;field))</span></span><br></pre></td></tr></tbody></table></figure><p>RTL_SIZEOF_THROUGH_FIELD宏计算的是type结构体中field成员距离结构体首地址的偏移大小，加上field成员本身的大小。</p><p>LOOKASIDE_MINIMUM_BLOCK_SIZE宏来说，计算的是Next成员与SLIST_ENTRY首地址的距离加上Next成员自身的大小。</p><p>SLIST_ENTRY定义:</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SLIST_ENTRY</span>{</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">SLIST_ENTRY</span> *<span class="title">Next</span>;</span></span><br><span class="line">}SLIST_ENTRY, *PLIST_ENTRY;</span><br></pre></td></tr></tbody></table></figure><p>在64位系统下，LOOKASIDE_MINIMUM_BLOCK_SIZE宏的值为8；</p><p><strong>Tag</strong> 参数表示分配内存时所使用的标记，与ExAllocatePoolWithTag函数中的Tag参数函数一样。</p><p><strong>Depth</strong> 参数是一个保留参数，没有意义，传递0即可；</p><h2 id="内存申请与释放"><a class="markdownIt-Anchor" href="#内存申请与释放"></a> 内存申请与释放</h2><p>内存申请函数</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">ExAllocateFormNPageLookasideList(PNPAGED_LOOKASIDE_LIST Lookaside);</span><br></pre></td></tr></tbody></table></figure><p>只需要传入“旁氏列表” 对象的地址传入上面的函数，就可以分配函数指定大小的内存。执行成功的话就会返回相应的内存块，否则返回NULL。</p><p>内存释放函数</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">ExFreeToNPagedLookasideList(</span><br><span class="line">PNPAGED_LOOKASIDE_LIST Lookaside,</span><br><span class="line">    PVOIDEntry</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure><p>Lookaside为“旁视列表”对象指针，Entry指针表示需要释放的内存块，也就是ExAllocateFromNPagedLookasideList的返回值。</p><h2 id="旁氏列表删除"><a class="markdownIt-Anchor" href="#旁氏列表删除"></a> 旁氏列表删除</h2><p>删除函数</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">ExDeleteNPageLookasideList(PNPAGED_LOOKASIDE_LIST Lookaside)</span><br></pre></td></tr></tbody></table></figure><p><strong>Lookaside</strong>  参数表示需要删除的“旁视列表”对象。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> kernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kernel programm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自旋锁</title>
      <link href="/posts/e3da.html"/>
      <url>/posts/e3da.html</url>
      
        <content type="html"><![CDATA[<h1 id="自旋锁"><a class="markdownIt-Anchor" href="#自旋锁"></a> 自旋锁</h1><p>自旋锁是内核中提供的一种高IRQL锁，用同步以及独占的方式访问某个资源。</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">KSPIN_LOCK my_spin_lock;</span><br><span class="line">KeInitializeSpinLock(&amp;my_spin_lock); <span class="comment">//函数无返回值</span></span><br></pre></td></tr></tbody></table></figure><p>自旋锁的使用方法：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">KIRQL irql;<span class="comment">//KIRQL是一个中断级</span></span><br><span class="line">KeAcquireSpinLock(&amp;my_spin_lock,&amp;irql);</span><br><span class="line"><span class="comment">// To do something ...</span></span><br><span class="line">KeReleaseSpinLock(&amp;my_spin_lock,irql);</span><br></pre></td></tr></tbody></table></figure><p>KeAcquireSpinLock 和 KeReleaseSpinLock 之间的代码是只有单线程执行的，其他的线程会停留在 KeAcquireSpinLock 等候，直到 KeReleaseSpinLock 被调用。换句话说，只有一个线程能够获得自旋锁。</p><p><strong>注意</strong>： 锁一般不会定义成局部变量，可以使用静态变量、全局变量，或者分配在池（POOL）中。因为每个线程来执行的时候都会重新初始化一个锁。只有所有的线程共用一个锁，锁才有意义。</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*正确使用自旋锁的例子*/</span></span><br><span class="line">KSPIN_LOCK my_spin_lock = {<span class="number">0</span>};</span><br><span class="line">Void <span class="title function_">InitSpinLock</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    KeInitializeSpinLock(&amp;my_spin_lock);</span><br><span class="line">}</span><br><span class="line">Void <span class="title function_">MySafeFunction</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    KIRQL irql;</span><br><span class="line">    KeAcquireSpinlock(&amp;my_spin_lock,&amp;irql);</span><br><span class="line">    <span class="comment">// To do something...</span></span><br><span class="line">    KeRealeaseSpinLock(&amp;my_spin_lock,irql);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="双向链表自旋锁"><a class="markdownIt-Anchor" href="#双向链表自旋锁"></a> 双向链表自旋锁</h1><p>在双向链表中使用自旋锁的目的是保证多线程安全。在操作链表之前，调用KeAcquireSpinLock 来获取锁，在操作完成之后，调用 KeReleaseSpinLock 来释放锁。</p><p>链表中初始化自旋锁。LIST_ENTRY有一系列操作，这些操作并不需要使用者自己调用获取与释放锁，只需要为每个链表定义并初始化一个锁即可。</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">FILE_INFO</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    LIST_ENTRY m_ListEntry;</span><br><span class="line">    WCHAR m_strFileName[<span class="number">260</span>];</span><br><span class="line">    <span class="comment">// other member</span></span><br><span class="line">}FILE_INFO, *PFLIE_INFO;</span><br><span class="line"></span><br><span class="line">LIST_ENTRY my_list_head; <span class="comment">//链表头</span></span><br><span class="line">KSPIN_LOCK my_list_lock; <span class="comment">//链表的值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyFileInforInit</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    InitializeListHead(&amp;my_list_head);</span><br><span class="line">    KeInitalizeSpinLock(&amp;my_list_lock);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>正常情况下链表插入一个节点：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">FILE_INFO my_file_infor={<span class="number">0</span>};</span><br><span class="line"><span class="comment">// 对 my_file_infor 进行初始化</span></span><br><span class="line"> InsertHeadList(&amp;my_list_head,(PLIST_ENTRY)&amp; my_file_infor);</span><br></pre></td></tr></tbody></table></figure><p>加锁的情况下链表插入一个节点：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">ExInterlockInsertHeadList(</span><br><span class="line">&amp;my_list_head,</span><br><span class="line">    (PLIST_ENTRY)&amp; my_file_infor,</span><br><span class="line">    &amp;my_list_lock</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure><p>加锁的情况下链表移除一个节点：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">PLSIT_ENTRY pRemoveEntry = <span class="literal">NULL</span>;</span><br><span class="line">pRemoveEntry = ExInterlockInsertHeadList(</span><br><span class="line">&amp;my_list_head,</span><br><span class="line">    &amp;my_list_lock</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure><p><strong>注意</strong>: 锁一般不会定义成局部变量。可以使用静态变量、全局变量，或者分配在堆中。</p><h1 id="队列自旋锁"><a class="markdownIt-Anchor" href="#队列自旋锁"></a> 队列自旋锁</h1><p>队列自旋锁遵守“谁先等待，谁先获取自旋锁”的原则。其过程和队列的“First inFirst out”特点非常类似，正是由于这个原因，这种自旋锁被称为“队列自旋锁”。</p><p>队列自旋锁的获取和释放</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">VOID <span class="title function_">KeAcquireInStackQueueSpinlock</span><span class="params">(</span></span><br><span class="line"><span class="params">    IN PKSPIN_LOCK SpinLock,</span></span><br><span class="line"><span class="params">IN PKSPIN_QUEUE_HANDLE LockHandle</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br><span class="line">VOID <span class="title function_">KeReleaseInStackQueueSpinLock</span><span class="params">(</span></span><br><span class="line"><span class="params">IN PKLOCK_QUEUE_HANDLE LockHandle</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></tbody></table></figure><p>队列自旋锁初始化</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">KSPIN_LOCK my_Queue_SpinLock = {<span class="number">0</span>};</span><br><span class="line">KeInitializeSpinLock( &amp;my_Queue_SpinLock );</span><br></pre></td></tr></tbody></table></figure><p>队列自旋锁的获取和释放</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">KLOCK_QUEUE_HANDLE my_lock_queue_handle;</span><br><span class="line">KeAcquireInStackQueuedSpinLock(&amp;my_Queue_SpinLock,&amp;my_lock_queue_handle )；<span class="comment">//do something</span></span><br><span class="line">KeReleaseInStackQueueSpinLock( &amp;my_Queue_SpinLock );</span><br></pre></td></tr></tbody></table></figure><p><strong>注意</strong>：</p><ol><li>队列自旋锁的使用增加了一个 KLOCK_QUEUE_HANDLE 数据结构，这个数据结构唯一地表示一个队列自旋锁。</li><li>普通自旋锁和队列自旋锁虽然都是使用 KeInitializeSpinLock 函数来初始化的，但是对于一个初始化后的自旋锁，要么按普通自旋锁方式来使用，要么按队列自旋锁方式来使用，绝对不能混用。</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> kernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kernel programm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LIST_ENTRY</title>
      <link href="/posts/2587.html"/>
      <url>/posts/2587.html</url>
      
        <content type="html"><![CDATA[<h1 id="链表的定义"><a class="markdownIt-Anchor" href="#链表的定义"></a> 链表的定义：</h1><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> *<span class="title">Flink</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">LIST_ENTRY</span> *<span class="title">Blink</span>;</span></span><br><span class="line">}LIST_ENTRY, *PLIST_ENTRY;</span><br></pre></td></tr></tbody></table></figure><p>LIST_ENTRY表示一个链表的节点，其中Flink成员指向当前节点的后一个节点，Blink成员指向当前节点的前一个节点。</p><p>链表的使用：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">TestListEntry</span></span></span><br><span class="line"><span class="class">{</span></span><br><span class="line">    ULONG m_ulDataA;</span><br><span class="line">    ULONG m_ulDataB;</span><br><span class="line">    LIST_ENTRY m_ListEntry;</span><br><span class="line">    <span class="comment">/*双向链表节点的结构，m_ListEntry可以放在结构体的任意位置*/</span></span><br><span class="line">    ULONG m_ulDataC;</span><br><span class="line">    ULONG m_ulDataD;</span><br><span class="line">}TestListEntry, *PTestListEntry;</span><br></pre></td></tr></tbody></table></figure><p>m_ulDataA成员处于最低地址，m_ulDataD处于最高地址，而链表节点LIST_ENTRY的两个成员展开后在结构体中分别为Flink与Blink，其中Flink处于低地址，Blink处于高地址。</p><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20210202175751.jpg" alt="内存布局"></p><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20210202175817.jpg" alt="节点的关系"></p><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20210202180503.jpg" alt="包含头结点"></p><h1 id="头结点初始化"><a class="markdownIt-Anchor" href="#头结点初始化"></a> 头结点初始化</h1><p>头结点的定义和初始化</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">LIST_ENTRAY ListHeader = {<span class="number">0</span>};</span><br><span class="line">InitializeListHeader(&amp;ListHeader);</span><br></pre></td></tr></tbody></table></figure><p>InitializeListHead函数，函数只有一个参数ListHead，表示需要被初始化的头节点</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">VOID <span class="title function_">InitializeListHead</span><span class="params">(_Out_PLIST_ENTRAY ListHead)</span></span><br><span class="line">{</span><br><span class="line">    ListHeader-&gt;Flink = ListHeader-&gt;Blink = listHead;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>当只存在头结点的时候，没有其他节点时，这个链表就是一个空链表，用 IsListEmpty 可以判断一个链表是否为空，IsListEmpty返回TRUE表示链表为空链表，返回FALSE表示链表非空。</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">BOOLEAN　<span class="title function_">IslistEmpty</span><span class="params">(const_LIST_ENTRY *ListHead )</span>；</span><br></pre></td></tr></tbody></table></figure><h1 id="节点插入"><a class="markdownIt-Anchor" href="#节点插入"></a> 节点插入</h1><p>InsertHeadList函数的作用是把一个节点插入到链表的第一个位置</p><p>InsertTailList函数的作用是把一个节点插入到链表的最后一个位置</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">VOID <span class="title function_">InsertHeadList</span><span class="params">(PLIST_ENTRY ListHead, PLSIT_ENTRY Entry)</span>;</span><br><span class="line">VOID <span class="title function_">InsertTailList</span><span class="params">(PLIST_ENTRY ListHead, PLSIT_ENTRY Entry)</span>;</span><br></pre></td></tr></tbody></table></figure><h1 id="链表的遍历"><a class="markdownIt-Anchor" href="#链表的遍历"></a> 链表的遍历</h1><p>链表遍历可以通过Flink指针从前往后遍历，也可以通过Blink从后往前遍历。</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">PLIST_ENTRY pListEntry = <span class="literal">NULL</span>;</span><br><span class="line">plistEntry = ListHeader.Flink;</span><br><span class="line"><span class="keyword">while</span>(pListEntry!=&amp;ListHeader)</span><br><span class="line">{</span><br><span class="line">    PTestListEntray pTestEntry = CONTINING_RECORD (pListEntry,TestListEntry,m_ListEntry );</span><br><span class="line">    Dbgprint(<span class="string">"ListPtr = %p，Entry = %p,Tag = %c\n"</span>,pListEntry,pTestEntry,(CHAR)pTestEntry-&gt;m_ulDataA);</span><br><span class="line">    PListEntry=pTestEntry-&gt;Flink;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>pTestEntry指针的获取:</p><p>在while循环块中，是通过pListEntry指针进行遍历的，而pListEntry指向的地址是TestListEntry结构体中的m_ListEntry地址，而m_ListEntry成员的地址并不是这个结构体的首地址，所以这里需要通过一个宏CONTAINING_RECORD把m_ListEntry的地址转换成结构体TestListEntry的首地址.</p><p>CONTAINING_RECORD宏的用法:</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">PCHAR <span class="title function_">CONTAINING_RECORD</span><span class="params">(PCHAR Address,TYPE Type,PCHAR Field)</span>;</span><br></pre></td></tr></tbody></table></figure><p>Address表示LIST_ENTRY的地址，在本例中，就是pListEntry指向的地址</p><p>Type表示类型，在本例中为TestListEntry</p><p>Field表示结构体中LIST_ENTRY成员的名字，在本例中为m_ListEntry。</p><p>CONTAINING_RECORD宏通过Type与Field这两个成员，计算出Field成员距离结构体顶部的内存距离，然后结合具体的Address成员，算出最终的结构体首地址。</p><h1 id="节点移除"><a class="markdownIt-Anchor" href="#节点移除"></a> 节点移除</h1><ol><li><p>移除链表中第一个节点与最后一个节点分别使用RemoveHeadList以及RemoveTailList函数。</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">PLIST_ENTRY <span class="title function_">RemoveHeadList</span><span class="params">(PLIST_ENTRY ListHead)</span>;</span><br><span class="line">PLIST_ENTRY <span class="title function_">RemoveTailList</span><span class="params">(PLIST_ENTRY ListHead)</span>;</span><br></pre></td></tr></tbody></table></figure><p>函数仅有一个参数，表示所需要移除的链表头节点指针，这两个函数的返回值均为PLIST_ENTRY，成功移除则返回从链表移除的节点指针，如果无节点可以移除（如链表为空）则返回NULL。</p></li><li><p>移除某个特定节点，即可使用RemoveEntryList函数。</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">BOOLEAN <span class="title function_">RemoveEntryList</span><span class="params">(PLSIT_ENTRY Entry)</span>;</span><br></pre></td></tr></tbody></table></figure><p>Entry表示需要移除的链表节点指针，RemoveEntryList函数的返回值类型为BOOLEAN，节点被移除后，若链表变为空链表，RemoveEntryList返回TRUE，否则返回FALSE。</p></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> kernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kernel programm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UNICODE_STRING</title>
      <link href="/posts/b83c.html"/>
      <url>/posts/b83c.html</url>
      
        <content type="html"><![CDATA[<h1 id="unicode_string数据类型"><a class="markdownIt-Anchor" href="#unicode_string数据类型"></a> UNICODE_STRING数据类型</h1><p>内核层编程一般不直接使用WCHAR类型的Unicode字符串，而是使用UNICODE_STRING类型来表示Unicode。</p><p>这里简单介绍一下 UNICODE_STRING 类型。</p><p>UNICODE_STRING是内核中表示字符串的结构体；</p><p>Buffer为一个指针，指向一个UNICODE类型的字符串缓冲区；</p><p>MaximumLength表示Buffer所指向缓冲区的总空间大小，一般等于Buffer被分配时的内存大小，单位为字节；</p><p>Length表示Buffer所指向缓冲区中字符串的长度，单位也是字节；</p><p><strong>注意</strong>：Buffer指向的字符串，并不要求以’\0’作为结束，在大多数情况下，Buffer指向的字符串没有以’\0’结尾</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span>{</span> </span><br><span class="line">       USHORT Length; </span><br><span class="line">       USHORT MaximumLength; </span><br><span class="line">       PWSTR Buffer;</span><br><span class="line">}UNICODE_STRING, *PUNICODE_STRING;</span><br></pre></td></tr></tbody></table></figure><h1 id="unicode_string-初始化"><a class="markdownIt-Anchor" href="#unicode_string-初始化"></a> UNICODE_STRING 初始化</h1><h2 id="手动初始化"><a class="markdownIt-Anchor" href="#手动初始化"></a> 手动初始化</h2><h3 id="指针赋值"><a class="markdownIt-Anchor" href="#指针赋值"></a> 指针赋值</h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MYSTRING <span class="string">L"www.tlhg.top"</span></span></span><br><span class="line">    <span class="comment">// 先定义后，再定义空间</span></span><br><span class="line">UNICODE_STRING str;</span><br><span class="line">str.Buffer = MYSTRING;</span><br><span class="line">str.Length = str.MaximumLength = wcslen(MYSTRING) * <span class="keyword">sizeof</span>(WCHAR);</span><br></pre></td></tr></tbody></table></figure><p>指针Buffer进行了初始化赋值，这个指针指向的全局常量地址空间，所以这一段地址空间只能读，不可写。<br>如果我们强行对其地址修改，会触发系统的异常，导致蓝屏。</p><h3 id="计算赋值"><a class="markdownIt-Anchor" href="#计算赋值"></a> 计算赋值</h3><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">UNICODE_STRING str = { </span><br><span class="line">    <span class="keyword">sizeof</span>(<span class="string">L"www.tlhg.top"</span>) – <span class="keyword">sizeof</span>((<span class="string">L"www.tlhg.top"</span>)[<span class="number">0</span>]),</span><br><span class="line">    <span class="keyword">sizeof</span>(<span class="string">L"www.tlhg.top"</span>),</span><br><span class="line">    <span class="string">L"www.tlhg.top"</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>分别对结构体的三个变量进行初始化：</p><p>对于UNICODE_STRING的Length,相当于</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">str.Length = <span class="keyword">sizeof</span>(<span class="string">L"www.tlhg.top"</span>) – <span class="keyword">sizeof</span>((<span class="string">L"www.tlhg.top"</span>)[<span class="number">0</span>]);</span><br></pre></td></tr></tbody></table></figure><ul><li>sizeof(L”www.tlhg.top”) 计算该字符串所占的内存空间，这里包括L’\0’。</li><li>sizeof((L”www.tlhg.top”)[0])相当于取的是这个字符串的第一个字符长度，这里因为宽字节，所以是2，两者相减，就计算出了字符串的长度。这里看到确实是以字节为单位计算的，而不是以宽字节的长度为单位的。</li></ul><p>对于UNIOCDE_STRING的MaximumLength成同，则直接使用sizeof计算其所占内存空间。所以这里也就包括了L’\0’2个字节的长度。</p><p>对于UNIOCDE_STRING的Buffer成员，直接使用常量地址空间的地址赋值。</p><h2 id="宏初始化rtl_constant_string"><a class="markdownIt-Anchor" href="#宏初始化rtl_constant_string"></a> 宏初始化（RTL_CONSTANT_STRING）</h2><p>微软封装了字符串初始化的代码，封装成了一个宏RTL_CONSTANT_STRING，我们可以直接使用这个宏来初始化常量字符串。</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> RTL_CONSTANT_STRING(s) \</span></span><br><span class="line"><span class="meta">{ \</span></span><br><span class="line"><span class="meta">    sizeof( s ) - sizeof( (s)[0] ), \</span></span><br><span class="line"><span class="meta">    sizeof( s ) / sizeof(_RTL_CONSTANT_STRING_type_check(s)), \</span></span><br><span class="line"><span class="meta">    _RTL_CONSTANT_STRING_remove_const_macro(s) \</span></span><br><span class="line"><span class="meta">}</span></span><br></pre></td></tr></tbody></table></figure><p>这样一来，初始化字符串就简单的多了</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntdef.h&gt;</span></span></span><br><span class="line">UNICODE_STRING str = RTL_CONSTANT_STRING(<span class="string">L"www.tlhg.top"</span>);</span><br></pre></td></tr></tbody></table></figure><p>要使用宏RTL_CONSTANT_STRING，必须包括头文件ntdef.h，因为这个宏是在ntdef.h头文件中定义的。</p><h2 id="函数初始化rtlinitunicodestring"><a class="markdownIt-Anchor" href="#函数初始化rtlinitunicodestring"></a> 函数初始化（RtlInitUnicodeString）</h2><p>常用的初始化函数为RtlInitUnicodeString，这个函数的作用是把一个以’\0’结尾的WCHAR类型的Unicode字符串初始化成UNICODE_STRING类型的字符串。</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">VOID <span class="title function_">RtlInitUnicodeString</span><span class="params">(</span></span><br><span class="line"><span class="params">    PUNICODE_STRING DestinationString,</span></span><br><span class="line"><span class="params">    PCWSTR SourceString</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></tbody></table></figure><p>RtlInitUnicodeString函数有两个参数，第一个参数为返回类型，表示需要初始化的UNICODE_STRING结构体，第二个参数为传入参数，表示被用来初始化DestinationString的常量WCHAR类型字符串，这个字符串以’\0’为结束符。</p><p><strong>注意</strong>：RtlInitUnicodeString函数在使用的过程中，并不会为字符串的缓冲区申请内存，只是把定义的结构体的的缓冲区指向字符串的首地址，所以我们在使用的过程中，应该注意在使用DestinationString期间，必须保证SourceString有效。</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">UNICODE_STRING str;</span><br><span class="line">RtlInitUnicodeString(&amp;str,<span class="string">L"www.tlhg.top"</span>);</span><br><span class="line">...</span><br><span class="line"><span class="comment">//可以再次初始化</span></span><br><span class="line">RtlInitUnicodeString(&amp;str,<span class="string">L"www.tlhg.top"</span>);</span><br></pre></td></tr></tbody></table></figure><p>注意： 初始化的字符串，不用担心内存释放方面的问题。因为我们并没有分配任何内存,因为这些内存都是使用的是常量地址空间。</p><h1 id="unicode_string-拷贝操作"><a class="markdownIt-Anchor" href="#unicode_string-拷贝操作"></a> UNICODE_STRING 拷贝操作</h1><p>由于 UNICODE_STRING 和ANSI_STRING字符串是一个结构体，所以UNICODE_STRING 和ANSI_STRING字符串的拷贝就不能使用wcscpy和strcpy来进行拷贝了。</p><p>常用的拷贝函数为RtlUnicodeStringCopyString，这个函数的功能是把以’\0’结尾的字符串pszSrc拷贝到DestinationString中。</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">NTSTATUS <span class="title function_">RelUnicodeStringCopystring</span><span class="params">(</span></span><br><span class="line"><span class="params">PUNICODE_STRING DestinationString,</span></span><br><span class="line"><span class="params">    NTSTATUS_PCWSTR pszSrc</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></tbody></table></figure><p>RtlUnicodeStringCopyString会把函数第二个参数pszSrc字符串拷贝到DestinationString所指向的内存中。</p><p><strong>注意</strong>：</p><ol><li>RtlInitUnicodeString函数内部只是简单地使DestinationString.Buffer指向函数的第二个参数SourceString，没有任何的拷贝操作，而RtlUnicodeStringCopyString会把函数第二个参数pszSrc字符串拷贝到DestinationString所指向的内存中。</li><li>使用的时候，要添加头文件 “Ntstrsafe.h”，引入相关的库文件 Ntstrsafe.lib ，简单的做法是在Sources文件中添加一行：TARGETLIBS = $(DDK_LIB_PATH)\ntstrsafe.lib。</li></ol><h2 id="unicode_strng示例"><a class="markdownIt-Anchor" href="#unicode_strng示例"></a> UNICODE_STRNG示例</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">UNICODE_STRING dst;            <span class="comment">// 目标字符串</span></span><br><span class="line">WCHAR dst_buf[<span class="number">256</span>];         <span class="comment">// 不分配内存，故先定义缓冲区</span></span><br><span class="line">UNICODE_STRING src = RTL_CONST_STRING(<span class="string">L"www.tlhg.top"</span>);</span><br><span class="line"><span class="comment">// 把目标字符串初始化为拥有缓冲区长度为256的UNICODE_STRING空串。</span></span><br><span class="line">RtlInitEmptyString(dst,dst_buf,<span class="number">256</span>*<span class="keyword">sizeof</span>(WCHAR));</span><br><span class="line">RtlCopyUnicodeString(&amp;dst,&amp;src);    <span class="comment">// 字符串拷贝！</span></span><br></pre></td></tr></tbody></table></figure><p>以上这个拷贝之所以可以成功，是因为256比 L”www.tlhg.top” 的长度要大。如果小，则拷贝也不会出现任何明示的错误。但是拷贝结束之后，与使用者的目标不符，字符串实际上被截短了。</p><h2 id="stringansi_string示例"><a class="markdownIt-Anchor" href="#stringansi_string示例"></a> STRING/ANSI_STRING示例</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">STRING dst;            <span class="comment">// 目标字符串</span></span><br><span class="line"><span class="type">char</span> dst_buf[<span class="number">256</span>]; <span class="comment">// 不分配内存，故先定义缓冲区</span></span><br><span class="line">STRING src = RTL_CONSTANT_STRING(<span class="string">"www.tlhg.top"</span>);</span><br><span class="line"><span class="comment">// 把目标字符串初始化为拥有缓冲区长度为256的STRING空串。</span></span><br><span class="line">RtlInitEmptyAnsiString(&amp;dst, dst_buf, <span class="number">256</span> * <span class="keyword">sizeof</span>(<span class="type">char</span>));</span><br><span class="line">RtlCopyString(&amp;dst, &amp;src);    <span class="comment">// 字符串拷贝！</span></span><br></pre></td></tr></tbody></table></figure><p>注意：</p><p>如果没有调用RtlInitEmptyString。dst字符串被初始化认为缓冲区长度为0，结果就是dst字符串为空串。</p><h1 id="unicode_string-拼接"><a class="markdownIt-Anchor" href="#unicode_string-拼接"></a> UNICODE_STRING 拼接</h1><h2 id="rtlappendunicodetostring"><a class="markdownIt-Anchor" href="#rtlappendunicodetostring"></a> RtlAppendUnicodeToString</h2><p><strong>RtlAppendUnicodeToString</strong> : 将一个宽字节接接到  UNICODE_STRING 中</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">NTSTATUS status;</span><br><span class="line">UNICODE_STRING dst;      <span class="comment">// 目标字符串</span></span><br><span class="line">WCHAR dst_buf[<span class="number">256</span>];     <span class="comment">// 不分配内存，故先定义缓冲区</span></span><br><span class="line"><span class="comment">// 把目标字符串初始化为拥有缓冲区长度为256的UNICODE_STRING空串</span></span><br><span class="line">RtlInitEmptyUnicodeString(&amp;dst,dst_buf,<span class="number">256</span>*<span class="keyword">sizeof</span>(WCHAR));</span><br><span class="line">status = RtlAppendUnicodeToString(&amp;dst,<span class="string">L"www.tlhg.top"</span>);</span><br></pre></td></tr></tbody></table></figure><p>NTSTATUS是常见的返回值类型。如果函数成功，返回STATUS_SUCCESS。否则的话，是一个错误码。RtlAppendUnicodeToString在目标字符串空间不足的时候依然可以连接字符串，但是会返回一个警告性的错误STATUS_BUFFER_TOO_SMALL。</p><h2 id="rtlappendunicodestringtostring"><a class="markdownIt-Anchor" href="#rtlappendunicodestringtostring"></a> RtlAppendUnicodeStringToString</h2><p>RtlAppendUnicodeStringToString: 希望连接两个UNICODE_STRING，这个函数的第二个参数也是一个UNICODE_STRING的指针。</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">NTSTATUS status;</span><br><span class="line">UNICODE_STRING dst;           <span class="comment">// 目标字符串</span></span><br><span class="line">WCHAR dst_buf[<span class="number">256</span>];           <span class="comment">// 不分配内存，故先定义缓冲区</span></span><br><span class="line">UNICODE_STRING src = RTL_CONSTANT_STRING(<span class="string">L"www.tlhg.top"</span>);</span><br><span class="line">RtlInitEmptyUnicodeString(&amp;dst, dst_buf, <span class="number">256</span> * <span class="keyword">sizeof</span>(WCHAR));</span><br><span class="line">status = RtlAppendUnicodeStringToString(&amp;dst, &amp;src);    <span class="comment">// 字符串拷贝！</span></span><br></pre></td></tr></tbody></table></figure><p>RtlAppendUnicodeStringToString在目标字符串空间不足的时候依然可以连接字符串，但是会返回一个警告性的错误STATUS_BUFFER_TOO_SMALL。</p><h2 id="ansi_string的拼接"><a class="markdownIt-Anchor" href="#ansi_string的拼接"></a> ANSI_STRING的拼接</h2><p>对于ANSI_STRING类型，使用RtlAppendStringToString函数进行字符串拼接。</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">NTSTATUS status;</span><br><span class="line">UNICODE_STRING dst;            </span><br><span class="line">CHAR dst_buf[<span class="number">256</span>];                </span><br><span class="line">RtlInitEmptyString(dst, dst_buf, <span class="number">256</span> * <span class="keyword">sizeof</span>(CHAR));</span><br><span class="line">status = RtlAppendStringToString(&amp;dst,<span class="string">"www.tlhg.top"</span>);</span><br></pre></td></tr></tbody></table></figure><h1 id="unicode_string-打印"><a class="markdownIt-Anchor" href="#unicode_string-打印"></a> UNICODE_STRING 打印</h1><h2 id="普通打印"><a class="markdownIt-Anchor" href="#普通打印"></a> 普通打印</h2><p>字符串的连接另一种常见的情况是字符串和数字的组合。有时数字需要被转换为字符串。有时需要把若干个数字和字符串混合组合起来。这往往用于打印日志的时候。日志中可能含有文件名、时间、和行号，以及其他的信息。</p><p>C语言sprintf函数的宽字符版本为swprintf。该函数在驱动开发中依然可以使用，但是不安全。微软建议使用RtlStringCbPrintfW来代替它。RtlStringCbPrintfW需要包含头文件ntstrsafe.h。在连接的时候，还需要连接库ntsafestr.lib。</p><p>下面的代码生成一个字符串，字符串中包含文件的路径，和这个文件的大小。</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntstrsafe.h&gt;</span></span></span><br><span class="line"><span class="comment">/* 任何时候，假设文件路径的长度为有限的都是不对的。应该动态的分配内存。但是动态分配内存的方法还没有讲述，所以这里再次把内存空*间定义在局部变量中，也就是所谓的“在栈中”</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">WCHAR buf[<span class="number">512</span>] = { <span class="number">0</span> };</span><br><span class="line">UNICODE_STRING dst;</span><br><span class="line">NTSTATUS status;</span><br><span class="line">……</span><br><span class="line"><span class="comment">// 字符串初始化为空串。缓冲区长度为512*sizeof(WCHAR)</span></span><br><span class="line">RtlInitEmptyString(dst,dst_buf,<span class="number">512</span>*<span class="keyword">sizeof</span>(WCHAR));</span><br><span class="line"><span class="comment">// 调用RtlStringCbPrintfW来进行打印</span></span><br><span class="line">status = RtlStringCbPrintfW(</span><br><span class="line">    dst-&gt;Buffer,L”file path = %wZ file size = %d \r\n”，</span><br><span class="line">    &amp;file_path,file_size);</span><br><span class="line"><span class="comment">// 这里调用wcslen没问题，这是因为RtlStringCbPrintfW打印的</span></span><br><span class="line"><span class="comment">// 字符串是以空结束的。</span></span><br><span class="line">    dst-&gt;Length = wcslen(dst-&gt;Buffer) * <span class="keyword">sizeof</span>(WCHAR);</span><br></pre></td></tr></tbody></table></figure><p>RtlStringCbPrintfW在目标缓冲区内存不足的时候依然可以打印，但是多余的部分被截去了。返回的status值为STATUS_BUFFER_OVERFLOW。调用这个函数之前很难知道究竟需要多长的缓冲区。一般都采取倍增尝试。每次都传入一个为前次尝试长度为2倍长度的新缓冲区，直到这个函数返回STATUS_SUCCESS为止。</p><p>值得注意的是UNICODE_STRING类型的指针，用%wZ打印可以打印出字符串。在不能保证字符串为空结束的时候，必须避免使用%ws或者%s。其他的打印格式字符串与传统C语言中的printf函数完全相同。可以尽情使用。</p><h2 id="输出打印"><a class="markdownIt-Anchor" href="#输出打印"></a> 输出打印</h2><p>驱动中可以调用DbgPrint()函数来打印调试信息。这个函数的使用和printf基本相同。但是格式字符串要使用宽字符。DbgPrint()的一个缺点在于，发行版本的驱动程序往往不希望附带任何输出信息，只有调试版本才需要调试信息。但是DbgPrint()无论是发行版本还是调试版本编译都会有效。为此可以自己定义一个宏：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> DBG</span></span><br><span class="line">    KdPrint(a)    DbgPrint#<span class="meta">#a</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    KdPrint (a)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure><p>不过这样的后果是，由于KdPrint (a)只支持1个参数，因此必须把DbgPrint的所有参数都括起来当作一个参数传入。导致KdPrint看起来很奇特的用了双重括弧：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 调用KdPrint来进行输出调试信息</span></span><br><span class="line">status = KdPrint((<span class="string">L"file path = %wZ file size = %d \r\n"</span>,&amp;file_path,file_size));</span><br></pre></td></tr></tbody></table></figure><p>这个宏没有必要自己定义，WDK包中已有。所以可以直接使用KdPrint来代替DbgPrint取得更方便的效果。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> kernel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kernel programm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ Calculator</title>
      <link href="/posts/190e.html"/>
      <url>/posts/190e.html</url>
      
        <content type="html"><![CDATA[<p>《The C++ Programming Language》 第六章函数的一个例子。</p><p>没有高深的算法，都是c++中最常用的语法现象，但是这150行程序里蕴含的功力极深（至少我达不到这种水平，程序的效率，存储开销等方面做的都非常出色，甚至是天衣无缝）。</p><p>今日贴出，请大家一同欣赏（作者在程序中因为简化程序而改写了一些更好的方法，正如作者在序言中所说，要有一种健康的怀疑态度,我之所以说它完美，并不是指我们编不出比它好的程序，而是指它清晰的结构，合理的设计，以及蕴含在这里面的编程艺术）</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">////////////////////////////////////////////////////////////// </span></span><br><span class="line"><span class="comment">//以下是 c++之父写的一个简单计算器程序 包括分析器,输入,符号表,驱动程序 </span></span><br><span class="line"><span class="comment">//计算器的输入语法: </span></span><br><span class="line"><span class="comment">// 1)以 ";" 号作为一行的结束 </span></span><br><span class="line"><span class="comment">// 2)可用英文单词命名变量 (但变量后要有空格) </span></span><br><span class="line"><span class="comment">// 例子如下: </span></span><br><span class="line"><span class="comment">// 输入: r =2.5; (注意空格) </span></span><br><span class="line"><span class="comment">// 输出: 2.5 (记负值结果) </span></span><br><span class="line"><span class="comment">// 输入: area = r * r * pi ; </span></span><br><span class="line"><span class="comment">// 输出: 19.635 </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// 以下代码为标准c++代码,我在vc++2003.net上运行无误 </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ture=<span class="number">1</span>; </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> flase=<span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">map&lt;string,<span class="type">double</span>&gt; table; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////// </span></span><br><span class="line"><span class="comment">//计算器输入允许的词法 </span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Token_value</span>{ </span><br><span class="line">    NAME, NUMBER, END, </span><br><span class="line">    PLUS=<span class="string">'+'</span>, MINUS=<span class="string">'-'</span>, MUL=<span class="string">'*'</span>, DIV=<span class="string">'/'</span>, </span><br><span class="line">    PRINT=<span class="string">';'</span>, ASSIGN=<span class="string">'='</span>, LP=<span class="string">'('</span>, RP=<span class="string">')'</span>, </span><br><span class="line">}; </span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////// </span></span><br><span class="line"><span class="comment">//分析器 加和减 </span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">expr</span><span class="params">(<span class="type">bool</span>)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////// </span></span><br><span class="line"><span class="comment">//分析器 乘和除 </span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">term</span><span class="params">(<span class="type">bool</span>)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////// </span></span><br><span class="line"><span class="comment">//分析器 处理初等项 </span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">prim</span><span class="params">(<span class="type">bool</span>)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////// </span></span><br><span class="line"><span class="comment">//词法分析器 </span></span><br><span class="line"><span class="function">Token_value <span class="title">get_token</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////// </span></span><br><span class="line"><span class="comment">//错误处理 </span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">error</span><span class="params">(<span class="type">const</span> string &amp;s)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////////////////////// </span></span><br><span class="line"><span class="comment">//当前词法标记 </span></span><br><span class="line">Token_value curr_tok=PRINT; </span><br><span class="line"></span><br><span class="line"><span class="type">double</span> number_value;  <span class="comment">//存放数值 </span></span><br><span class="line">string string_value; <span class="comment">//存放计算器变量名 </span></span><br><span class="line"><span class="type">int</span> no_of_errors; <span class="comment">//记录错误个数 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">expr</span><span class="params">(<span class="type">bool</span> get)</span> </span>{ </span><br><span class="line">    <span class="type">double</span> left=<span class="built_in">term</span>( get); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( ; ; ) </span><br><span class="line">        <span class="keyword">switch</span>(curr_tok) { </span><br><span class="line">        <span class="keyword">case</span> PLUS: </span><br><span class="line">            left+=<span class="built_in">term</span>(ture); </span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        <span class="keyword">case</span> MINUS: </span><br><span class="line">            left-=<span class="built_in">term</span>(ture); </span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        <span class="keyword">default</span>: </span><br><span class="line">            <span class="keyword">return</span> left; </span><br><span class="line">    } </span><br><span class="line">} </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">term</span><span class="params">(<span class="type">bool</span> get)</span> </span>{ </span><br><span class="line">    <span class="type">double</span> left=<span class="built_in">prim</span>(get); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( ; ; ) </span><br><span class="line">        <span class="keyword">switch</span>(curr_tok) { </span><br><span class="line">        <span class="keyword">case</span> MUL: </span><br><span class="line">            left*=<span class="built_in">prim</span>(ture); </span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        <span class="keyword">case</span> DIV: </span><br><span class="line">            <span class="keyword">if</span>(<span class="type">double</span> d=<span class="built_in">prim</span>(ture)) { </span><br><span class="line">                left/=d; </span><br><span class="line">                <span class="keyword">break</span>; </span><br><span class="line">            } </span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">error</span>(<span class="string">"divide by 0"</span>); </span><br><span class="line">        <span class="keyword">default</span>: </span><br><span class="line">            <span class="keyword">return</span> left; </span><br><span class="line">    } </span><br><span class="line">} </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">prim</span><span class="params">(<span class="type">bool</span> get)</span> </span>{ </span><br><span class="line">    <span class="keyword">if</span>(get) <span class="built_in">get_token</span>(); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(curr_tok) { </span><br><span class="line">    <span class="keyword">case</span> NUMBER: { </span><br><span class="line">        <span class="type">double</span> v=number_value; </span><br><span class="line">        <span class="built_in">get_token</span>(); </span><br><span class="line">        <span class="keyword">return</span> v; </span><br><span class="line">                 } </span><br><span class="line">    <span class="keyword">case</span> NAME: { </span><br><span class="line">        <span class="type">double</span>&amp; v=table[string_value]; </span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">get_token</span>()==ASSIGN) </span><br><span class="line">            v=<span class="built_in">expr</span>(ture); </span><br><span class="line">        <span class="keyword">return</span> v; </span><br><span class="line">               } </span><br><span class="line">    <span class="keyword">case</span> MINUS: </span><br><span class="line">        <span class="keyword">return</span> -<span class="built_in">prim</span>(ture); </span><br><span class="line">    <span class="keyword">case</span> LP: { </span><br><span class="line">        <span class="type">double</span> e=<span class="built_in">expr</span>(ture); </span><br><span class="line">        <span class="keyword">if</span>(curr_tok!=RP) </span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">error</span>(<span class="string">") expected"</span>); </span><br><span class="line">        <span class="built_in">get_token</span>(); </span><br><span class="line">        <span class="keyword">return</span> e; </span><br><span class="line">             } </span><br><span class="line">    <span class="keyword">default</span>: </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">error</span>(<span class="string">"primary expected"</span>); </span><br><span class="line">    } </span><br><span class="line">} </span><br><span class="line"></span><br><span class="line"><span class="function">Token_value <span class="title">get_token</span><span class="params">()</span> </span>{ </span><br><span class="line">    <span class="type">char</span> ch=<span class="number">0</span>; </span><br><span class="line">    cin&gt;&gt;ch; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(ch) { </span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: </span><br><span class="line">        <span class="keyword">return</span> curr_tok=END; </span><br><span class="line">    <span class="keyword">case</span> <span class="string">';'</span>: </span><br><span class="line">    <span class="keyword">case</span> <span class="string">'*'</span>: </span><br><span class="line">    <span class="keyword">case</span> <span class="string">'/'</span>: </span><br><span class="line">    <span class="keyword">case</span> <span class="string">'+'</span>: </span><br><span class="line">    <span class="keyword">case</span> <span class="string">'('</span>: </span><br><span class="line">    <span class="keyword">case</span> <span class="string">')'</span>: </span><br><span class="line">    <span class="keyword">case</span> <span class="string">'='</span>: </span><br><span class="line">        <span class="keyword">return</span> curr_tok=<span class="built_in">Token_value</span>(ch); </span><br><span class="line">    <span class="keyword">case</span> <span class="string">'0'</span>: </span><br><span class="line">    <span class="keyword">case</span> <span class="string">'1'</span>: </span><br><span class="line">    <span class="keyword">case</span> <span class="string">'2'</span>: </span><br><span class="line">    <span class="keyword">case</span> <span class="string">'3'</span>: </span><br><span class="line">    <span class="keyword">case</span> <span class="string">'4'</span>: </span><br><span class="line">    <span class="keyword">case</span> <span class="string">'5'</span>: </span><br><span class="line">    <span class="keyword">case</span> <span class="string">'6'</span>: </span><br><span class="line">    <span class="keyword">case</span> <span class="string">'7'</span>: </span><br><span class="line">    <span class="keyword">case</span> <span class="string">'8'</span>: </span><br><span class="line">    <span class="keyword">case</span> <span class="string">'9'</span>: </span><br><span class="line">    <span class="keyword">case</span> <span class="string">'.'</span>: </span><br><span class="line">        cin.<span class="built_in">putback</span>(ch); </span><br><span class="line">        cin&gt;&gt;number_value; </span><br><span class="line">        <span class="keyword">return</span> curr_tok=NUMBER; </span><br><span class="line">    <span class="keyword">default</span>: </span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isalpha</span>(ch)) { </span><br><span class="line">            cin.<span class="built_in">putback</span>(ch); </span><br><span class="line">            cin&gt;&gt;string_value; </span><br><span class="line">            <span class="keyword">return</span> curr_tok=NAME; </span><br><span class="line">        } </span><br><span class="line">        <span class="built_in">error</span>(<span class="string">"bad token"</span>); </span><br><span class="line">        <span class="keyword">return</span> curr_tok=PRINT; </span><br><span class="line">    } </span><br><span class="line">} </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">error</span><span class="params">(<span class="type">const</span> string&amp; s)</span></span></span><br><span class="line"><span class="function"></span>{ </span><br><span class="line">    no_of_errors++; </span><br><span class="line">    cerr&lt;&lt;<span class="string">"error: "</span>&lt;&lt;s&lt;&lt;endl; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">} </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>{ </span><br><span class="line">    table[<span class="string">"pi"</span>]=<span class="number">3.1415926</span>; </span><br><span class="line">    table[<span class="string">"e"</span>]=<span class="number">2.718281828</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(cin) { </span><br><span class="line">        <span class="built_in">get_token</span>(); </span><br><span class="line">        <span class="keyword">if</span>(curr_tok==END) </span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        <span class="keyword">if</span>(curr_tok==PRINT) </span><br><span class="line">            <span class="keyword">continue</span>; </span><br><span class="line">        cout&lt;&lt;<span class="built_in">expr</span>(<span class="literal">false</span>)&lt;&lt;endl; </span><br><span class="line">    } </span><br><span class="line">    <span class="keyword">return</span> no_of_errors; </span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git Command List</title>
      <link href="/posts/5a5a.html"/>
      <url>/posts/5a5a.html</url>
      
        <content type="html"><![CDATA[<p>常用 Git 命令清单。几个专用名词的译名如下。</p><pre><code>Workspace：工作区Index / Stage：暂存区Repository：仓库区（或本地仓库）Remote：远程仓库</code></pre><h1 id="新建代码库"><a class="markdownIt-Anchor" href="#新建代码库"></a> 新建代码库</h1><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"># 在当前目录新建一个Git代码库</span><br><span class="line">$ git init</span><br><span class="line"></span><br><span class="line"># 新建一个目录，将其初始化为Git代码库</span><br><span class="line">$ git init [project-name]</span><br><span class="line"></span><br><span class="line"># 下载一个项目和它的整个代码历史</span><br><span class="line">$ git clone [url]</span><br></pre></td></tr></tbody></table></figure><h1 id="配置"><a class="markdownIt-Anchor" href="#配置"></a> 配置</h1><p>Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"># 显示当前的Git配置</span><br><span class="line">$ git config --list</span><br><span class="line"></span><br><span class="line"># 编辑Git配置文件</span><br><span class="line">$ git config -e [--global]</span><br><span class="line"></span><br><span class="line"># 设置提交代码时的用户信息</span><br><span class="line">$ git config [--global] user.name "[name]"</span><br><span class="line">$ git config [--global] user.email "[email address]"</span><br></pre></td></tr></tbody></table></figure><h1 id="增加删除文件"><a class="markdownIt-Anchor" href="#增加删除文件"></a> 增加/删除文件</h1><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"># 添加指定文件到暂存区</span><br><span class="line">$ git add [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"># 添加指定目录到暂存区，包括子目录</span><br><span class="line">$ git add [dir]</span><br><span class="line"></span><br><span class="line"># 添加当前目录的所有文件到暂存区</span><br><span class="line">$ git add .</span><br><span class="line"></span><br><span class="line"># 添加每个变化前，都会要求确认</span><br><span class="line"># 对于同一个文件的多处变化，可以实现分次提交</span><br><span class="line">$ git add -p</span><br><span class="line"></span><br><span class="line"># 删除工作区文件，并且将这次删除放入暂存区</span><br><span class="line">$ git rm [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"># 停止追踪指定文件，但该文件会保留在工作区</span><br><span class="line">$ git rm --cached [file]</span><br><span class="line"></span><br><span class="line"># 改名文件，并且将这个改名放入暂存区</span><br><span class="line">$ git mv [file-original] [file-renamed]</span><br></pre></td></tr></tbody></table></figure><h1 id="代码提交"><a class="markdownIt-Anchor" href="#代码提交"></a> 代码提交</h1><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"># 提交暂存区到仓库区</span><br><span class="line">$ git commit -m [message]</span><br><span class="line"></span><br><span class="line"># 提交暂存区的指定文件到仓库区</span><br><span class="line">$ git commit [file1] [file2] ... -m [message]</span><br><span class="line"></span><br><span class="line"># 提交工作区自上次commit之后的变化，直接到仓库区</span><br><span class="line">$ git commit -a</span><br><span class="line"></span><br><span class="line"># 提交时显示所有diff信息</span><br><span class="line">$ git commit -v</span><br><span class="line"></span><br><span class="line"># 使用一次新的commit，替代上一次提交</span><br><span class="line"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span><br><span class="line">$ git commit --amend -m [message]</span><br><span class="line"></span><br><span class="line"># 重做上一次commit，并包括指定文件的新变化</span><br><span class="line">$ git commit --amend [file1] [file2] ...</span><br></pre></td></tr></tbody></table></figure><h1 id="分支"><a class="markdownIt-Anchor" href="#分支"></a> 分支</h1><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"># 列出所有本地分支</span><br><span class="line">$ git branch</span><br><span class="line"></span><br><span class="line"># 列出所有远程分支</span><br><span class="line">$ git branch -r</span><br><span class="line"></span><br><span class="line"># 列出所有本地分支和远程分支</span><br><span class="line">$ git branch -a</span><br><span class="line"></span><br><span class="line"># 新建一个分支，但依然停留在当前分支</span><br><span class="line">$ git branch [branch-name]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，并切换到该分支</span><br><span class="line">$ git checkout -b [branch]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，指向指定commit</span><br><span class="line">$ git branch [branch] [commit]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，与指定的远程分支建立追踪关系</span><br><span class="line">$ git branch --track [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"># 切换到指定分支，并更新工作区</span><br><span class="line">$ git checkout [branch-name]</span><br><span class="line"></span><br><span class="line"># 切换到上一个分支</span><br><span class="line">$ git checkout -</span><br><span class="line"></span><br><span class="line"># 建立追踪关系，在现有分支与指定的远程分支之间</span><br><span class="line">$ git branch --set-upstream [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"># 合并指定分支到当前分支</span><br><span class="line">$ git merge [branch]</span><br><span class="line"></span><br><span class="line"># 选择一个commit，合并进当前分支</span><br><span class="line">$ git cherry-pick [commit]</span><br><span class="line"></span><br><span class="line"># 删除分支</span><br><span class="line">$ git branch -d [branch-name]</span><br><span class="line"></span><br><span class="line"># 删除远程分支</span><br><span class="line">$ git push origin --delete [branch-name]</span><br><span class="line">$ git branch -dr [remote/branch]</span><br></pre></td></tr></tbody></table></figure><h1 id="标签"><a class="markdownIt-Anchor" href="#标签"></a> 标签</h1><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"># 列出所有tag</span><br><span class="line">$ git tag</span><br><span class="line"></span><br><span class="line"># 新建一个tag在当前commit</span><br><span class="line">$ git tag [tag]</span><br><span class="line"></span><br><span class="line"># 新建一个tag在指定commit</span><br><span class="line">$ git tag [tag] [commit]</span><br><span class="line"></span><br><span class="line"># 删除本地tag</span><br><span class="line">$ git tag -d [tag]</span><br><span class="line"></span><br><span class="line"># 删除远程tag</span><br><span class="line">$ git push origin :refs/tags/[tagName]</span><br><span class="line"></span><br><span class="line"># 查看tag信息</span><br><span class="line">$ git show [tag]</span><br><span class="line"></span><br><span class="line"># 提交指定tag</span><br><span class="line">$ git push [remote] [tag]</span><br><span class="line"></span><br><span class="line"># 提交所有tag</span><br><span class="line">$ git push [remote] --tags</span><br><span class="line"></span><br><span class="line"># 新建一个分支，指向某个tag</span><br><span class="line">$ git checkout -b [branch] [tag]</span><br></pre></td></tr></tbody></table></figure><h1 id="查看信息"><a class="markdownIt-Anchor" href="#查看信息"></a> 查看信息</h1><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"># 下载远程仓库的所有变动</span><br><span class="line">$ git fetch [remote]</span><br><span class="line"></span><br><span class="line"># 显示所有远程仓库</span><br><span class="line">$ git remote -v</span><br><span class="line"></span><br><span class="line"># 显示某个远程仓库的信息</span><br><span class="line">$ git remote show [remote]</span><br><span class="line"></span><br><span class="line"># 增加一个新的远程仓库，并命名</span><br><span class="line">$ git remote add [shortname] [url]</span><br><span class="line"></span><br><span class="line"># 取回远程仓库的变化，并与本地分支合并</span><br><span class="line">$ git pull [remote] [branch]</span><br><span class="line"></span><br><span class="line"># 上传本地指定分支到远程仓库</span><br><span class="line">$ git push [remote] [branch]</span><br><span class="line"></span><br><span class="line"># 强行推送当前分支到远程仓库，即使有冲突</span><br><span class="line">$ git push [remote] --force</span><br><span class="line"></span><br><span class="line"># 推送所有分支到远程仓库</span><br><span class="line">$ git push [remote] --all</span><br></pre></td></tr></tbody></table></figure><h1 id="撤销"><a class="markdownIt-Anchor" href="#撤销"></a> 撤销</h1><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 恢复暂存区的指定文件到工作区</span><br><span class="line">$ git checkout [file]</span><br><span class="line"></span><br><span class="line"># 恢复某个commit的指定文件到暂存区和工作区</span><br><span class="line">$ git checkout [commit] [file]</span><br><span class="line"></span><br><span class="line"># 恢复暂存区的所有文件到工作区</span><br><span class="line">$ git checkout .</span><br><span class="line"></span><br><span class="line"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span><br><span class="line">$ git reset [file]</span><br><span class="line"></span><br><span class="line"># 重置暂存区与工作区，与上一次commit保持一致</span><br><span class="line">$ git reset --hard</span><br><span class="line"></span><br><span class="line"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span><br><span class="line">$ git reset [commit]</span><br><span class="line"></span><br><span class="line"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span><br><span class="line">$ git reset --hard [commit]</span><br><span class="line"></span><br><span class="line"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span><br><span class="line">$ git reset --keep [commit]</span><br><span class="line"></span><br><span class="line"># 新建一个commit，用来撤销指定commit</span><br><span class="line"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span><br><span class="line">$ git revert [commit]</span><br><span class="line"></span><br><span class="line"># 暂时将未提交的变化移除，稍后再移入</span><br><span class="line">$ git stash</span><br><span class="line">$ git stash pop</span><br></pre></td></tr></tbody></table></figure><h1 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h1><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 生成一个可供发布的压缩包</span><br><span class="line">$ git archive</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> get </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单链表的反转</title>
      <link href="/posts/f962.html"/>
      <url>/posts/f962.html</url>
      
        <content type="html"><![CDATA[<p>反转链表：将链表整体“反过来”，将头变成尾、尾变成头。</p><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20201025144559.png" alt="反转的链表"></p><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20201025144605.png" alt="反转后的链表"></p><p>常见的四种方法:</p><ol><li><p>迭代反转法</p></li><li><p>递归反转法</p></li><li><p>就地逆置法</p></li><li><p>头插法</p></li></ol><p>递归反转法更适用于反转不带头节点的链表；其它 3 种方法既能反转不带头节点的链表，也能反转带头节点的链表。</p><h1 id="迭代反转链表"><a class="markdownIt-Anchor" href="#迭代反转链表"></a> 迭代反转链表</h1><p>方法：从当前链表的首元节点开始，一直遍历至链表的最后一个节点，这期间会逐个改变所遍历到的节点的指针域，另其指向前一个节点。</p><p>具体实现：借助 3 个指针即可。首先我们定义 3 个指针并分别命名为 beg、mid、end。它们的初始指向如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20201025145917.png" alt=""></p><p>在上图的基础上，遍历链表的过程就等价为：3 个指针每次各向后移动一个节点，直至 mid 指向链表中最后一个节点（此时 end 为 NULL ）。需要注意的是，这 3 个指针每移动之前，都需要做一步操作，即改变 mid 所指节点的指针域，另其指向和 beg 相同。</p><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20201025150330.png" alt=""></p><ol><li><p>3 个指针每次各向后移动一个节点（end 不为 NULL）</p></li><li><p>改变 head 头指针的指向，另其和 mid 同向（end 为 NULL）</p></li></ol><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//迭代反转法，head 为无头节点链表的头指针</span></span><br><span class="line">link * <span class="title function_">iteration_reverse</span><span class="params">(link* head)</span> {</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        link * beg = <span class="literal">NULL</span>;</span><br><span class="line">        link * mid = head;</span><br><span class="line">        link * end = head-&gt;next;</span><br><span class="line">        <span class="comment">//一直遍历</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">//修改 mid 所指节点的指向</span></span><br><span class="line">            mid-&gt;next = beg;</span><br><span class="line">            <span class="comment">//此时判断 end 是否为 NULL，如果成立则退出循环</span></span><br><span class="line">            <span class="keyword">if</span> (end == <span class="literal">NULL</span>) {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//整体向后移动 3 个指针</span></span><br><span class="line">            beg = mid;</span><br><span class="line">            mid = end;</span><br><span class="line">            end = end-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//最后修改 head 头指针的指向</span></span><br><span class="line">        head = mid;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="递归反转链表"><a class="markdownIt-Anchor" href="#递归反转链表"></a> 递归反转链表</h1><p>方法：从链表的尾节点开始，依次向前遍历，遍历过程依次改变各节点的指向，即另其指向前一个节点。</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">link* <span class="title function_">recursive_reverse</span><span class="params">(link* head)</span> {</span><br><span class="line">    <span class="comment">//递归的出口</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)     <span class="comment">// 空链或只有一个结点，直接返回头指针</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">//一直递归，找到链表中最后一个节点</span></span><br><span class="line"></span><br><span class="line">        link *new_head = recursive_reverse(head-&gt;next);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当逐层退出时，new_head 的指向都不变，一直指向原链表中最后一个节点；</span></span><br><span class="line">        <span class="comment">//递归每退出一层，函数中 head 指针的指向都会发生改变，都指向上一个节点。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//每退出一层，都需要改变 head-&gt;next 节点指针域的指向，同时令 head 所指节点的指针域为 NULL。</span></span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//每一层递归结束，都要将新的头指针返回给上一层。由此，即可保证整个递归过程中，能够一直找得到新链表的表头。</span></span><br><span class="line">        <span class="keyword">return</span> new_head;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol><li>由于 head 不为 NULL，因此函数每执行到第 11 行时，递归都会深入一层，并依次将指向节点 2、3、4 的指针作为实参（head_next 的指向）参与递归。而根据递归出口的判断条件，当函数参数 head 指向的是节点 4 时满足 head-&gt;next == NULL，递归过程不再深入，并返回指向节点 4 的指针，这就是反转链表的新头指针。</li></ol><p>因此，当递归首次退出一层时，new_head 指向的是节点 4 ，而 head 由于退出一层，指向的是节点 3，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20201025153138.png" alt=""></p><ol start="2"><li>在此基础上，开始执行 17、18 行代码，整个操作过程如下图所示，最后将 new_head 的指向继续作为函数的返回值，传给上一层的 new_head。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20201025153208.png" alt=""></p><ol start="3"><li>再退一层，此时 new_head 仍指向节点 4，而 head 退出一层后，指向的是节点 2。在此基础上执行 17、18 行代码，并最终将 new_head 的指向作为函数返回值，继续传给上一层的 new_head。整个操作过程如下图所示：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20201025153247.png" alt=""></p><ol start="4"><li>再退一层，此时 new_head 仍指向节点 4，而 head 退出一层后，指向的是节点 1。在此基础上执行 17、18 行代码，并返回 new_head。整个操作过程如下图所示：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20201025153329.png" alt=""></p><p>head 由节点 1 进入递归，此时 head 的指向又返回到节点 1，整个递归过程结束。显然，以上过程已经实现了链表的反转，新反转链表的头指针为 new_head。</p><h1 id="头插法反转链表"><a class="markdownIt-Anchor" href="#头插法反转链表"></a> 头插法反转链表</h1><p>方法：在原有链表的基础上，依次将位于链表头部的节点摘下，然后采用从头部插入的方式生成一个新链表，则此链表即为原链表的反转版。</p><p>步骤：</p><ol><li>创建一个新的空链表</li></ol><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20201025154153.png" alt=""></p><ol start="2"><li>从原链表中摘除头部节点 i（i &lt; N），并以头部插入的方式将该节点添加到新链表中</li></ol><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20201025154220.png" alt=""></p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">link * <span class="title function_">head_reverse</span><span class="params">(link * head)</span> {</span><br><span class="line">    link * new_head = <span class="literal">NULL</span>;</span><br><span class="line">    link * temp = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        temp = head;</span><br><span class="line">        <span class="comment">//将 temp 从 head 中摘除</span></span><br><span class="line">        head = head-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将 temp 插入到 new_head 的头部</span></span><br><span class="line">        temp-&gt;next = new_head;</span><br><span class="line">        new_head = temp;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> new_head;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="就地逆置法反转链表"><a class="markdownIt-Anchor" href="#就地逆置法反转链表"></a> 就地逆置法反转链表</h1><p>方法：就地逆置法和头插法的实现思想类似，唯一的区别在于，头插法是通过建立一个新链表实现的，而就地逆置法则是直接对原链表做修改，从而实现将原链表反转。</p><p>在原链表的基础上做修改，需要额外借助 2 个指针（假设分别为 beg 和 end）</p><p>步骤：</p><ol><li>初始状态下，令 beg 指向第一个节点，end 指向 beg-&gt;next，如下图所示：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20201025155134.png" alt=""></p><ol start="2"><li>将 end 所指节点 2 从链表上摘除，然后再添加至当前链表的头部。如下图所示：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20201025155238.png" alt=""></p><ol start="3"><li>将 end 指向 beg-&gt;next，然后将 end 所指节点 3 从链表摘除，再添加到当前链表的头部，如下图所示：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20201025155238.png" alt=""></p><ol start="4"><li>将 end 指向 beg-&gt;next，再将 end 所示节点 4 从链表摘除，并添加到当前链表的头部，如下图所示：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20201025155352.png" alt=""></p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">link * <span class="title function_">local_reverse</span><span class="params">(link * head)</span> {</span><br><span class="line">    link * beg = <span class="literal">NULL</span>;</span><br><span class="line">    link * end = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    }</span><br><span class="line">    beg = head;</span><br><span class="line">    end = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (end != <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="comment">//将 end 从链表中摘除</span></span><br><span class="line">        beg-&gt;next = end-&gt;next;</span><br><span class="line">        <span class="comment">//将 end 移动至链表头</span></span><br><span class="line">        end-&gt;next = head;</span><br><span class="line">        head = end;</span><br><span class="line">        <span class="comment">//调整 end 的指向，另其指向 beg 后的一个节点，为反转下一个节点做准备</span></span><br><span class="line">        end = beg-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性表</title>
      <link href="/posts/82e6.html"/>
      <url>/posts/82e6.html</url>
      
        <content type="html"><![CDATA[<h1 id="顺序表"><a class="markdownIt-Anchor" href="#顺序表"></a> 顺序表</h1><h2 id="顺序表初始化"><a class="markdownIt-Anchor" href="#顺序表初始化"></a> 顺序表初始化</h2><p><strong>定义数据表</strong></p><ul><li><p>顺序表申请的存储容量；</p></li><li><p>顺序表的长度，也就是表中存储数据元素的个数；</p></li></ul><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Table</span>{</span></span><br><span class="line">    <span class="type">int</span> * head;<span class="comment">//声明了一个名为head的长度不确定的数组，也叫“动态数组”</span></span><br><span class="line">    <span class="type">int</span> length;<span class="comment">//记录当前顺序表的长度</span></span><br><span class="line">    <span class="type">int</span> size;<span class="comment">//记录顺序表分配的存储容量</span></span><br><span class="line">}table;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>注意：head 是我们声明的一个未初始化的动态数组，不要只把它看做是普通的指针。</p><p><strong>数据表的初始化</strong></p><ul><li><p>给 head 动态数据申请足够大小的物理空间；</p></li><li><p>给 size 和 length 赋初值；</p></li></ul><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Size 5 <span class="comment">//对Size进行宏定义，表示顺序表申请空间的大小</span></span></span><br><span class="line">table <span class="title function_">initTable</span><span class="params">()</span>{</span><br><span class="line">    table t;</span><br><span class="line">    t.head=(<span class="type">int</span>*)<span class="built_in">malloc</span>(Size*<span class="keyword">sizeof</span>(<span class="type">int</span>));<span class="comment">//构造一个空的顺序表，动态申请存储空间</span></span><br><span class="line">    <span class="keyword">if</span> (!t.head) <span class="comment">//如果申请失败，作出提示并直接退出程序</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"初始化失败"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">    t.length=<span class="number">0</span>;<span class="comment">//空表的长度初始化为0</span></span><br><span class="line">    t.size=Size;<span class="comment">//空表的初始存储空间为Size</span></span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>顺序表初始化的过程被封装到了一个函数中，此函数返回值是一个已经初始化完成的顺序表。这样做的好处是增加了代码的可用性，也更加美观。</p><h2 id="顺序表的基本操作"><a class="markdownIt-Anchor" href="#顺序表的基本操作"></a> 顺序表的基本操作</h2><p><strong>顺序表插入元素</strong></p><p>向已有顺序表中插入数据元素，根据插入位置的不同，可分为以下 3 种情况：</p><ol><li><p>插入到顺序表的表头；</p></li><li><p>在表的中间位置插入元素；</p></li><li><p>尾随顺序表中已有元素，作为顺序表中的最后一个元素；</p></li></ol><p>插入的步骤：</p><ol><li><p>将要插入位置元素以及后续的元素整体向后移动一个位置；</p></li><li><p>将元素放到腾出来的位置上；</p></li></ol><p>顺序表插入数据元素的 C 语言实现代码如下：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//插入函数，其中，elem为插入的元素，add为插入到顺序表的位置</span></span><br><span class="line">table <span class="title function_">addTable</span><span class="params">(table t,<span class="type">int</span> elem,<span class="type">int</span> add)</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">//判断插入本身是否存在问题（如果插入元素位置比整张表的长度+1还大（如果相等，是尾随的情况），或者插入的位置本身不存在，程序作为提示并自动退出）</span></span><br><span class="line">    <span class="keyword">if</span> (add&gt;t.length+<span class="number">1</span>||add&lt;<span class="number">1</span>) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"插入位置有问题\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//做插入操作时，首先需要看顺序表是否有多余的存储空间提供给插入的元素，如果没有，需要申请</span></span><br><span class="line">    <span class="keyword">if</span> (t.length==t.size) {</span><br><span class="line">        t.head=(<span class="type">int</span> *)<span class="built_in">realloc</span>(t.head, (t.size+<span class="number">1</span>)*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        <span class="keyword">if</span> (!t.head) {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"存储分配失败\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        }</span><br><span class="line">        t.size+=<span class="number">1</span>;</span><br><span class="line">    } </span><br><span class="line">    <span class="comment">//插入操作，需要将从插入位置开始的后续元素，逐个后移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=t.length<span class="number">-1</span>; i&gt;=add<span class="number">-1</span>; i--) {</span><br><span class="line">        t.head[i+<span class="number">1</span>]=t.head[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//后移完成后，直接将所需插入元素，添加到顺序表的相应位置</span></span><br><span class="line">    t.head[add<span class="number">-1</span>]=elem;</span><br><span class="line">    <span class="comment">//由于添加了元素，所以长度+1</span></span><br><span class="line">    t.length++;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>注意，动态数组额外申请更多物理空间使用的是 realloc 函数。并且，在实现后续元素整体后移的过程，目标位置其实是有数据的，还是 3，只是下一步新插入元素时会把旧元素直接覆盖。</p><p><strong>顺序表删除元素</strong></p><p>删除的步骤：</p><p>找到目标元素，并将其后续所有元素整体前移 1 个位置即可。</p><p>顺序表删除元素的 C 语言实现代码为：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">table <span class="title function_">delTable</span><span class="params">(table t,<span class="type">int</span> add)</span>{</span><br><span class="line">    <span class="keyword">if</span> (add&gt;t.length || add&lt;<span class="number">1</span>) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"被删除元素的位置有误\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//删除操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=add; i&lt;t.length; i++) {</span><br><span class="line"></span><br><span class="line">        t.head[i<span class="number">-1</span>]=t.head[i];</span><br><span class="line">    }</span><br><span class="line">    t.length--;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><strong>顺序表查找元素</strong></p><p>方法：顺序查找法</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//查找函数，其中，elem表示要查找的数据元素的值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">selectTable</span><span class="params">(table t,<span class="type">int</span> elem)</span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;t.length; i++) {</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (t.head[i]==elem) {</span><br><span class="line">            <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//如果查找失败，返回-1</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>顺序表更改元素</strong></p><p>顺序表更改元素的步骤是：</p><ol><li><p>找到目标元素；</p></li><li><p>直接修改该元素的值；</p></li></ol><p>顺序表更改元素的 C 语言实现代码为：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//更改函数，其中，elem为要更改的元素，newElem为新的数据元素</span></span><br><span class="line">table <span class="title function_">amendTable</span><span class="params">(table t,<span class="type">int</span> elem,<span class="type">int</span> newElem)</span>{</span><br><span class="line">    <span class="type">int</span> add=selectTable(t, elem);</span><br><span class="line">    t.head[add<span class="number">-1</span>]=newElem;<span class="comment">//由于返回的是元素在顺序表中的位置，所以-1就是该元素在数组中的下标</span></span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="链表"><a class="markdownIt-Anchor" href="#链表"></a> 链表</h1><p>与顺序表不同，链表不限制数据的物理存储状态，换句话说，使用链表存储的数据元素，其物理存储位置是随机的。</p><p>链式存储结构：数据元素随机存储，并通过指针表示数据之间逻辑关系的存储结构</p><h2 id="链表的节点"><a class="markdownIt-Anchor" href="#链表的节点"></a> 链表的节点</h2><table><thead><tr><th style="text-align:center">data</th><th style="text-align:center">point</th></tr></thead><tbody><tr><td style="text-align:center">数据域</td><td style="text-align:center">指针域</td></tr></tbody></table><ol><li><p>数据元素本身，其所在的区域称为数据域；</p></li><li><p>指向直接后继元素的指针，所在的区域称为指针域；</p></li></ol><p>链表中每个节点的具体实现，需要使用 C 语言中的结构体，具体实现代码为：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Link</span>{</span></span><br><span class="line">    <span class="type">char</span> elem; <span class="comment">//代表数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Link</span> * <span class="title">next</span>;</span> <span class="comment">//代表指针域，指向直接后继元素</span></span><br><span class="line">}link; <span class="comment">//link为节点名，每个节点都是一个 link 结构体</span></span><br></pre></td></tr></tbody></table></figure><p><strong>头节点，头指针和首元节点</strong></p><p>一个完整的链表需要由以下几部分构成：</p><p>1.头指针：一个普通的指针，它的特点是永远指向链表第一个节点的位置。很明显，头指针用于指明链表的位置，便于后期找到链表并使用表中的数据；</p><ol><li>节点：链表中的节点又细分为头节点、首元节点和其他节点：</li></ol><ul><li><p>头节点：其实就是一个不存任何数据的空节点，通常作为链表的第一个节点。对于链表来说，头节点不是必须的，它的作用只是为了方便解决某些实际问题；</p></li><li><p>首元节点：由于头节点（也就是空节点）的缘故，链表中称第一个存有数据的节点为首元节点。首元节点只是对链表中第一个存有数据节点的一个称谓，没有实际意义；</p></li><li><p>其他节点：链表中其他的节点；</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20201025115428.png" alt=""></p><p>##　链表的创建（初始化）</p><p>创建链表的步骤是：</p><ol><li><p>声明一个头指针（如果有必要，可以声明一个头节点）；</p></li><li><p>创建多个存储数据的节点，在创建的过程中，要随时与其前驱节点建立逻辑关系；</p></li></ol><p>例如</p><p>创建一个存储 {1,2,3,4} 且无头节点的链表，C 语言实现代码如下：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">link * <span class="title function_">initLink</span><span class="params">()</span>{</span><br><span class="line">    link * p=<span class="literal">NULL</span>;<span class="comment">//创建头指针</span></span><br><span class="line">    link * temp = (link*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(link));<span class="comment">//创建首元节点</span></span><br><span class="line">    <span class="comment">//首元节点先初始化</span></span><br><span class="line">    temp-&gt;elem = <span class="number">1</span>;</span><br><span class="line">    temp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    p = temp;<span class="comment">//头指针指向首元节点</span></span><br><span class="line">    <span class="comment">//从第二个节点开始创建</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>; i&lt;<span class="number">5</span>; i++) {</span><br><span class="line">     <span class="comment">//创建一个新节点并初始化</span></span><br><span class="line">        link *a=(link*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(link));</span><br><span class="line">        a-&gt;elem=i;</span><br><span class="line">        a-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//将temp节点与新建立的a节点建立逻辑关系</span></span><br><span class="line">        temp-&gt;next=a;</span><br><span class="line">        <span class="comment">//指针temp每次都指向新链表的最后一个节点，其实就是 a节点，这里写temp=a也对</span></span><br><span class="line">        temp=temp-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//返回建立的节点，只返回头指针 p即可，通过头指针即可找到整个链表</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>创建一个存储 {1,2,3,4} 且含头节点的链表，则 C 语言实现代码为：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">link * <span class="title function_">initLink</span><span class="params">()</span>{</span><br><span class="line">    link * p=(link*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(link));<span class="comment">//创建一个头结点</span></span><br><span class="line">    link * temp=p;<span class="comment">//声明一个指针指向头结点，</span></span><br><span class="line">    <span class="comment">//生成链表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;<span class="number">5</span>; i++) {</span><br><span class="line">        link *a=(link*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(link));</span><br><span class="line">        a-&gt;elem=i;</span><br><span class="line">        a-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">        temp-&gt;next=a;</span><br><span class="line">        temp=temp-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="链表的基本操作"><a class="markdownIt-Anchor" href="#链表的基本操作"></a> 链表的基本操作</h2><p><strong>链表插入元素</strong></p><p>向链表中增添元素，根据添加位置不同，可分为以下 3 种情况：</p><ul><li><p>插入到链表的头部（头节点之后），作为首元节点；</p></li><li><p>插入到链表中间的某个位置；</p></li><li><p>插入到链表的最末端，作为链表中最后一个数据元素；</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20201025140149.png" alt=""></p><p>链表插入元素的步骤：</p><ol><li><p>将新结点的 next 指针指向插入位置后的结点；</p></li><li><p>将插入位置前结点的 next 指针指向插入结点；</p></li></ol><p>注意：链表插入元素的操作必须是先步骤 1，再步骤 2；反之，若先执行步骤 2，除非再添加一个指针，作为插入位置后续链表的头指针，否则会导致插入位置后的这部分链表丢失，无法再实现步骤 1。</p><p>实现链表插入元素的操作：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//p为原链表，elem表示新数据元素，add表示新元素要插入的位置</span></span><br><span class="line">link * <span class="title function_">insertElem</span><span class="params">(link * p, <span class="type">int</span> elem, <span class="type">int</span> add)</span> {</span><br><span class="line">    link * temp = p;<span class="comment">//创建临时结点temp</span></span><br><span class="line">    <span class="comment">//首先找到要插入位置的上一个结点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; add; i++) {</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="literal">NULL</span>) {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"插入位置无效\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//创建插入结点c</span></span><br><span class="line">    link * c = (link*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(link));</span><br><span class="line">    c-&gt;elem = elem;</span><br><span class="line">    <span class="comment">//向链表中插入结点</span></span><br><span class="line">    c-&gt;next = temp-&gt;next;</span><br><span class="line">    temp-&gt;next = c;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><strong>链表删除元素</strong></p><p>链表删除元素的步骤：</p><ol><li>将结点从链表中摘下来;</li></ol><p>2.手动释放掉结点，回收被结点占用的存储空间;</p><p>链表删除元素的的操作：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">link * delElem(link * p, int add) {</span><br><span class="line">    link * temp = p;</span><br><span class="line">    //遍历到被删除结点的上一个结点</span><br><span class="line">    for (int i = 1; i &lt; add; i++) {</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">        if (temp-&gt;next == NULL) {</span><br><span class="line">            printf("没有该结点\n");</span><br><span class="line">            return p;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    link * del = temp-&gt;next;//单独设置一个指针指向被删除结点，以防丢失</span><br><span class="line">    temp-&gt;next = temp-&gt;next-&gt;next;//删除某个结点的方法就是更改前一个结点的指针域</span><br><span class="line">    free(del);//手动释放该结点，防止内存泄漏</span><br><span class="line">    return p;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>链表查找元素</strong></p><p>步骤：从表头依次遍历表中节点，用被查找元素与各节点数据域中存储的数据元素进行比对，直至比对成功或遍历至链表最末端的 <code>NULL</code>（比对失败的标志）。</p><p>链表中查找特定数据元素的操作：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//p为原链表，elem表示被查找元素、</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">selectElem</span><span class="params">(link * p,<span class="type">int</span> elem)</span>{</span><br><span class="line"><span class="comment">//新建一个指针t，初始化为头指针 p</span></span><br><span class="line">    link * t=p;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//由于头节点的存在，因此while中的判断为t-&gt;next</span></span><br><span class="line">    <span class="keyword">while</span> (t-&gt;next) {</span><br><span class="line">        t=t-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (t-&gt;elem==elem) {</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        }</span><br><span class="line">        i++;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//程序执行至此处，表示查找失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>注意，遍历有头节点的链表时，需避免头节点对测试数据的影响，因此在遍历链表时，建立使用上面代码中的遍历方法，直接越过头节点对链表进行有效遍历。</p><p><strong>链表更新元素</strong></p><p>步骤：通过遍历找到存储此元素的节点，对节点中的数据域做更改操作即可。</p><p>链表中更新数据元素的操作</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//更新函数，其中，add 表示更改结点在链表中的位置，newElem 为新的数据域的值</span></span><br><span class="line">link *<span class="title function_">amendElem</span><span class="params">(link * p,<span class="type">int</span> add,<span class="type">int</span> newElem)</span>{</span><br><span class="line">    link * temp=p;</span><br><span class="line">    temp=temp-&gt;next;<span class="comment">//在遍历之前，temp指向首元结点</span></span><br><span class="line">    <span class="comment">//遍历到待更新结点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;add; i++) {</span><br><span class="line">        temp=temp-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    temp-&gt;elem=newElem;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="静态链表"><a class="markdownIt-Anchor" href="#静态链表"></a> 静态链表</h2><p>静态链表：兼顾了顺序表和链表的优点于一身，可以看做是顺序表和链表的升级版。</p><p>使用静态链表存储数据，数据全部存储在数组中（和顺序表一样），但存储位置是随机的，数据之间"一对一"的逻辑关系通过一个整形变量（称为"游标"，和指针功能类似）维持（和链表类似）。</p><p><strong>静态链表中的节点</strong></p><p>静态链表存储数据元素也需要自定义数据类型，至少需要包含以下 2 部分信息：</p><ul><li>数据域：用于存储数据元素的值；</li><li>其实就是数组下标，表示直接后继元素所在数组中的位置；</li></ul><p>静态链表中节点的构成用 C 语言实现为：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    <span class="type">int</span> data;<span class="comment">//数据域</span></span><br><span class="line">    <span class="type">int</span> cur;<span class="comment">//游标</span></span><br><span class="line">}component;</span><br></pre></td></tr></tbody></table></figure><p><strong>备用链表</strong></p><p>备用链表：静态链表中，除了数据本身通过游标组成的链表外，还需要有一条连接各个空闲位置的链表，称为备用链表。</p><p>备用链表的作用是回收数组中未使用或之前使用过（目前未使用）的存储空间，留待后期使用。也就是说，静态链表使用数组申请的物理空间中，存有两个链表，一条连接数据，另一条连接数组中未使用的空间。</p><pre><code>通常，备用链表的表头位于数组下标为 0（a[0]） 的位置，而数据链表的表头位于数组下标为 1（a[1]）的位置。</code></pre><p>静态链表中设置备用链表的好处是，可以清楚地知道数组中是否有空闲位置，以便数据链表添加新数据时使用。比如，若静态链表中数组下标为 0 的位置上存有数据，则证明数组已满。</p><p><strong>静态链表的创建</strong></p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>y</mi><mrow><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></msup><mo>=</mo><mrow><mo stretchy="false">(</mo><mo>−</mo><mn>1</mn><msup><mo stretchy="false">)</mo><mi>n</mi></msup></mrow><mfrac><mn>1</mn><mn>3</mn></mfrac><mi>n</mi><mo stretchy="false">!</mo><mo stretchy="false">[</mo><mrow><mo stretchy="false">(</mo><mfrac><mn>1</mn><mrow><mi>x</mi><mo>−</mo><mn>4</mn></mrow></mfrac><msup><mo stretchy="false">)</mo><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup></mrow><mo>−</mo><mrow><mo stretchy="false">(</mo><mfrac><mn>1</mn><mrow><mi>x</mi><mo>−</mo><mn>1</mn></mrow></mfrac><msup><mo stretchy="false">)</mo><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup></mrow><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">{y^{(n)}} = {( - 1)^n}{1 \over 3}n![{({1 \over {x - 4}})^{n + 1}} - {({1 \over {x - 1}})^{n + 1}}]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.13244em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">n</span><span class="mclose mtight">)</span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.09077em;vertical-align:-0.7693300000000001em;"></span><span class="mord"><span class="mopen">(</span><span class="mord">−</span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7143919999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="mord mathdefault">n</span><span class="mclose">!</span><span class="mopen">[</span><span class="mord"><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">4</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693300000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.09077em;vertical-align:-0.7693300000000001em;"></span><span class="mord"><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693300000000001em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span><span class="mclose">]</span></span></span></span></span></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Data Structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Function call Convention</title>
      <link href="/posts/a251.html"/>
      <url>/posts/a251.html</url>
      
        <content type="html"><![CDATA[<h2 id="cdecl"><a class="markdownIt-Anchor" href="#cdecl"></a> cdecl</h2><p>cdecl是C语言中使用的调用方式，调用者负责处理栈</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> (a+b)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="built_in">main</span>(<span class="type">int</span> argc, <span class="type">char</span> *argv[]</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">add</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20201018182131.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20201018182416.png" alt=""></p><p>在调用完add() 函数之后，使用 ADD ESP,8 命令整理栈。调用者 main() 函数直接清理其压入栈的函数参数，这样的方式叫 cdecl。</p><p>cdecl 调用的优点：可以向调用函数传递长度可变的参数，这种长度可变的参数在其他调用中很难实现。</p><h2 id="stdcall"><a class="markdownIt-Anchor" href="#stdcall"></a> stdcall</h2><p>stdcll是 win32 API常用的调用方式，被调用者负责清理栈。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> _stdcall <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> (a+b)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="built_in">main</span>(<span class="type">int</span> argc, <span class="type">char</span> *argv[]</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">add</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20201018182510.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20201018182516.png" alt=""></p><p>在调用add() 函数的最后，(40100A)的 RETN 8 命令整理栈，RETN 8 的含义为RETN+POP 8 字节，即返回后使ESP增加到知指定大小。</p><p>stdcall 调用的优点：被调用者函数内部存在着栈清理代码，代码的尺寸要小，WIN 32 使用这种方式，是为了更好的兼容性。</p><h2 id="fastcall"><a class="markdownIt-Anchor" href="#fastcall"></a> fastcall</h2><p>fastcall 使用寄存器来传递给函数的参数。</p><p>fastcall 调用的优点：可以实现对函数的快速调用（调用前记得保存ECX和EDX中的重要数据）</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Reverse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stack frame</title>
      <link href="/posts/a7dd.html"/>
      <url>/posts/a7dd.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是栈帧"><a class="markdownIt-Anchor" href="#什么是栈帧"></a> 什么是栈帧</h2><p>栈帧就是利用EBP（栈帧指针，注意不是ESP）寄存器访问栈内局部变量，参数，函数返回地址的手段，在IA-32寄存器中，ESP寄存器承担着栈顶指针的作用，而EBP寄存器则负责行使栈帧指针的职能。</p><p>但是在程序运行的过程中，ESP寄存器的值随时发生变化，访问栈中函数的局部变量，参数时候，若以ESP值为基准编写程序会产生困难，并且难使CPU引用到准确的值。所以引入了栈帧。</p><p>在调用某些函数时，先要把用作基准点（函数起始地址）的ESP值保存到EBP，并维持在函数内部，这样无论ESP的值如何变化，以EBP的值作为基准（base）就能够安全访问到相关函数的局部变量，参数，返回地址。</p><h2 id="分析栈帧"><a class="markdownIt-Anchor" href="#分析栈帧"></a> 分析栈帧</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">add</span> <span class="params">(<span class="type">long</span> a, <span class="type">long</span> b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">long</span> x = a ,y = b;</span><br><span class="line">    <span class="keyword">return</span> (x + y);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">long</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="built_in">add</span>(a, b));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20201018115721.png" alt=""></p><p><strong>main() 函数产生栈帧</strong></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>*argv[])</span></span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">00401020         55                    push ebp</span><br><span class="line">00401021         8BEC                  mov ebp,esp</span><br></pre></td></tr></tbody></table></figure><p><strong>main() 函数局部变量</strong></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">long</span> a=<span class="number">1</span>, b=<span class="number">2</span>;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">00401023         83EC 08               sub esp,0x8</span><br><span class="line">00401026         C745 FC 01000000      mov dword ptr ss:[ebp-0x4],0x1</span><br><span class="line">0040102D         C745 F8 02000000      mov dword ptr ss:[ebp-0x8],0x2</span><br></pre></td></tr></tbody></table></figure><p><strong>add()函数参数传递与调用</strong></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%d/n"</span>,<span class="built_in">add</span>(a,b));</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">00401034         8B45 F8               mov eax,dword ptr ss:[ebp-0x8]</span><br><span class="line">00401037         50                    push eax</span><br><span class="line">00401038         8B4D FC               mov ecx,dword ptr ss:[ebp-0x4]</span><br><span class="line">0040103B         51                    push ecx</span><br><span class="line">0040103C         E8 BFFFFFFF           call StackFra.00401000</span><br></pre></td></tr></tbody></table></figure><p><strong>开始执行add()函数 &amp; 生成栈帧</strong></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="title">add</span><span class="params">(<span class="type">long</span> a,<span class="type">long</span> b)</span></span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">00401000         55                    push ebp</span><br><span class="line">00401001         8BEC                  mov ebp,espa</span><br></pre></td></tr></tbody></table></figure><p><strong>设置 add()函数的局部变量(x,y)</strong></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">long</span> x=a, y=b;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">00401003         83EC 08               sub esp,0x8</span><br><span class="line">00401006         8B45 08               mov eax,dword ptr ss:[ebp+0x8]   ;[ebp+8]=param a</span><br><span class="line">00401009         8945 F8               mov dword ptr ss:[ebp-0x8],eax   ;[ebp-8]=local x</span><br><span class="line">0040100C         8B4D 0C               mov ecx,dword ptr ss:[ebp+0xC]   ;[ebp-8]=local x</span><br><span class="line">0040100F         894D FC               mov dword ptr ss:[ebp-0x4],ecx   ;[ebp-4]=local y </span><br></pre></td></tr></tbody></table></figure><p><font color="red"><strong>注意</strong></font>：多个函数栈帧的生成：</p><p>主函数会参数栈帧，程序运行到其他函数的时候也会产生栈帧，栈帧生成之后 EBP 的值就会发生变化，所以每当程序运行到一个新函数的时候，EBP 都会发生变化。</p><p>主函数和其他函数中都存在局部变量，局部变量在引入的时候都要改变 栈中ESP （SS段中栈指针）的位置，为局部变量开辟内存空间。</p><p>在上述代码中，</p><p><code>main()</code> 函数的栈帧先生成（ESP-4，栈中填充EBP地址），之后为局部变量 a,b 开辟空间（ESP-4，ESP-8），此时a,b 的实际地址是 [EBP-4] 和 [EBP-8]；</p><p><code>add()</code>函数的栈帧后生成（ESP-4，栈中填充EBP地址），（此时的 EBP 已经发生变化，此时参数a,b 的实际地址是 [EBP+8] 和 [EBP+c], 多的那一部分就是进入栈的 EBP 所占据的内存单元的长度。）  之后为局部变量x,y 开辟内存空间（ESP-4，ESP-8）。此时 x,y 的实际地址是 [EBP-4] 和 [EBP-8]</p><p><strong>add运算</strong></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> (x+y)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">00401012         8B45 F8               mov eax,dword ptr ss:[ebp-0x8]   ;[ebp-8]=local x</span><br><span class="line">00401015         0345 FC               add eax,dword ptr ss:[ebp-0x4]   [ebp-4]=local y</span><br></pre></td></tr></tbody></table></figure><p><strong>删除函数add()的栈帧 &amp; 函数执行完毕（返回）</strong></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> (x+y)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">00401018         8BE5                  mov esp,ebp</span><br><span class="line">0040101A         5D                    pop ebp</span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20201018115306.png" alt=""></p><p>图中红色矩形中的命令,在地址401001处，使用 MOV EBP,ESP 命令把函数 <code>add()</code> 开始执行时候的ESP值（12FF28）备份到EBP, 函数执行完毕后，使用地址401018处的 MOV ESP,EBP命令再把存储在EBP中的值恢复到ESP中。</p><p>注意：执行完上述命令后，地址401003处的 SUB ESP,8就会失效，函数 <code>add()</code>的两个局部变量x,y ，不再有效。</p><p><strong>从栈中删除函数 add()的参数（整理栈）</strong></p><p>此时程序执行流已经回到了主函数main()</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">00401041         83C4 08               add esp,0x8</span><br></pre></td></tr></tbody></table></figure><p>上述汇编指令的目的是清除在add()函数中给局部变量a,b开辟的内存空间，将他们从栈中清理掉。（由于a,b 都是长整型，各占4个字节，一共把八个字节，所以ESP+8）</p><p><strong>调用printf() 函数</strong></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%d/n"</span>)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">00401044         50                    push eax</span><br><span class="line">00401045         68 84B34000           push StackFra.</span><br><span class="line">0040104A         E8 18000000           call StackFra.00401067</span><br><span class="line">0040104F         83C4 08               add esp,0x8</span><br></pre></td></tr></tbody></table></figure><p>printf() 函数有两个参数，大小都是八个字节，（32位寄存器+32位常量=64位=8字节），所以在40104F地址处使用ADD命令，将ESP加上8个字节，把函数的参数从栈中删除。</p><p>此时栈内地址如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">EBP-8    0012FF38      00000002</span><br><span class="line">EBP-4    0012FF3C      00000001</span><br><span class="line">EBP ==&gt;  0012FF40     /0012FF88</span><br><span class="line">EBP+4    0012FF44     |00401250  返回到 StackFra.00401250 来自 StackFra.00401020</span><br><span class="line">EBP+8    0012FF48     |00000001</span><br><span class="line">EBP+C    0012FF4C     |001E18A8  返回到 001E18A8</span><br><span class="line">EBP+10   0012FF50     |001E18F8</span><br></pre></td></tr></tbody></table></figure><p><strong>设置返回值</strong></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">00401052         33C0                  xor eax,eax</span><br></pre></td></tr></tbody></table></figure><p>汇编将数置零的操作：</p><ol><li><p>MOV EAX,0</p></li><li><p>XOR EAX,EAX  ;两个相同的值进行异或运算，，结果为零</p></li></ol><p>异或运算的执行速度较快，常用于寄存器的初始化操作。</p><p><strong>删除栈帧 &amp; main() 函数终止</strong></p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">00401054         8BE5                  mov esp,ebp</span><br><span class="line">00401056         5D                    pop ebp</span><br><span class="line">00401057         C3                    retn</span><br></pre></td></tr></tbody></table></figure><p>此时主函数执行完毕并且返回，程序执行流程跳转到地址（401250），该地址指向 Visual C++ 的启动函数区域，随后执行进程终止代码。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Reverse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IA-32 register</title>
      <link href="/posts/1a06.html"/>
      <url>/posts/1a06.html</url>
      
        <content type="html"><![CDATA[<p><strong>基本程序运行寄存器</strong></p><p>通用寄存器 （General Purpse Resigisters,32位，8个）</p><p>段寄存器 （Segment Register，16位，6个）</p><p>程序状态与控制寄存器 （Program Status and Contral Register,32位，1个）</p><p>指令指针寄存器（Instruction Pointer， 32位，1个）</p><ol><li>通用寄存器</li></ol><p>EAX:（针对操作数和结果数据的） 累加器</p><p>EBX：（DS段中的数据指针）基址寄存器</p><p>ECX：（字符串和循环操作的）计数器</p><p>EDX （I/O指针）数据寄存器</p><p>注意： Windows 汇编程序中，Windows  API 函数会在内部使用ECX和EDX，会导致这两者寄存器内的数据发生改变，为了保护数据，调用API 还函数之前要把这些数据备份到其他寄存器或栈。</p><p>EBP：（SS段中栈内数据指针）扩展基址指针寄存器</p><p>ESI：（字符串操作源指针）源变址寄存器</p><p>EDI：（字符串操作目的指针）目的变址寄存器</p><p>ESP： （SS段中栈指针） 栈指针寄存器</p><ol start="2"><li>段寄存器</li></ol><p>CS: Code Segment,代码寄存器</p><p>SS: stack Segment, 栈段寄存器</p><p>DS: Data Segment, 数据段寄存器</p><p>ES: Exera(Data), 附加（数据）寄存器</p><p>FS：Data Segment, 数据段寄存器</p><p>GS：Data Segment, 数据段寄存器</p><ol start="3"><li>程序状态寄存器</li></ol><p>EFLAGS (大小：4个字节)</p><ul><li>ZF</li></ul><p>若运算结果为0时，其值为1，否则其值为0.</p><ul><li>OF</li></ul><p>有符号整数(signed integer)溢出时，OF被置为1，此外，MSB（Most Significent Bit，最高有效位）改变时候，其值也被置为1.</p><ul><li>CF</li></ul><p>无符号整数(unsined integer) 溢出时，其值也被置为1.</p><ol start="4"><li>指令指针寄存器</li></ol><p>EIP：instruction Pointer， 指针指针寄存器</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Reverse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Reverse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git</title>
      <link href="/posts/a89f.html"/>
      <url>/posts/a89f.html</url>
      
        <content type="html"><![CDATA[<h2 id="创建版本库"><a class="markdownIt-Anchor" href="#创建版本库"></a> 创建版本库</h2><ol><li>选择一个合适的地方，创建一个空目录：</li></ol><figure class="highlight plaintext"><figcaption><span>bash</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">$ mkdir learngit</span><br><span class="line">$ cd learngit</span><br><span class="line">$ pwd</span><br><span class="line">/Users/michael/learngit</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>通过<code>git init</code>命令把这个目录变成Git可以管理的仓库：</li></ol><figure class="highlight plaintext"><figcaption><span>bash</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository in /Users/michael/learngit/.git/</span><br></pre></td></tr></tbody></table></figure><p>在文件夹目录下面会出现一个 .git 的目录，这个目录的作用是Git来跟踪版本管理库的，对于该文件夹下面的文件修改要慎重，盲目修改可能会导致版本库出现问题。<br>如果你没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见。<br>也不一定必须在空目录下创建Git仓库，选择一个已经有东西的目录也是可以的。</p><p><strong>将文件提交到仓库的步骤</strong></p><ol><li>用命令<code>git add</code>告诉Git，把文件添加到仓库：</li></ol><figure class="highlight plaintext"><figcaption><span>bash</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">$ git add readme.txt</span><br></pre></td></tr></tbody></table></figure><p>执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。</p><ol><li>用命令<code>git commit</code>告诉Git，把文件提交到仓库</li></ol><figure class="highlight plaintext"><figcaption><span>bash</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">$ git commit -m "wrote a readme file"</span><br><span class="line">[master (root-commit) eaadf4e] wrote a readme file</span><br><span class="line"> 1 file changed, 2 in</span><br><span class="line"> sertions(+)</span><br><span class="line"> create mode 100644 readme.txt</span><br></pre></td></tr></tbody></table></figure><p><code>git commit</code>命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。<br><code>git commit</code>命令执行成功后会告诉你，1 file changed：1个文件被改动（我们新添加的readme.txt文件）；2 insertions：插入了两行内容（readme.txt有两行内容）。</p><p>为什么Git添加文件需要add，commit一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如：</p><figure class="highlight plaintext"><figcaption><span>bash</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">$ git add file1.txt</span><br><span class="line">$ git add file2.txt file3.txt</span><br><span class="line">$ git commit -m "add 3 files."</span><br></pre></td></tr></tbody></table></figure><h2 id="版本回退"><a class="markdownIt-Anchor" href="#版本回退"></a> 版本回退</h2><p><code>git status</code><br>git status  命令可以让我们时刻掌握仓库当前的状态</p><figure class="highlight plaintext"><figcaption><span>bash</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use "git add &lt;file&gt;..." to update what will be committed)</span><br><span class="line">  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use "git add" and/or "git commit -a")</span><br></pre></td></tr></tbody></table></figure><p>上面的命令输出告诉我们，readme.txt被修改过了，但还没有准备提交的修改。</p><p><code>git diff</code><br><code>git diff</code>顾名思义就是查看difference，显示的格式正是Unix通用的diff格式.</p><figure class="highlight plaintext"><figcaption><span>bash</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">$ git diff readme.txt</span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">index 013b5bc..2ec0ed2 100644</span><br><span class="line">--- a/readme.txt</span><br><span class="line">+++ b/readme.txt</span><br><span class="line">@@ -1,2 +1,2 @@</span><br><span class="line">-Git is a distributed version control system.</span><br><span class="line">+Git is a perfect distributed version control system.</span><br><span class="line"> Git is free software.</span><br><span class="line">\ No newline at end of file</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>从上面的命令可以看出。我们在第一行中添加了一个单词 perfect<br>当知道了对readme.txt作了什么修改后，再把它提交到仓库就放心多了。</p><p>提交修改和提交新文件是一样的两步：<br>第一步是git add：</p><figure class="highlight plaintext"><figcaption><span>bash</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">$ git add readme.txt</span><br></pre></td></tr></tbody></table></figure><p>命令在执行之后同样没有任何提示。不过我们可以通过 <code>git status</code> 命令来了解到当前仓库的存在。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">$ git status  </span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use "git reset HEAD &lt;file&gt;..." to unstage)</span><br><span class="line"></span><br><span class="line">modified:   readme.txt</span><br></pre></td></tr></tbody></table></figure><p>提交后，我们再用git status命令看看仓库的当前状态：</p><figure class="highlight plaintext"><figcaption><span>bash</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></tbody></table></figure><p>Git告诉我们当前没有需要提交的修改，而且，工作目录是干净（working tree clean）的。</p><p><code>git log</code><br><code>git log</code>命令显示从最近到最远的提交日志，我们可以看到3次提交，最近的一次是<code>append GPL</code>，上一次是<code>add distributed</code>，最早的一次是<code>wrote a readme file</code>。<br>加上–pretty=oneline参数： 可以减少输出信息。</p><figure class="highlight plaintext"><figcaption><span>bash</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">$ git log --pretty=oneline</span><br><span class="line">d304540b814243a41ce9ce1c2ad802326dde7b7b (HEAD -&gt; master) append GPL</span><br><span class="line">ba4ce482d04b936b123b31e0152174241f53f2d5 succeed in deleting lhg.txt and t</span><br><span class="line">lhg.top.txt</span><br><span class="line">9a4d1e5895a6f8485c54bf9010f097bf7742989f add perfect distributed and delet</span><br><span class="line">e tlhg.top.txt</span><br><span class="line">94d7ce607d4e75423ab46b49ef25f495c733e898 wrote a tlhg.top file</span><br><span class="line">98cfd639681054d4a790a28b758f7c125f423a3a wrote a readme file</span><br></pre></td></tr></tbody></table></figure><p>git log 的退出方法： 输入字母Q即可退出.</p><p><code>git reset</code><br>git reset命令：把当前版本回退到上一个版本add distributed.</p><figure class="highlight plaintext"><figcaption><span>bash</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">$ git reset --hard ba4ce482d04b</span><br><span class="line">HEAD is now at ba4ce48 succeed in deleting lhg.txt and tlhg.top.txt</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><code>git reflog</code><br>Git提供了一个命令git reflog用来记录你的每一次命令：  想恢复到新版本,可以通过<code>git reflog</code> 找到新版本的commit id</p><figure class="highlight plaintext"><figcaption><span>bash</span></figcaption><table><tbody><tr><td class="code"><pre><span class="line">$  git reflog</span><br><span class="line">ba4ce48 (HEAD -&gt; master) HEAD@{0}: reset: moving to ba4ce482d04b</span><br><span class="line">d304540 HEAD@{1}: commit: append GPL</span><br><span class="line">ba4ce48 (HEAD -&gt; master) HEAD@{2}: commit: succeed in deleting lhg.txt and tlhg.top.t</span><br><span class="line">xt</span><br><span class="line">9a4d1e5 HEAD@{3}: commit: add perfect distributed and delete tlhg.top.txt</span><br><span class="line">94d7ce6 HEAD@{4}: commit: wrote a tlhg.top file</span><br><span class="line">98cfd63 HEAD@{5}: commit (initial): wrote a readme file</span><br></pre></td></tr></tbody></table></figure><p>总结：</p><p>HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令git reset --hard commit_id。</p><p>穿梭前，用git log可以查看提交历史，以便确定要回退到哪个版本。</p><p>要重返未来，用git reflog查看命令历史，以便确定要回到未来的哪个版本。</p><h2 id="工作区和暂存区"><a class="markdownIt-Anchor" href="#工作区和暂存区"></a> 工作区和暂存区</h2><p>工作区（Working Directory）<br>就是你在电脑里能看到的目录，比如我的learngit文件夹就是一个工作区：</p><p>版本库（Repository）<br>工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。</p><p>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。<br><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20201002161857" alt=""></p><p>把文件往Git版本库里添加的时候，是分两步执行的：</p><p>第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；</p><p>第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当 前分支。</p><p>因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。</p><p>现在测试一下：</p><ol><li>先对readme.txt做个修改，比如加上一行内容：</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>然后，在工作区新增一个LICENSE文本文件（内容随便写）。<br>先用git status查看一下状态：</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use "git add &lt;file&gt;..." to update what will be committed)</span><br><span class="line">  (use "git restore &lt;file&gt;..." to discard changes in working directory)</span><br><span class="line">        modified:   readme.txt</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use "git add &lt;file&gt;..." to include in what will be committed)</span><br><span class="line">        LICENSE</span><br><span class="line"></span><br><span class="line">no changes added to commit (use "git add" and/or "git commit -a")</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>Git非常清楚地告诉我们，readme.txt被修改了，而LICENSE还从来没有被添加过，所以它的状态是Untracked。</p><p>现在，使用两次命令git add，把readme.txt和LICENSE都添加后，用git status再查看一下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use "git restore --staged &lt;file&gt;..." to unstage)</span><br><span class="line">        new file:   LICENSE</span><br><span class="line">        modified:   readme.txt</span><br></pre></td></tr></tbody></table></figure><p>现在，暂存区的状态就变成这样了：<br><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20201002165019" alt=""></p><p>所以，git add命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行git commit就可以一次性把暂存区的所有修改提交到分支。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">$ git commit -m "understand how stage works"</span><br><span class="line">[master acc5181] understand how stage works</span><br><span class="line"> 2 files changed, 3 insertions(+), 1 deletion(-)</span><br><span class="line"> create mode 100644 LICENSE</span><br></pre></td></tr></tbody></table></figure><p>一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></tbody></table></figure><p>现在版本库变成了这样，暂存区就没有任何内容了：<br><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20201002165119" alt=""></p><h2 id="撤销修改"><a class="markdownIt-Anchor" href="#撤销修改"></a> 撤销修改</h2><p><code>git checkout = git switch + git restore</code></p><p><code>git checkout -- file</code> 可以撤销修改，丢弃在工作区的修存在两种情况。</p><ol><li><p>一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p></li><li><p>一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p></li></ol><p>总之，就是让这个文件回到最近一次git commit或git add时的状态。</p><p>现在举例说明上述两种情况：</p><p>第一种情况：文件修改后还没有被放到暂存区</p><p>修改过的文件(添加了最后一行)：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">$ cat readme.txt</span><br><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software distributed under the GPL.</span><br><span class="line">Git has a mutable index called stage.</span><br><span class="line">Git tracks changes of files.</span><br><span class="line">My stupid boss still prefers SVN.</span><br></pre></td></tr></tbody></table></figure><p><code>git status</code> 观察一下情况 (修改后)</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use "git add &lt;file&gt;..." to update what will be committed)</span><br><span class="line">  (use "git restore &lt;file&gt;..." to discard changes in working directory)</span><br><span class="line">        modified:   readme.txt</span><br></pre></td></tr></tbody></table></figure><p>现在让我们测试一下撤销修改的命令</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">$ git checkout -- readme.txt</span><br></pre></td></tr></tbody></table></figure><p><code>git status</code> 观察一下情况(撤销后)</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">撤销后文件内容(添加的最后一行被删除)：  </span><br></pre></td></tr></tbody></table></figure><p>$ cat readme.txt<br>Git is a distributed version control system.<br>Git is free software distributed under the GPL.<br>Git has a mutable index called stage.<br>Git tracks changes of files.</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">第一种情况：文件修改后还已经被放到暂存区  </span><br><span class="line"></span><br><span class="line">修改过的文件(添加了最后一行)：  </span><br></pre></td></tr></tbody></table></figure><p>$ cat readme.txt<br>Git is a distributed version control system.<br>Git is free software distributed under the GPL.<br>Git has a mutable index called stage.<br>Git tracks changes of files.<br>My stupid boss still prefers SVN.</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">将修改的文件提交到暂存区：  </span><br></pre></td></tr></tbody></table></figure><p>git add readme.txt</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">`git status` 查看(在 `commit` 之前)  </span><br></pre></td></tr></tbody></table></figure><p>$ git status<br>On branch master<br>Changes to be committed:<br>(use “git restore --staged <file>…” to unstage)<br>modified:   readme.txt</file></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">可以看到，修改只是提交到了暂存区，还没有提交。  </span><br><span class="line"></span><br><span class="line">现在让我们测试一下撤销修改的命令  </span><br></pre></td></tr></tbody></table></figure><p>$ git reset HEAD readme.txt<br>Unstaged changes after reset:<br>Mreadme.txt</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">`git reset`命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。  </span><br><span class="line"></span><br><span class="line">`git status` 观察一下情况(撤销后)  </span><br></pre></td></tr></tbody></table></figure><p>$ git status<br>On branch master<br>Changes not staged for commit:<br>(use “git add <file>…” to update what will be committed)<br>(use “git restore <file>…” to discard changes in working directory)<br>modified:   readme.txt</file></file></p><p>no changes added to commit (use “git add” and/or “git commit -a”)</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">现在暂存区是干净的，工作区有修改：  </span><br><span class="line"></span><br><span class="line">之后撤销工作区的修改：  </span><br></pre></td></tr></tbody></table></figure><p>$ git checkout – readme.txt</p><p>$ git status<br>On branch master<br>nothing to commit, working tree clean</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">使用`git status`查看,发现工作目录是干净的。  </span><br><span class="line"></span><br><span class="line">总结：  </span><br><span class="line">场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file。</span><br><span class="line"></span><br><span class="line">场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD &lt;file&gt;，就回到了场景1，第二步按场景1操作。</span><br><span class="line"></span><br><span class="line">场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 删除文件</span><br><span class="line"></span><br><span class="line">在Git中，删除也是一个修改操作，我们实战一下，先添加一个新文件test.txt到Git并且提交：</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>$ git commit -m “add test.txt”<br>[master 4b29612] add test.txt<br>1 file changed, 0 insertions(+), 0 deletions(-)<br>create mode 100644 test.txt</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了：</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>$ git status<br>On branch master<br>Changes not staged for commit:<br>(use “git add/rm <file>…” to update what will be committed)<br>(use “git restore <file>…” to discard changes in working directory)<br>deleted:    test.txt</file></file></p><p>no changes added to commit (use “git add” and/or “git commit -a”)</p><pre class="highlight"><code class=""></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> get </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LaTeX公式-Katex解析</title>
      <link href="/posts/6d4d.html"/>
      <url>/posts/6d4d.html</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h2><p>LaTeX是一种基于ΤΕΧ的排版系统，由美国计算机学家莱斯利·兰伯特（Leslie Lamport）在20世纪80年代初期开发，利用这种格式，即使使用者没有排版和程序设计的知识也可以充分发挥由TeX所提供的强大功能，能在几天，甚至几小时内生成很多具有书籍质量的印刷品。对于生成复杂表格和数学公式，这一点表现得尤为突出。因此它非常适用于生成高印刷质量的科技和数学类文档。</p><p>MathJax是一个显示网络上数学公式的开源JavaScript引擎库，它可以在所有浏览器上面工作，其中就支持LaTeX，MathML和AsciiMath 符号，里面的数字会被MathJax使用JavaScript引擎解析成HTML，SVG或者是MathML 方程式，然后在现代的浏览器里面显示。 它的设计目标是利用最新的web技术，构建一个支持math的web平台。支持主要的浏览器和操作系统,包括那些移动设备</p><p>KaTeX： 可汗学院出品，号称“最快”的数学公式渲染库<br>支持主流的浏览器：Chrome, Firefox, Safari, Opera和 IE8-IE11。</p><p>快速：并发渲染，无需重排页面。根据这个测试，性能绝对秒杀MathJax； +渲染效果好：采用TeX语法，渲染效果达到印刷出版级别； +无依赖：不依赖其它库； +支持服务器端渲染：例如，服务器端的Node.js程序调用KaTeX，把渲染好的HTML片段直接发送给客户端。</p><h2 id="在线测试工具"><a class="markdownIt-Anchor" href="#在线测试工具"></a> 在线测试工具</h2><p>在线测试，我们可以进行latex公式、katex效果一一对应<br><a href="http://pandao.github.io/editor.md/examples/katex.html">http://pandao.github.io/editor.md/examples/katex.html</a><br><a href="http://latex.codecogs.com/eqneditor/editor.php">http://latex.codecogs.com/eqneditor/editor.php</a><br><a href="http://latex.91maths.com/">http://latex.91maths.com/</a></p><p>latex公式<br>参考文档：<br><a href="http://www.mohu.org/info/lshort-cn.pdf">http://www.mohu.org/info/lshort-cn.pdf</a></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">空白</span><br><span class="line">1_1多个连续的空白字符等同为一个空白字符</span><br><span class="line">1_2每行开始的空白字符将被忽略</span><br><span class="line">1_3使用空行来结束段落，两行文本中的空行标志上一段落的结束和</span><br><span class="line">新段落的开始</span><br><span class="line"></span><br><span class="line">#空格</span><br><span class="line">使用\quad和\qquad 来表示空格</span><br><span class="line"></span><br><span class="line">#特殊字符</span><br><span class="line">前面需要添加\来表示特殊字符</span><br><span class="line">$ %  &amp; _ { } # ^ ~ </span><br><span class="line"></span><br><span class="line">语法对应</span><br><span class="line">\$ \%  \&amp; \_ \{ \}  \# </span><br><span class="line">\~{}  \^{}(测试有问题)</span><br><span class="line"></span><br><span class="line">#指数上下标</span><br><span class="line">指数可以用x^a 或者x^{a} 格式来表示,x代表底数，a是指数</span><br><span class="line">下标可以用x_{a}格式来表示,x代表底数,a代表下指数</span><br><span class="line">#下标</span><br><span class="line">a1(a的下标标为1)   表达式：a_{1}</span><br><span class="line"></span><br><span class="line">#指数(上标)</span><br><span class="line">x2(x的指数为2)   表达式：x^2</span><br><span class="line"></span><br><span class="line">#上下标</span><br><span class="line">b3ij(b的上标为3下标为ij)  表达式：b^{3}_{ij}</span><br><span class="line"></span><br><span class="line">#多次上标</span><br><span class="line">ex2(e的上标为x的平方)  表达式：{e^x}^2</span><br><span class="line"></span><br><span class="line">#平方根</span><br><span class="line">平方根命令为：\sqrt，n 次方根相应地为: \sqrt[n]</span><br><span class="line"></span><br><span class="line">x开根号  表达式：\sqrt{x} </span><br><span class="line">x开三次方根  表达式：\sqrt[3]{x} </span><br><span class="line">对x平方+根号y在开平方：表达式\sqrt{x^{2}+ \sqrt{y}}</span><br><span class="line"></span><br><span class="line">#分数</span><br><span class="line">分数使用\frac{a}{b} 排版,a是分子，b是分母</span><br><span class="line">例子如下：</span><br><span class="line">\frac{x^2}{k+1}</span><br><span class="line">x^{\frac{2}{k+1}}</span><br><span class="line">x^{1/2}</span><br><span class="line"></span><br><span class="line">#向量</span><br><span class="line">向量由\vec 得到。另两个命令\overrightarrow 和\overleftarrow在定义从A 到B 的向量</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#求和运算符</span><br><span class="line">求和运算符由\sum 生成</span><br><span class="line">\sum_{i=1}^{n}</span><br><span class="line"></span><br><span class="line">#数学运算符</span><br><span class="line">大于：&gt;  小于：&lt;  小于等于：\le  大于等于：\ge  不等于：\ne  双波浪线：\approx  单波浪线：\sim  子集：\subseteq  属于：\in  不属于：\notin  乘号：\times  除号：\div  加减号：\pm  右双箭头\Rightarrow 右单箭头：\rightarrow  无穷大：\infty   角度斜度\angle </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#常用小写希腊字母</span><br><span class="line">\alpha \beta \gamma \sigma \omega \delta \pi \rho \epsilon \eta \lambda \mu \xi \tau \kappa \zeta \phi \chi</span><br><span class="line"></span><br><span class="line">e^{2}\neq</span><br><span class="line"></span><br><span class="line">#小括号</span><br><span class="line">空格式：\left (  \right )</span><br><span class="line">效果：()</span><br><span class="line">有数据的括号格式：\left ( 123,45 \right )</span><br><span class="line">效果：(123,45)</span><br><span class="line">#中括号</span><br><span class="line">空格式：\left [  \right ]</span><br><span class="line">效果：[]</span><br><span class="line">有数据的括号格式：\left [ 3,5,9 \right ]</span><br><span class="line">效果：[3,5,9]</span><br><span class="line"></span><br><span class="line">#尖括号</span><br><span class="line">空数据格式：\left \langle  \right \rangle</span><br><span class="line">&lt;&gt;</span><br><span class="line">有数据格式：\left \langle 3,4 \right \rangle</span><br><span class="line">&lt;3,4&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#水平线</span><br><span class="line">使用 \overline 和 \underline 在表达式的上、下方画出水平线</span><br><span class="line">\overline{lindexi.oschina.io}+\underline{lindexi.github.io}</span><br><span class="line"></span><br><span class="line">#上大括号</span><br><span class="line">使用\overbrace 和 \underbrace 可以在表达式上方、下方添加花括号</span><br><span class="line"></span><br><span class="line">\overbrace{blog.csdn.net/lindexi_gd}_{lindexi} + \underbrace{lindexi.github.io}_{doubi}</span><br><span class="line"></span><br><span class="line">#三角函数</span><br><span class="line">\sin\theta </span><br><span class="line">\cos\theta </span><br><span class="line">\tan\theta </span><br><span class="line">\cot \theta</span><br></pre></td></tr></tbody></table></figure><h2 id="katex前端展示latex数学公式效果"><a class="markdownIt-Anchor" href="#katex前端展示latex数学公式效果"></a> katex前端展示latex数学公式效果</h2><p>参考GitHub<br><a href="https://github.com/Khan/KaTeX">https://github.com/Khan/KaTeX</a></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang="en"&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset="UTF-8"&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">    &lt;script src='/static/jq/jquery.min.js'&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-beta/dist/katex.min.css"</span><br><span class="line">          integrity="sha384-9tPv11A+glH/on/wEu99NVwDPwkMQESOocs/ZGXPoIiLE8MU/qkqUcZ3zzL+6DuH" crossorigin="anonymous"&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script src="https://cdn.jsdelivr.net/npm/katex@0.10.0-beta/dist/katex.min.js"</span><br><span class="line">            integrity="sha384-U8Vrjwb8fuHMt6ewaCy8uqeUXv4oitYACKdB0VziCerzt011iQ/0TqlSlv8MReCm"</span><br><span class="line">            crossorigin="anonymous"&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;p&gt;&lt;span class="sp1"&gt;...&lt;/span&gt;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;&lt;span class="sp2"&gt;...&lt;/span&gt;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;&lt;span class="sp3"&gt;...&lt;/span&gt;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;&lt;span class="sp4"&gt;...&lt;/span&gt;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;&lt;span class="sp5"&gt;...&lt;/span&gt;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;&lt;span class="sp6"&gt;...&lt;/span&gt;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;&lt;span class="sp7"&gt;...&lt;/span&gt;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;&lt;span class="sp8"&gt;...&lt;/span&gt;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;&lt;span class="sp9"&gt;...&lt;/span&gt;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;&lt;span class="sp10"&gt;...&lt;/span&gt;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;&lt;span class="sp11"&gt;...&lt;/span&gt;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;&lt;span class="sp12"&gt;...&lt;/span&gt;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;&lt;span class="sp13"&gt;...&lt;/span&gt;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;&lt;span class="sp14"&gt;...&lt;/span&gt;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;&lt;span class="sp15"&gt;...&lt;/span&gt;&lt;/p&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    {#var a = document.getElementsByClassName("sp15")#}</span><br><span class="line">    {#katex.render("c = \\pm\\sqrt{a^2 + b^2}", a);#}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    {#特殊符号#}</span><br><span class="line">    html = katex.renderToString("\\$ \\%  \\&amp; \\_ \\{ \\}  \\# ");</span><br><span class="line">    $(".sp1").html(html)</span><br><span class="line"></span><br><span class="line">    {#上下标#}</span><br><span class="line">    html = katex.renderToString("a_{1}\\qquad x^2 \\quad  b^{3}_{ij} \\quad e^{2}\\neq (e^x)^2 \\quad e^{x^2}");</span><br><span class="line">    $(".sp2").html(html)</span><br><span class="line"></span><br><span class="line">    {#平方根#}</span><br><span class="line">    html = katex.renderToString("\\sqrt{x} \\quad \\sqrt[3]{x} \\quad \\sqrt{x^{2}+ \\sqrt{y}}");</span><br><span class="line">    $(".sp3").html(html)</span><br><span class="line"></span><br><span class="line">    {#分数#}</span><br><span class="line">    html = katex.renderToString("\\frac{x^2}{k+1} \\quad  x^{\\frac{2}{k+1}} \\quad x^{1/2}");</span><br><span class="line">    $(".sp4").html(html)</span><br><span class="line"></span><br><span class="line">    {#向量#}</span><br><span class="line">    html = katex.renderToString("\\vec a  \\qquad  \\overrightarrow{AB}  \\qquad  \\overleftarrow{AB}");</span><br><span class="line">    $(".sp5").html(html)</span><br><span class="line"></span><br><span class="line">    {#求和运算符#}</span><br><span class="line">    html = katex.renderToString("\\displaystyle{\\sum_{i=4}^{10}}");</span><br><span class="line">    $(".sp6").html(html)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    {#希腊字母#}</span><br><span class="line">    html = katex.renderToString("\\alpha \\beta \\gamma \\sigma \\omega \\delta \\pi \\rho \\epsilon \\eta \\lambda \\mu \\xi \\tau \\kappa \\zeta \\phi \\chi");</span><br><span class="line">    $(".sp7").html(html)</span><br><span class="line"></span><br><span class="line">    {#常用的数学运算符#}</span><br><span class="line">    html = katex.renderToString("\&gt; \&lt; \\le  \\ge  \\ne  \\approx  \\sim  \\subseteq  \\in  \\notin  \\times  \\div  \\pm  \\Rightarrow  \\rightarrow  \\infty  \\partial  \\angle  \\triangle");</span><br><span class="line">    $(".sp8").html(html)</span><br><span class="line"></span><br><span class="line">    {#小括号,中括号#}</span><br><span class="line">    html = katex.renderToString("\\left (1,2,4\\right) \\qquad \\left [ 3,5,9 \\right ]");</span><br><span class="line">    $(".sp9").html(html)</span><br><span class="line"></span><br><span class="line">    {#尖括号#}</span><br><span class="line">    html = katex.renderToString("\\left \\langle  \\right \\rangle \\qquad \\left \\langle 3,4 \\right \\rangle");</span><br><span class="line">    $(".sp10").html(html)</span><br><span class="line"></span><br><span class="line">    {#水平线#}</span><br><span class="line">    html = katex.renderToString("\\overline{.oschina.io}+\\underline{lindexi.github.io}");</span><br><span class="line">    $(".sp11").html(html)</span><br><span class="line"></span><br><span class="line">    {#上下大括号#}</span><br><span class="line">    html = katex.renderToString("\\overbrace{blog.csdn.net/lindexi_gd}_{lindexi} + \\underbrace{lindexi.github.io}_{doubi}");</span><br><span class="line">    $(".sp12").html(html)</span><br><span class="line"></span><br><span class="line">    {#三角函数#}</span><br><span class="line">    html = katex.renderToString("\\sin\\theta \\qquad \\cos\\theta \\qquad \\tan\\theta \\qquad \\cot \\theta");</span><br><span class="line">    $(".sp13").html(html)</span><br><span class="line"></span><br><span class="line">    {#对数函数 #}</span><br><span class="line">    html = katex.renderToString("\\lg X \\qquad \\log X \\qquad \\log_ 3 10");</span><br><span class="line">    $(".sp14").html(html)</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></tbody></table></figure><p>展现效果如下：<br><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200809194637.png" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LaTex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EOP 脱壳常用方法</title>
      <link href="/posts/cbad.html"/>
      <url>/posts/cbad.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x1-oep"><a class="markdownIt-Anchor" href="#0x1-oep"></a> 0X1 OEP</h1><hr><p>OEP：(Original Entry Point)，程序的入口点，软件加壳就是隐藏了OEP（或者用了假的OEP）， 只要我们找到程序真正的OEP，就可以立刻脱壳。</p><p>PUSHAD （压栈） 代表程序的入口点</p><p>POPAD （出栈） 代表程序的出口点</p><p>POPAD与PUSHAD相对应，一般找到这个OEP就在附近啦。</p><h1 id="0x2-常见寻找oep脱壳的方法"><a class="markdownIt-Anchor" href="#0x2-常见寻找oep脱壳的方法"></a> 0x2 常见寻找OEP脱壳的方法</h1><hr><h2 id="方法一"><a class="markdownIt-Anchor" href="#方法一"></a> 方法一：</h2><p>1.用OD载入，不分析代码！</p><p>2.单步向下跟踪F8，是向下跳的让它实现</p><p>3.遇到程序往回跳的（包括循环），我们在下一句代码处按F4（或者右健单击代码，选择断点——运行到所选）</p><p>4.绿色线条表示跳转没实现，不用理会，红色线条表示跳转已经实现！</p><p>5.如果刚载入程序，在附近就有一个CALL的，我们就F7跟进去，这样很快就能到程序的OEP</p><p>6.在跟踪的时候，如果运行到某个CALL程序就运行的，就在这个CALL中F7进入</p><p>7.一般有很大的跳转，比如 jmp XXXXXX 或者 JE XXXXXX 或者有RETE的一般很快就会到程序的OEP。</p><h2 id="方法二"><a class="markdownIt-Anchor" href="#方法二"></a> 方法二：</h2><p>ESP定理脱壳（ESP在OD的寄存器中，我们只要在命令行下ESP的硬件访问断点，就会一下来到程序的OEP了！）</p><p>1.开始就点F8，注意观察OD右上角的寄存器中ESP有没出现。</p><p>2.在命令行下：dd 0012FFA4（指在当前代码中的ESP地址），按回车！</p><p>3.选种下断的地址，下硬件访问WORD断点。</p><p>4.按一下F9运行程序，直接来到了跳转处，按下F8，到达程序OEP，脱壳</p><h2 id="方法三"><a class="markdownIt-Anchor" href="#方法三"></a> 方法三：</h2><p>内存跟踪：</p><p>1：用OD打开软件！</p><p>2：点击选项——调试选项——异常，把里面的忽略全部√上！CTRL+F2重载下程序！</p><p>3：按ALT+M,DA 打开内存镜象，找到第一个。rsrc.按F2下断点，</p><p>然后按SHIFT+F9运行到断点，接着再按ALT+M,DA 打开内存镜象，找到。RSRC上面的CODE，按<br>F2下断点！然后按SHIFT+F9，直接到达程序OEP，脱壳！</p><h2 id="方法四"><a class="markdownIt-Anchor" href="#方法四"></a> 方法四：</h2><p>一步到达OEP（前辈们总结的经验）</p><p>1.开始按Ctrl+F,输入：popad（只适合少数壳，包括ASPACK壳），然后按下F2，F9运行到此处</p><p>2.来到大跳转处，点下F8，脱壳之！</p><h2 id="方法五"><a class="markdownIt-Anchor" href="#方法五"></a> 方法五：</h2><p>1：用OD打开软件！</p><p>2：点击选项——调试选项——异常，把里面的√全部去掉！CTRL+F2重载下程序！</p><p>3：一开是程序就是一个跳转，在这里我们按SHIFT+F9，直到程序运行，记下从开始按F9到程序<br>运行的次数！</p><p>4：CTRL+F2重载程序，按SHIFT+F9（次数为程序运行的次数-1次</p><p>5：在OD的右下角我们看见有一个SE 句柄，这时我们按CTRL+G，输入SE 句柄前的地址！</p><p>6：按F2下断点！然后按SHIFT+F9来到断点处！</p><p>7：去掉断点，按F8慢慢向下走！</p><p>8：到达程序的OEP，脱壳！</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Reverse </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shelling method </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>获取Windosw系统信息批处理脚本</title>
      <link href="/posts/3763.html"/>
      <url>/posts/3763.html</url>
      
        <content type="html"><![CDATA[<figure class="highlight bat"><table><tbody><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">echo</span> --------------------------------------------------------------------------------------------------- &gt;&gt; System_Details.txt</span><br><span class="line"><span class="built_in">echo</span> System Information &gt;&gt; System_Details.txt</span><br><span class="line"><span class="built_in">echo</span> --------------------------------------------------------------------------------------------------- &gt;&gt; System_Details.txt</span><br><span class="line">systeminfo | <span class="built_in">findstr</span> /B /C:"OS" &gt; System_Details.txt</span><br><span class="line"><span class="built_in">echo</span> --------------------------------------------------------------------------------------------------- &gt;&gt; System_Details.txt</span><br><span class="line"><span class="built_in">echo</span> Hostname &gt;&gt; System_Details.txt</span><br><span class="line"><span class="built_in">echo</span> --------------------------------------------------------------------------------------------------- &gt;&gt; System_Details.txt</span><br><span class="line">hostname &gt;&gt; System_Details.txt</span><br><span class="line"><span class="built_in">echo</span> --------------------------------------------------------------------------------------------------- &gt;&gt; System_Details.txt</span><br><span class="line"><span class="built_in">echo</span> Users&gt;&gt; System_Details.txt</span><br><span class="line"><span class="built_in">echo</span> --------------------------------------------------------------------------------------------------- &gt;&gt; System_Details.txt</span><br><span class="line"><span class="built_in">net</span> users &gt;&gt; System_Details.txt</span><br><span class="line"><span class="built_in">echo</span> --------------------------------------------------------------------------------------------------- &gt;&gt; System_Details.txt</span><br><span class="line"><span class="built_in">echo</span> Route table &gt;&gt; System_Details.txt</span><br><span class="line"><span class="built_in">echo</span> --------------------------------------------------------------------------------------------------- &gt;&gt; System_Details.txt</span><br><span class="line">route <span class="built_in">print</span> &gt;&gt; System_Details.txt</span><br><span class="line"><span class="built_in">echo</span> --------------------------------------------------------------------------------------------------- &gt;&gt; System_Details.txt</span><br><span class="line"><span class="built_in">echo</span> Netstat INformation&gt;&gt; System_Details.txt</span><br><span class="line"><span class="built_in">echo</span> --------------------------------------------------------------------------------------------------- &gt;&gt; System_Details.txt</span><br><span class="line">netstat -ano &gt;&gt; System_Details.txt</span><br><span class="line"><span class="built_in">echo</span> --------------------------------------------------------------------------------------------------- &gt;&gt; System_Details.txt</span><br><span class="line"><span class="built_in">echo</span> Firewall State &gt;&gt; System_Details.txt</span><br><span class="line"><span class="built_in">echo</span> --------------------------------------------------------------------------------------------------- &gt;&gt; System_Details.txt</span><br><span class="line">netsh firewall show state &gt;&gt; System_Details.txt</span><br><span class="line"><span class="built_in">echo</span> --------------------------------------------------------------------------------------------------- &gt;&gt; System_Details.txt</span><br><span class="line"><span class="built_in">echo</span> Firewall configuration &gt;&gt; System_Details.txt</span><br><span class="line"><span class="built_in">echo</span> --------------------------------------------------------------------------------------------------- &gt;&gt; System_Details.txt</span><br><span class="line">netsh firewall show config &gt;&gt; System_Details.txt</span><br><span class="line"><span class="built_in">echo</span> --------------------------------------------------------------------------------------------------- &gt;&gt; System_Details.txt</span><br><span class="line"><span class="built_in">echo</span> Scheduled tasks &gt;&gt; System_Details.txt</span><br><span class="line"><span class="built_in">echo</span> --------------------------------------------------------------------------------------------------- &gt;&gt; System_Details.txt</span><br><span class="line">schtasks /query /fo LIST /v &gt;&gt; System_Details.txt</span><br><span class="line"><span class="built_in">echo</span> --------------------------------------------------------------------------------------------------- &gt;&gt; System_Details.txt</span><br><span class="line"><span class="built_in">echo</span> tasklist &gt;&gt; System_Details.txt</span><br><span class="line"><span class="built_in">echo</span> --------------------------------------------------------------------------------------------------- &gt;&gt; System_Details.txt</span><br><span class="line">tasklist /SVC &gt;&gt; System_Details.txt</span><br><span class="line"><span class="built_in">echo</span> --------------------------------------------------------------------------------------------------- &gt;&gt; System_Details.txt</span><br><span class="line"><span class="built_in">echo</span> <span class="built_in">net</span> <span class="built_in">start</span> &gt;&gt; System_Details.txt</span><br><span class="line"><span class="built_in">echo</span> --------------------------------------------------------------------------------------------------- &gt;&gt; System_Details.txt</span><br><span class="line"><span class="built_in">net</span> <span class="built_in">start</span> &gt;&gt; System_Details.txt</span><br><span class="line"><span class="built_in">echo</span> --------------------------------------------------------------------------------------------------- &gt;&gt; System_Details.txt</span><br><span class="line"><span class="built_in">echo</span> driverquery &gt;&gt; System_Details.txt</span><br><span class="line"><span class="built_in">echo</span> --------------------------------------------------------------------------------------------------- &gt;&gt; System_Details.txt</span><br><span class="line">DRIVERQUERY &gt;&gt; System_Details.txt</span><br><span class="line"><span class="built_in">echo</span> --------------------------------------------------------------------------------------------------- &gt;&gt; System_Details.txt</span><br><span class="line"><span class="built_in">echo</span> Wmic hotfix &gt;&gt; System_Details.txt</span><br><span class="line"><span class="built_in">echo</span> --------------------------------------------------------------------------------------------------- &gt;&gt; System_Details.txt</span><br><span class="line">wmic qfe get Caption,Description,HotFixID,InstalledOn &gt;&gt; System_Details.txt</span><br><span class="line"><span class="built_in">echo</span> --------------------------------------------------------------------------------------------------- &gt;&gt; System_Details.txt</span><br><span class="line"><span class="built_in">echo</span> reg queries - elavated &gt;&gt; System_Details.txt</span><br><span class="line"><span class="built_in">echo</span> --------------------------------------------------------------------------------------------------- &gt;&gt; System_Details.txt</span><br><span class="line">reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer\AlwaysInstallElevated</span><br><span class="line"><span class="built_in">echo</span> --------------------------------------------------------------------------------------------------- &gt;&gt; System_Details.txt</span><br><span class="line"><span class="built_in">echo</span> reg queries - elavated &gt;&gt; System_Details.txt</span><br><span class="line"><span class="built_in">echo</span> --------------------------------------------------------------------------------------------------- &gt;&gt; System_Details.txt</span><br><span class="line">sc qc Spooler &gt;&gt; System_Details.txt</span><br><span class="line">accesschk.exe -ucqv Spooler &gt;&gt; System_Details.txt</span><br><span class="line">accesschk.exe -uwcqv "Authenticated Users" * &gt;&gt; System_Details.txt</span><br><span class="line"><span class="built_in">echo</span> --------------------------------------------------------------------------------------------------- &gt;&gt; System_Details.txt</span><br><span class="line"><span class="built_in">echo</span> upnhosts - elavated &gt;&gt; System_Details.txt</span><br><span class="line"><span class="built_in">echo</span> --------------------------------------------------------------------------------------------------- &gt;&gt; System_Details.txt</span><br><span class="line">sc qc upnphost &gt;&gt; System_Details.txt</span><br><span class="line"><span class="built_in">echo</span> --------------------------------------------------------------------------------------------------- &gt;&gt; System_Details.txt</span><br><span class="line"><span class="built_in">echo</span> End of Script &gt;&gt; System_Details.txt</span><br><span class="line"><span class="built_in">echo</span> --------------------------------------------------------------------------------------------------- &gt;&gt; System_Details.txt</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> System </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Crack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VS Code edit background</title>
      <link href="/posts/7060.html"/>
      <url>/posts/7060.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>  今天用VS Code 写代码，感觉背景有点单调，所以决定美化一下（美名其曰美化，其实是偷偷摸鱼），网上大部分教程都是使用background插件来自定义vscode的背景图，这种方法需要在配置文件中配置一下，但是折腾完了发现这个方法不是很对我的胃口。</p><p>​ 这是在使用过程中出现的一些问题：</p><ol><li>在VS Code窗口右下角会有警告提示，虽然可以手动关闭，但是我不喜欢。</li><li>背景图只能覆盖代码区，左侧菜单区是不能覆盖的。</li><li>VS Code更新后，配置文件setting.json下修改的适应背景的配置代码会消失。</li></ol><p>  感兴趣的小伙伴可以去百度一下教程，我在这里就不在赘述了，这里着重介绍第二种方法：修改一下vscode的源css文件。</p><p>**ps：**background插件在删除的时候，会自动删除添加的样式（依赖node环境）。<br>如果没有node环境，需要在 settings.json 中设置 {“background.enabled”: false} ，然后再删除插件。如果直接删除插件会有遗留，就需要重装vscode了。</p><p>这里先把效果图放一下：</p><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200529162132.png" alt=""></p><h1 id="如何实现"><a class="markdownIt-Anchor" href="#如何实现"></a> 如何实现</h1><ol><li><p>进入VS Code的源文件下面，找到 workbench.desktop.main.css 文件，文件地址  E:\Microsoft VS Code\resources\app\out\vs\workbench  （我的VS Code安装在E盘下）</p><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/J(OZ_WI@QE67%7BAU)59~7RZW.png" alt="img"></p></li><li><p>任意的编译器打开workbench.desktop.main.css 文件，可以插入源代码中，也可以直接写在末尾位置，添加body{}，这一步也就是在css中写入配置文件，修改添加到背景的图片的相关信息，代码如下：</p><figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> {</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">11px</span>;</span><br><span class="line">  user-select: none;</span><br><span class="line">  <span class="attribute">pointer-events</span>: auto;</span><br><span class="line">  <span class="attribute">background-size</span>: cover;    //详见说明</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0.75</span>;             //透明度修改，注意这里图片和代码文字都能会被透明度影响</span><br><span class="line">  <span class="attribute">background-position</span>: <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">"file:///F:/picture/wallpaper/cartoon/大姐姐.png"</span>);</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">z-index</span>: <span class="number">99999</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ol><p><strong>说明：</strong></p><ul><li><p>background-size: cover实现背景图片自适应:</p><p>background-size:100% ;   不设置表示默认图片大小，设置100%表示全屏显示图片，按比例缩小或者放大。这样就可以实现背景图片自适应父容器大小而自动变化，达到填充效果。 但是，图片会被拉伸填充，这并不是我们想要的效果，那么我们可以不设置 <code>100%</code> 参数，而是使用 <code>cover</code> 参数。</p><p>background-size:cover ;  设置cover参数以后，背景图会按比例缩放填充满整个背景。</p></li><li><p>页面可以设置全局的也可以设置局部的，下面是局部和全局简洁配置代码:</p><p>局部效果（简洁），修改body为下面代码：</p><figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> {</span><br><span class="line">      <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">'file:///F:/picture/wallpaper/cartoon/大姐姐.png'</span>);</span><br><span class="line">      <span class="attribute">background-size</span>: <span class="number">20%</span>;</span><br><span class="line">      <span class="attribute">background-position</span>: <span class="number">100%</span> <span class="number">100%</span>;</span><br><span class="line">      <span class="attribute">opacity</span>: <span class="number">0.75</span>;</span><br><span class="line">      <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure><p>全局效果（简洁），修改body为下面代码：</p><figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> {</span><br><span class="line">      <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">'file:///F:/picture/wallpaper/cartoon/大姐姐.png'</span>);</span><br><span class="line">      <span class="attribute">background-size</span>: <span class="number">100%</span>;</span><br><span class="line">      <span class="attribute">opacity</span>: <span class="number">0.75</span>;</span><br><span class="line">      <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">  }</span><br></pre></td></tr></tbody></table></figure></li><li><p>对body添加图片：</p><p>图片要用file:///D:/xxxxx这种格式写，例子  file:///F:/picture/wallpaper/cartoon/大姐姐.png</p></li></ul><ol start="3"><li>接下来就可以欣赏大姐姐了😍</li></ol><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200529162120.png" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VS Code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown grammer</title>
      <link href="/posts/b01d.html"/>
      <url>/posts/b01d.html</url>
      
        <content type="html"><![CDATA[<h2 id="正文"><a class="markdownIt-Anchor" href="#正文"></a> 正文</h2><h3 id="1-markdown是什么"><a class="markdownIt-Anchor" href="#1-markdown是什么"></a> 1. Markdown<em>是什么</em>？</h3><p><strong>Markdown</strong>是一种轻量级<strong>标记语言</strong>，它以纯文本形式(<em>易读、易写、易更改</em>)编写文档，并最终以HTML格式发布。<br><strong>Markdown</strong>也可以理解为将以MARKDOWN语法编写的语言转换成HTML内容的工具。</p><h3 id="2-为什么要使用它"><a class="markdownIt-Anchor" href="#2-为什么要使用它"></a> 2. <em>为什么</em>要使用它？</h3><ul><li>它是易读（看起来舒服）、易写（语法简单）、易更改<strong>纯文本</strong>。处处体现着<strong>极简主义</strong>的影子。</li><li>兼容HTML，可以转换为HTML格式发布。</li><li>跨平台使用。</li><li>越来越多的网站支持Markdown。</li><li>更方便清晰地组织你的电子邮件。（Markdown-here, Airmail）</li><li>摆脱Word（我不是认真的）。</li></ul><h3 id="3-怎么使用"><a class="markdownIt-Anchor" href="#3-怎么使用"></a> 3. <em>怎么</em>使用？</h3><p>如果不算<strong>扩展</strong>，Markdown的语法绝对<strong>简单</strong>到让你爱不释手。</p><p>Markdown语法主要分为如下几大部分： <strong>标题</strong>，<strong>段落</strong>，<strong>区块引用</strong>，<strong>代码区块</strong>，<strong>强调</strong>，<strong>列表</strong>，<strong>分割线</strong>，<strong>链接</strong>，<strong>图片</strong>，<strong>反斜杠 <code>\</code></strong>，<strong>符号’`’</strong>。</p><h4 id="31-标题"><a class="markdownIt-Anchor" href="#31-标题"></a> 3.1 标题</h4><p>两种形式：<br>1）使用<code>=</code>和<code>-</code>标记一级和二级标题。</p><blockquote><p>一级标题<br><code>=========</code><br>二级标题<br><code>---------</code></p></blockquote><p>效果：</p><blockquote><h1 id="一级标题"><a class="markdownIt-Anchor" href="#一级标题"></a> 一级标题</h1><h2 id="二级标题"><a class="markdownIt-Anchor" href="#二级标题"></a> 二级标题</h2></blockquote><p>2）使用<code>#</code>，可表示1-6级标题。</p><blockquote><p># 一级标题<br>## 二级标题<br>### 三级标题<br>#### 四级标题<br>##### 五级标题<br>###### 六级标题</p></blockquote><p>效果：</p><blockquote><h1 id="一级标题-2"><a class="markdownIt-Anchor" href="#一级标题-2"></a> 一级标题</h1><h2 id="二级标题-2"><a class="markdownIt-Anchor" href="#二级标题-2"></a> 二级标题</h2><h3 id="三级标题"><a class="markdownIt-Anchor" href="#三级标题"></a> 三级标题</h3><h4 id="四级标题"><a class="markdownIt-Anchor" href="#四级标题"></a> 四级标题</h4><h5 id="五级标题"><a class="markdownIt-Anchor" href="#五级标题"></a> 五级标题</h5><h6 id="六级标题"><a class="markdownIt-Anchor" href="#六级标题"></a> 六级标题</h6></blockquote><h4 id="32-段落"><a class="markdownIt-Anchor" href="#32-段落"></a> 3.2 段落</h4><p>段落的前后要有空行，所谓的空行是指没有文字内容。若想在段内强制换行的方式是使用<strong>两个以上</strong>空格加上回车（引用中换行省略回车）。</p><h4 id="33-区块引用"><a class="markdownIt-Anchor" href="#33-区块引用"></a> 3.3 区块引用</h4><p>在段落的每行或者只在第一行使用符号<code>&gt;</code>,还可使用多个嵌套引用，如：</p><blockquote><p>&gt; 区块引用<br>&gt;&gt; 嵌套引用</p></blockquote><p>效果：</p><blockquote><p>区块引用</p><blockquote><p>嵌套引用</p></blockquote></blockquote><h4 id="34-代码区块"><a class="markdownIt-Anchor" href="#34-代码区块"></a> 3.4 代码区块</h4><ul><li>在需要高亮的代码块的前一行及后一行使用三个反引号 ```（~ 键）</li><li>同时第一行反引号后面，输入代码块所使用的语言，实现代码高亮。</li></ul><p>普通段落：</p><p>void main()<br>{<br>printf(“Hello, Markdown.”);<br>}</p><p>代码区块：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello, Markdown."</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>注意</strong>:需要和普通段落之间存在空行。</p><h4 id="35-强调"><a class="markdownIt-Anchor" href="#35-强调"></a> 3.5 强调</h4><p>在强调内容两侧分别加上<code>*</code>或者<code>_</code>，如：</p><blockquote><p><em>斜体</em>，<em>斜体</em><br><strong>粗体</strong>，<strong>粗体</strong></p></blockquote><p>效果：</p><blockquote><p><em>斜体</em>，<em>斜体</em><br><strong>粗体</strong>，<strong>粗体</strong></p></blockquote><h4 id="36-列表"><a class="markdownIt-Anchor" href="#36-列表"></a> 3.6 列表</h4><p>使用<code>·</code>、<code>+</code>、或<code>-</code>标记无序列表，如：</p><blockquote><p>-（+<em>） 第一项 -（+</em>） 第二项 - （+*）第三项</p></blockquote><p><strong>注意</strong>：标记后面最少有一个_空格_或_制表符_。若不在引用区块中，必须和前方段落之间存在空行。</p><p>效果：</p><blockquote><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul></blockquote><p>有序列表的标记方式是将上述的符号换成数字,并辅以<code>.</code>，如：</p><blockquote><p>1 . 第一项<br>2 . 第二项<br>3 . 第三项</p></blockquote><p>效果：</p><blockquote><ol><li>第一项</li><li>第二项</li><li>第三项</li></ol></blockquote><h4 id="37-分割线"><a class="markdownIt-Anchor" href="#37-分割线"></a> 3.7 分割线</h4><p>分割线最常使用就是三个或以上<code>*</code>，还可以使用<code>-</code>和<code>_</code>。</p><h4 id="38-链接"><a class="markdownIt-Anchor" href="#38-链接"></a> 3.8 链接</h4><p>链接可以由两种形式生成：<strong>行内式</strong>和<strong>参考式</strong>。<br><strong>行内式</strong>：</p><blockquote><p><a href="https://tlhg.top">Tlhg‘s blog address1</a></p></blockquote><p>效果：</p><blockquote><p><a href="https://tlhg.top">Tlhg‘s blog address1</a></p></blockquote><p><strong>参考式</strong>：</p><blockquote><p><a href="https://tlhg.top">Tlhg’s blog address1</a><br><a href="https://tlhg.top">Tlhg’s blog address2</a></p></blockquote><p>效果：</p><blockquote><p><a href="https://tlhg.top">Tlhg‘s blog address1</a><br><a href="https://tlhg.top">Tlhg‘s blog address2</a></p></blockquote><h4 id="39-图片"><a class="markdownIt-Anchor" href="#39-图片"></a> 3.9 图片</h4><p>添加图片的形式和链接相似，只需在链接的基础上前方加一个<code>！</code>。</p><h4 id="310-反斜杠"><a class="markdownIt-Anchor" href="#310-反斜杠"></a> 3.10 反斜杠<code>\</code></h4><p>相当于<strong>反转义</strong>作用。使符号成为普通符号。</p><h4 id="311-符号"><a class="markdownIt-Anchor" href="#311-符号"></a> 3.11 符号’`’</h4><p>起到标记作用。如：</p><blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">ctrl+a</span><br></pre></td></tr></tbody></table></figure></blockquote><p>效果：</p><blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">ctrl+a</span><br></pre></td></tr></tbody></table></figure></blockquote><h4 id="4-谁在用"><a class="markdownIt-Anchor" href="#4-谁在用"></a> 4. <em>谁</em>在用？</h4><p>Markdown的使用者：</p><ul><li>GitHub</li><li>简书</li><li>Stack Overflow</li><li>Apollo</li><li>Moodle</li><li>Reddit</li><li>等等</li></ul><h4 id="5-尝试一下"><a class="markdownIt-Anchor" href="#5-尝试一下"></a> 5. 尝试一下</h4><ul><li><strong>Chrome</strong>下的插件诸如<code>stackedit</code>与<code>markdown-here</code>等非常方便，也不用担心平台受限。</li><li><strong>在线</strong>的dillinger.io评价也不错</li><li><strong>Windowns</strong>下的MarkdownPad也用过，不过免费版的体验不是很好。</li><li><strong>Mac</strong>下的Mou是国人贡献的，口碑很好。</li><li><strong>Linux</strong>下的ReText不错。</li></ul><p><strong>当然，最终境界永远都是笔下是语法，心中格式化 😃。</strong></p><hr><p><strong>注意</strong>：不同的Markdown解释器或工具对相应语法（扩展语法）的解释效果不尽相同，具体可参见工具的使用说明。 虽然有人想出面搞一个所谓的标准化的Markdown，[没想到还惹怒了健在的创始人John Gruber] (<a href="http://blog.codinghorror.com/standard-markdown-is-now-common-markdown/">http://blog.codinghorror.com/standard-markdown-is-now-common-markdown/</a> )。</p><hr><p>以上基本是所有traditonal markdown的语法。</p><h3 id="其它"><a class="markdownIt-Anchor" href="#其它"></a> 其它：</h3><p>列表的使用(非traditonal markdown)：</p><p>用<code>|</code>表示表格纵向边界，表头和表内容用<code>-</code>隔开，并可用<code>:</code>进行对齐设置，两边都有<code>:</code>则表示居中，若不加<code>:</code>则默认左对齐。</p><table><thead><tr><th>代码库</th><th>链接</th></tr></thead><tbody><tr><td>MarkDown</td><td><a href="https://github.com/Tlhg-0">https://github.com/Tlhg-0</a></td></tr><tr><td>MarkDownCopy</td><td><a href="https://github.com/Tlhg-0">https://github.com/Tlhg-0</a></td></tr></tbody></table><p>关于其它扩展语法可参见具体工具的使用说明。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter08-IO库</title>
      <link href="/posts/702d.html"/>
      <url>/posts/702d.html</url>
      
        <content type="html"><![CDATA[<p>部分IO库设施：</p><ul><li><code>istream</code>：输入流类型，提供输入操作。</li><li><code>ostream</code>：输出流类型，提供输出操作。</li><li><code>cin</code>：<code>istream</code>对象，从标准输入读取数据。</li><li><code>cout</code>：<code>ostream</code>对象，向标准输出写入数据。</li><li><code>cerr</code>：<code>ostream</code>对象，向标准错误写入数据。</li><li><code>&gt;&gt;</code>运算符：从<code>istream</code>对象读取输入数据。</li><li><code>&lt;&lt;</code>运算符：向<code>ostream</code>对象写入输出数据。</li><li><code>getline</code>函数：从<code>istream</code>对象读取一行数据，写入<code>string</code>对象。</li></ul><h2 id="io类the-io-classes"><a class="markdownIt-Anchor" href="#io类the-io-classes"></a> IO类（The IO Classes）</h2><p>头文件<em>iostream</em>定义了用于读写流的基本类型，<em>fstream</em>定义了读写命名文件的类型，<em>sstream</em>定义了读写内存中<code>string</code>对象的类型。</p><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200825174630.png" alt=""></p><p>宽字符版本的IO类型和函数的名字以<code>w</code>开始，如<code>wcin</code>、<code>wcout</code>和<code>wcerr</code>分别对应<code>cin</code>、<code>cout</code>和<code>cerr</code>。它们与其对应的普通<code>char</code>版本都定义在同一个头文件中，如头文件<em>fstream</em>定义了<code>ifstream</code>和<code>wifstream</code>类型。</p><p>可以将派生类的对象当作其基类的对象使用。</p><h3 id="io象无拷贝或赋值no-copy-or-assign-for-io-objects"><a class="markdownIt-Anchor" href="#io象无拷贝或赋值no-copy-or-assign-for-io-objects"></a> IO象无拷贝或赋值（No Copy or Assign for IO Objects）</h3><p>不能拷贝或对IO对象赋值。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">ofstream out1, out2;</span><br><span class="line">out1 = out2;    <span class="comment">// error: cannot assign stream objects</span></span><br><span class="line"><span class="function">ofstream <span class="title">print</span><span class="params">(ofstream)</span></span>;   <span class="comment">// error: can't initialize the ofstream parameter</span></span><br><span class="line">out2 = <span class="built_in">print</span>(out2);     <span class="comment">// error: cannot copy stream objects</span></span><br></pre></td></tr></tbody></table></figure><p>由于IO对象不能拷贝，因此不能将函数形参或返回类型定义为流类型。进行IO操作的函数通常以引用方式传递和返回流。读写一个IO对象会改变其状态，因此传递和返回的引用不能是<code>const</code>的。</p><h3 id="条件状态condition-states"><a class="markdownIt-Anchor" href="#条件状态condition-states"></a> 条件状态（Condition States）</h3><p>IO库条件状态：</p><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200825174831.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200825174844.png" alt=""></p><p><code>badbit</code>表示系统级错误，如不可恢复的读写错误。通常情况下，一旦<code>badbit</code>被置位，流就无法继续使用了。在发生可恢复错误后，<code>failbit</code>会被置位，如期望读取数值却读出一个字符。如果到达文件结束位置，<code>eofbit</code>和<code>failbit</code>都会被置位。如果流未发生错误，则<code>goodbit</code>的值为0。如果<code>badbit</code>、<code>failbit</code>和<code>eofbit</code>任何一个被置位，检测流状态的条件都会失败。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (cin &gt;&gt; word)</span><br><span class="line">    <span class="comment">// ok: read operation successful...</span></span><br></pre></td></tr></tbody></table></figure><p><code>good</code>函数在所有错误均未置位时返回<code>true</code>。而<code>bad</code>、<code>fail</code>和<code>eof</code>函数在对应错误位被置位时返回<code>true</code>。此外，在<code>badbit</code>被置位时，<code>fail</code>函数也会返回<code>true</code>。因此应该使用<code>good</code>或<code>fail</code>函数确定流的总体状态，<code>eof</code>和<code>bad</code>只能检测特定错误。</p><p>流对象的<code>rdstate</code>成员返回一个<code>iostate</code>值，表示流的当前状态。<code>setstate</code>成员用于将指定条件置位（叠加原始流状态）。<code>clear</code>成员的无参版本清除所有错误标志；含参版本接受一个<code>iostate</code>值，用于设置流的新状态（覆盖原始流状态）。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// remember the current state of cin</span></span><br><span class="line"><span class="keyword">auto</span> old_state = cin.<span class="built_in">rdstate</span>();     <span class="comment">// remember the current state of cin</span></span><br><span class="line">cin.<span class="built_in">clear</span>();    <span class="comment">// make cin valid</span></span><br><span class="line"><span class="built_in">process_input</span>(cin);     <span class="comment">// use cin</span></span><br><span class="line">cin.<span class="built_in">setstate</span>(old_state);    <span class="comment">// now reset cin to its old state</span></span><br></pre></td></tr></tbody></table></figure><h3 id="管理输出缓冲managing-the-output-buffer"><a class="markdownIt-Anchor" href="#管理输出缓冲managing-the-output-buffer"></a> 管理输出缓冲（Managing the Output Buffer）</h3><p>每个输出流都管理一个缓冲区，用于保存程序读写的数据。导致缓冲刷新（即数据真正写入输出设备或文件）的原因有很多：</p><ul><li>程序正常结束。</li><li>缓冲区已满。</li><li>使用操纵符（如<code>endl</code>）显式刷新缓冲区。</li><li>在每个输出操作之后，可以用<code>unitbuf</code>操纵符设置流的内部状态，从而清空缓冲区。默认情况下，对<code>cerr</code>是设置<code>unitbuf</code>的，因此写到<code>cerr</code>的内容都是立即刷新的。</li><li>一个输出流可以被关联到另一个流。这种情况下，当读写被关联的流时，关联到的流的缓冲区会被刷新。默认情况下，<code>cin</code>和<code>cerr</code>都关联到<code>cout</code>，因此，读<code>cin</code>或写<code>cerr</code>都会刷新<code>cout</code>的缓冲区。</li></ul><p><code>flush</code>操纵符刷新缓冲区，但不输出任何额外字符。<code>ends</code>向缓冲区插入一个空字符，然后刷新缓冲区。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">"hi!"</span> &lt;&lt; endl;   <span class="comment">// writes hi and a newline, then flushes the buffer</span></span><br><span class="line">cout &lt;&lt; <span class="string">"hi!"</span> &lt;&lt; flush;  <span class="comment">// writes hi, then flushes the buffer; adds no data</span></span><br><span class="line">cout &lt;&lt; <span class="string">"hi!"</span> &lt;&lt; ends;   <span class="comment">// writes hi and a null, then flushes the buffer</span></span><br></pre></td></tr></tbody></table></figure><p>如果想在每次输出操作后都刷新缓冲区，可以使用<code>unitbuf</code>操纵符。它令流在接下来的每次写操作后都进行一次<code>flush</code>操作。而<code>nounitbuf</code>操纵符则使流恢复使用正常的缓冲区刷新机制。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">cout &lt;&lt; unitbuf;    <span class="comment">// all writes will be flushed immediately</span></span><br><span class="line"><span class="comment">// any output is flushed immediately, no buffering</span></span><br><span class="line">cout &lt;&lt; nounitbuf;  <span class="comment">// returns to normal buffering</span></span><br></pre></td></tr></tbody></table></figure><p>如果程序异常终止，输出缓冲区不会被刷新。</p><p>当一个输入流被关联到一个输出流时，任何试图从输入流读取数据的操作都会先刷新关联的输出流。标准库将<code>cout</code>和<code>cin</code>关联在一起，因此下面的语句会导致<code>cout</code>的缓冲区被刷新：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">cin &gt;&gt; ival;</span><br></pre></td></tr></tbody></table></figure><p>交互式系统通常应该关联输入流和输出流。这意味着包括用户提示信息在内的所有输出，都会在读操作之前被打印出来。</p><p>使用<code>tie</code>函数可以关联两个流。它有两个重载版本：无参版本返回指向输出流的指针。如果本对象已关联到一个输出流，则返回的就是指向这个流的指针，否则返回空指针。<code>tie</code>的第二个版本接受一个指向<code>ostream</code>的指针，将本对象关联到此<code>ostream</code>。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">cin.<span class="built_in">tie</span>(&amp;cout);     <span class="comment">// illustration only: the library ties cin and cout for us</span></span><br><span class="line"><span class="comment">// old_tie points to the stream (if any) currently tied to cin</span></span><br><span class="line">ostream *old_tie = cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>); <span class="comment">// cin is no longer tied</span></span><br><span class="line"><span class="comment">// ties cin and cerr; not a good idea because cin should be tied to cout</span></span><br><span class="line">cin.<span class="built_in">tie</span>(&amp;cerr);     <span class="comment">// reading cin flushes cerr, not cout</span></span><br><span class="line">cin.<span class="built_in">tie</span>(old_tie);   <span class="comment">// reestablish normal tie between cin and cout</span></span><br></pre></td></tr></tbody></table></figure><p>每个流同时最多关联一个流，但多个流可以同时关联同一个<code>ostream</code>。向<code>tie</code>传递空指针可以解开流的关联。</p><h2 id="文件输入输出file-input-and-output"><a class="markdownIt-Anchor" href="#文件输入输出file-input-and-output"></a> 文件输入输出（File Input and Output）</h2><p>头文件<em>fstream</em>定义了三个类型来支持文件IO：<code>ifstream</code>从给定文件读取数据，<code>ofstream</code>向指定文件写入数据，<code>fstream</code>可以同时读写指定文件。</p><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200825174953.png" alt=""></p><h3 id="使用文件流对象using-file-stream-objects"><a class="markdownIt-Anchor" href="#使用文件流对象using-file-stream-objects"></a> 使用文件流对象（Using File Stream Objects）</h3><p>每个文件流类型都定义了<code>open</code>函数，它完成一些系统操作，定位指定文件，并视情况打开为读或写模式。</p><p>创建文件流对象时，如果提供了文件名（可选），<code>open</code>会被自动调用。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(ifile)</span></span>;   <span class="comment">// construct an ifstream and open the given file</span></span><br><span class="line">ofstream out;   <span class="comment">// output file stream that is not associated with any file</span></span><br></pre></td></tr></tbody></table></figure><p>在C++11中，文件流对象的文件名可以是<code>string</code>对象或C风格字符数组。旧版本的标准库只支持C风格字符数组。</p><p>在要求使用基类对象的地方，可以用继承类型的对象代替。因此一个接受<code>iostream</code>类型引用或指针参数的函数，可以用对应的<code>fstream</code>类型来调用。</p><p>可以先定义空文件流对象，再调用<code>open</code>函数将其与指定文件关联。如果<code>open</code>调用失败，<code>failbit</code>会被置位。</p><p>对一个已经打开的文件流调用<code>open</code>会失败，并导致<code>failbit</code>被置位。随后试图使用文件流的操作都会失败。如果想将文件流关联到另一个文件，必须先调用<code>close</code>关闭当前文件，再调用<code>clear</code>重置流的条件状态（<code>close</code>不会重置流的条件状态）。</p><p>当<code>fstream</code>对象被销毁时，<code>close</code>会自动被调用。</p><h3 id="文件模式file-modes"><a class="markdownIt-Anchor" href="#文件模式file-modes"></a> 文件模式（File Modes）</h3><p>每个流都有一个关联的文件模式，用来指出如何使用文件。</p><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200825175411.png" alt=""></p><ul><li>只能对<code>ofstream</code>或<code>fstream</code>对象设定<code>out</code>模式。</li><li>只能对<code>ifstream</code>或<code>fstream</code>对象设定<code>in</code>模式。</li><li>只有当<code>out</code>被设定时才能设定<code>trunc</code>模式。</li><li>只要<code>trunc</code>没被设定，就能设定<code>app</code>模式。在<code>app</code>模式下，即使没有设定<code>out</code>模式，文件也是以输出方式打开。</li><li>默认情况下，即使没有设定<code>trunc</code>，以<code>out</code>模式打开的文件也会被截断。如果想保留以<code>out</code>模式打开的文件内容，就必须同时设定<code>app</code>模式，这会将数据追加写到文件末尾；或者同时设定<code>in</code>模式，即同时进行读写操作。</li><li><code>ate</code>和<code>binary</code>模式可用于任何类型的文件流对象，并可以和其他任何模式组合使用。</li><li>与<code>ifstream</code>对象关联的文件默认以<code>in</code>模式打开，与<code>ofstream</code>对象关联的文件默认以<code>out</code>模式打开，与<code>fstream</code>对象关联的文件默认以<code>in</code>和<code>out</code>模式打开。</li></ul><p>默认情况下，打开<code>ofstream</code>对象时，文件内容会被丢弃，阻止文件清空的方法是同时指定<code>app</code>或<code>in</code>模式。</p><p>流对象每次打开文件时都可以改变其文件模式。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">ofstream out;   <span class="comment">// no file mode is set</span></span><br><span class="line">out.<span class="built_in">open</span>(<span class="string">"scratchpad"</span>);    <span class="comment">// mode implicitly out and trunc</span></span><br><span class="line">out.<span class="built_in">close</span>();    <span class="comment">// close out so we can use it for a different file</span></span><br><span class="line">out.<span class="built_in">open</span>(<span class="string">"precious"</span>, ofstream::app);   <span class="comment">// mode is out and app</span></span><br><span class="line">out.<span class="built_in">close</span>();</span><br></pre></td></tr></tbody></table></figure><h2 id="string流string-streams"><a class="markdownIt-Anchor" href="#string流string-streams"></a> string流（string Streams）</h2><p>头文件<em>sstream</em>定义了三个类型来支持内存IO：<code>istringstream</code>从<code>string</code>读取数据，<code>ostringstream</code>向<code>string</code>写入数据，<code>stringstream</code>可以同时读写<code>string</code>的数据。</p><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200825175428.png" alt=""></p><h3 id="使用istringstreamusing-an-istringstream"><a class="markdownIt-Anchor" href="#使用istringstreamusing-an-istringstream"></a> 使用istringstream（Using an istringstream）</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// members are public by default</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PersonInfo</span></span><br><span class="line">{</span><br><span class="line">    string name;</span><br><span class="line">    vector&lt;string&gt; phones;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">string line, word;   <span class="comment">// will hold a line and word from input, respectively</span></span><br><span class="line">vector&lt;PersonInfo&gt; people;    <span class="comment">// will hold all the records from the input</span></span><br><span class="line"><span class="comment">// read the input a line at a time until cin hits end-of-file (or another error)</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">getline</span>(cin, line))</span><br><span class="line">{</span><br><span class="line">    PersonInfo info;    <span class="comment">// create an object to hold this record's data</span></span><br><span class="line">    <span class="function">istringstream <span class="title">record</span><span class="params">(line)</span></span>;    <span class="comment">// bind record to the line we just read</span></span><br><span class="line">    record &gt;&gt; info.name;    <span class="comment">// read the name</span></span><br><span class="line">    <span class="keyword">while</span> (record &gt;&gt; word)  <span class="comment">// read the phone numbers</span></span><br><span class="line">        info.phones.<span class="built_in">push_back</span>(word);   <span class="comment">// and store them</span></span><br><span class="line">    people.<span class="built_in">push_back</span>(info);    <span class="comment">// append this record to people</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="使用ostringstreamusing-ostringstreams"><a class="markdownIt-Anchor" href="#使用ostringstreamusing-ostringstreams"></a> 使用ostringstream（Using ostringstreams）</h3><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;entry : people)</span><br><span class="line">{ <span class="comment">// for each entry in people</span></span><br><span class="line">    ostringstream formatted, badNums;   <span class="comment">// objects created on each loop</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;nums : entry.phones)</span><br><span class="line">    { <span class="comment">// for each number</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">valid</span>(nums))</span><br><span class="line">        {</span><br><span class="line">            badNums &lt;&lt; <span class="string">" "</span> &lt;&lt; nums;  <span class="comment">// string in badNums</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// ''writes'' to formatted's string</span></span><br><span class="line">            formatted &lt;&lt; <span class="string">" "</span> &lt;&lt; format(nums);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (badNums.<span class="built_in">str</span>().<span class="built_in">empty</span>())   <span class="comment">// there were no bad numbers</span></span><br><span class="line">        os &lt;&lt; entry.name &lt;&lt; <span class="string">" "</span>  <span class="comment">// print the name</span></span><br><span class="line">            &lt;&lt; formatted.<span class="built_in">str</span>() &lt;&lt; endl;   <span class="comment">// and reformatted numbers</span></span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">// otherwise, print the name and bad numbers</span></span><br><span class="line">        cerr &lt;&lt; <span class="string">"input error: "</span> &lt;&lt; entry.name</span><br><span class="line">            &lt;&lt; <span class="string">" invalid number(s) "</span> &lt;&lt; badNums.<span class="built_in">str</span>() &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+github搭建博客</title>
      <link href="/posts/fef1.html"/>
      <url>/posts/fef1.html</url>
      
        <content type="html"><![CDATA[<p>转载此文章前，请先联系作者，经作者同意后再转载，并请注明原文链接和作者，整理这些不容易，最终版权归作者所有，谢谢合作！</p><p>你了解Hexo吗？ Hexo是一个静态博客框架，基于Node.js，将Markdown文章通过渲染引擎，生成一个静态网页，再结合Git命令（ssh），Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><p>几个月前偶然间了解到了Hexo这个静态博客网站，很适合那些喜欢写作的朋友们，最重要的是它是免费的，里面有许多的博客主题模板，这些主题都是一些很牛的大佬们开发的，而且设计的主题都很棒，让我很心动，心动不如行动，于是开始整理搭建属于自己的博客。直到今天，这中间经历了许多的坎坷荆棘，我将我的博客搭建的流程分享出来，能为那些博客小石榴们提供一些帮助吧，如果有错的话，请给我留言，我会及时修改，废话不多说，直接上教程。</p><blockquote><p>如果下面的教程有错误之处，请在评论区留言，收到后，我会尽快修改，谢谢支持！</p></blockquote><h2 id="一-博客环境搭建"><a class="markdownIt-Anchor" href="#一-博客环境搭建"></a> 一、博客环境搭建</h2><blockquote><p>本文系统环境信息：Win10专业版，64位（10.0 版本18362）</p><p>Node.js：12.13.0 Git：2.24.0</p><p>修改配置文件要用到的软件（可选）：</p><ul><li>Visual Studio Code（适合有开发基础的程序员，非常好用）</li><li>Sublime Text3，可免费使用。</li><li>NodePad++ 7.8.1（最新的，也可以在官网选择其他版本）</li></ul></blockquote><h3 id="1下载git和nodejs"><a class="markdownIt-Anchor" href="#1下载git和nodejs"></a> 1.下载Git和Node.js</h3><h4 id="11-nodejs的安装与配置"><a class="markdownIt-Anchor" href="#11-nodejs的安装与配置"></a> 1.1 Node.js的安装与配置</h4><p>首先去<a href="https://nodejs.org/en/download/">Node.js官网 </a>下载node.js的安装程序，根据你电脑系统的配置信息，下载对应的安装程序，然后开始进行下面的步骤。</p><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200604161523.png" alt="Node.js下载以及版本的选择"></p><p>下载好与电脑系统对应的安装程序后，开始安装流程：</p><ol><li>打开下载好的Node.js安装程序，点击Next，进行下一步的安装；</li></ol><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200604162048.png" alt=""></p><ol start="2"><li>将”I accept the terms in the License Agreement”前面的复选框勾选，同意安装协议，再点击Next，进行下一步操作；</li></ol><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200604162324.png" alt="node-2"></p><ol start="3"><li>选择Node.js安装程序的安装位置，在这里我以”C:\Program Files\nodejs”为例，点击Next，进入下一步操作；</li></ol><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200604162347.png" alt="node-3"></p><ol start="4"><li>选择安装的模块和功能，这里全部安装，并添加到系统环境变量 ，继续点击Next，进入下一步操作；</li></ol><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200604162428.png" alt="node-4"></p><ol start="5"><li>这一步可以跳过，这个选项的意思是安装一些编译本地模块的工具，比如python，C/C++等，点击Next，进入下一步；</li></ol><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200604162517.png" alt="node-5"></p><ol start="6"><li>点击”Install”，等待Node.js安装完成；</li></ol><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200604162541.png" alt="node-6"></p><ol start="7"><li>当看到下图所显示的情况，Node.js就成功安装完毕。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200604162601.png" alt="node-7"></p><ol start="8"><li>验证安装，并测试Node.js是否加入环境变量，当出现如下图的情况，Node.js安装大功告成。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200604163219.png" alt=""></p><p>如果执行<strong>node -v</strong>报错的话，那么手动将Node.js的安装路径添加到环境变量中，右击点击我的电脑 -&gt;属性 -&gt; 高级系统设置 -&gt; 环境变量，在系统变量下找到名为path的变量名，如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200604164051.png" alt=""></p><p>选中path，或者双击，然后将你node.js的安装路径放在path变量值的最后面，如果添加之前path值最后有 英文的分号，则直接将路径添加进去即可，如果没有，先添加分号，然后点击保存，回到桌面，打开cmd（Win+R），执行node -v，看是否成功。</p><ol start="9"><li>设置npm的镜像源：</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"># 查看npm的配置</span><br><span class="line">npm config list</span><br><span class="line"># 默认源</span><br><span class="line">npm config set registry https://registry.npmjs.org</span><br><span class="line"># 临时改变镜像源</span><br><span class="line">npm --registry=https://registry.npm.taobao.org</span><br><span class="line"># 永久设置为淘宝镜像源</span><br><span class="line">npm config set registry https://registry.npm.taobao.org</span><br><span class="line"># 另一种方式，编辑 ~/.npmrc 加入下面内容</span><br><span class="line">registry = https://registry.npm.taobao.org</span><br></pre></td></tr></tbody></table></figure><ol start="10"><li><p>设置npm的内置路径——&gt;全局模块路径和缓存路径（可选）</p><p>如果不改变内置路径也可，除非你的C盘空间足够bigger，这一步可以略过，不改变的话，它的路径在：</p></li></ol><blockquote><p>此处参考：jyjin的node环境变量配置，npm环境变量配置</p></blockquote><ul><li>npm包全局目录：</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">C:/Users/[username]/AppData/Roaming/npm/node_modules</span><br></pre></td></tr></tbody></table></figure><ul><li>npm包全局命令目录：</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">C:/Users/[username]/AppData/Roaming/npm</span><br></pre></td></tr></tbody></table></figure><ul><li><p>npm实际去找全局命令的目录：C:/Users/[username]/.npmrc 文件内容的prefix值</p></li><li><p>npm包全局cache目录：C:/Users/[username]/.npmrc 文件内容的cache值</p><p>首先在你Node.js的安装位置，新建两个文件夹，node_global和node_cache，我的路径是：</p></li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">C:\Program Files\nodejs\node_global</span><br><span class="line">C:\Program Files\nodejs\node_cache</span><br></pre></td></tr></tbody></table></figure><p>然后分别执行的命令就是：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">npm config set prefix"C:\Program Files\nodejs\node_global"</span><br><span class="line">npm config set cache "C:\Program Files\nodejs\node_cache"</span><br></pre></td></tr></tbody></table></figure><p>然后在配置环境变量，右击我的电脑 -&gt;属性 -&gt; 高级系统设置 -&gt; 环境变量同样的位置，在用户变量的地方，找到path变量进行修改，修改值如下图：</p><p><img src="dn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200604165230.png" alt="修改环境变量"></p><p>然后就大功告成了，Node.js就安装完毕了，下面开始Git安装。👇👇👇</p><h3 id="12-git的安装与配置"><a class="markdownIt-Anchor" href="#12-git的安装与配置"></a> 1.2 Git的安装与配置</h3><p>首先就是去<a href="https://git-scm.com/">Git官网</a>Git，根据你电脑系统的配置信息，下载对应的安装程序，然后开始进行下面的步骤。</p><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200604165831.png" alt=""></p><ol><li>Git的安装包，开始安装，打开安装包，出现如图的界面，点击Next：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200604170117.png" alt=""></p><ol start="2"><li>选择你要安装的位置，我以C盘为例，路径为图中所示，安装到其他位置的话，点击Browse，选择你要安装的位置，然后点击Next，进入下一步：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200604170241.png" alt=""></p><ol start="3"><li>选择你是否创建桌面快捷放方式，其他默认即可，点击Next，进入下一步：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200604170513.png" alt=""></p><ol start="4"><li>是否将Git快捷方式的目录加入开是菜单栏</li></ol><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200604170556.png" alt=""></p><ol start="5"><li>这个是选择文本编辑器的方式，默认是Vim，也可以选择其他的方式，自主选择，在这里我选择的Vim默认方式。选择好文本编辑器的方式后，点击Next，进入下一个流程：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200604170635.png" alt=""></p><ol start="6"><li>选择安装 Git 时对环境变量PATH的影响，第一种影响较小，第三种会影响到Windows的自带工具，默认勾选中间项，建议不要修改，直接点击 “Next” 继续安装：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200604170819.png" alt=""></p><ol start="7"><li>选择 Git 在使用 HTTPS 时使用的库，若无特殊需求，可保持默认选项，点击 “Next” 继续安装：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200604170859.png" alt=""></p><ol start="8"><li>选择提交与拉取记录时，对换行符的处理方式，若无特殊需要，默认选择即可，点击 “Next” 继续安装：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200604171147.png" alt=""></p><ol start="9"><li>选择模拟终端软件（即命令行窗口软件），若无特殊需要，可默认选择，点击 “Next” 继续安装：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200604171349.png" alt=""></p><ol start="10"><li>最新功能的询问，若不想尝试尚未保证稳定性的新功能，默认不勾选，点击 “Install” 即可完成安装：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200604171614.png" alt=""></p><ol start="11"><li>安装完成</li></ol><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200604171703.png" alt=""></p><ol start="12"><li>回到桌面，点击鼠标右键，会出现两个选项<strong>Git GUI Here</strong>和<strong>Git Bash Here</strong>，在打开Cmd(Win+R)，分别输入<strong>git</strong>和<strong>git --version</strong>，如果出现如下图的情况，即安装成功！</li></ol><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200604171914.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200604172330.png" alt=""></p><h2 id="二-github注册以及github-pages创建"><a class="markdownIt-Anchor" href="#二-github注册以及github-pages创建"></a> 二、Github注册以及Github Pages创建</h2><ol><li>打开Github官网首页，点击右上角的Sign Up ，然后在出现的页面上填写你的相关信息，进行注册：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200604172648.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200604173057.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200604173102.png" alt=""></p><p>验证完成后，点击Next：Select a plan，会出现如上图的验证界面，同理，只需要将其中的动物调整为正向显示即可。接着会出现下图的界面，选择Free，下方的两个选项可选可不选，点击Continue继续：</p><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200604173207.png" alt=""></p><p>这时Github会给你发一封邮件，验证一下即可，验证过后才可以创建库。</p><p>验证完成后，开始创建库，如下图所示，仓库名创建格式必须为：<strong>&lt;用户名&gt;.github.io</strong>，<strong>Description</strong>为描述仓库，自定义写，填写必要的描述，也可不填。勾选<strong>Initialize this repository with a README</strong>点击<strong>Creat repository</strong>进行创建。</p><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200604173422.png" alt=""></p><p>然后就会出现如图所示的界面，即仓库创建成功！</p><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200604173520.png" alt=""></p><p>我们来测试一下，点击<strong>Create new file</strong>，出现如下界面，然后命名文件名为<strong>index.html</strong>，在填写如图的内容，再点击<strong>Commit new file</strong>，即创建成功，然后打开一个新的网页，输入网址<strong>https://&lt;你的用户名&gt;.github.io</strong>，即可以看见一个新的网页，其中的内容就是你写的内容。</p><p>至此，Github的注册以及Github Pages已经创建完成了。</p><h2 id="三-配置git用户名和邮箱"><a class="markdownIt-Anchor" href="#三-配置git用户名和邮箱"></a> 三、配置Git用户名和邮箱</h2><p>在桌面点击鼠标右键，点击<strong>Git Bash Here</strong>，会出现一个界面如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200604174430.png" alt=""></p><p>然后分别输入下面的两个命令，并回车：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">git config --global user.name "此处填写你注册时的用户名"</span><br><span class="line">git config --global user.email "此处填写你注册时的邮箱"</span><br><span class="line"># 一般只要不报错，可以跳过下面寻找.gitconfig文件</span><br></pre></td></tr></tbody></table></figure><p>然后找到**.gitconfig<strong>文件，文件存放位置在</strong>C:/Users/[username]/.gitconfig**（未找到的话，请开启显示隐藏文件的功能），用编辑器打开，看到如下图所示的内容，即配置成功！</p><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200604174606.png" alt=""></p><h2 id="四-本地安装hexo静态博客框架以及发布到github-pages"><a class="markdownIt-Anchor" href="#四-本地安装hexo静态博客框架以及发布到github-pages"></a> 四、本地安装hexo静态博客框架以及发布到Github Pages</h2><p>首先选择一个磁盘作为你博客文件的存放位置，然后新建一个文件夹，比如名为blogtest的文件夹，创建完后，先不要点进去，在此处点击鼠标右键，选择Git Bash Here，然后依次输入如下命令，：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"># hexo框架的安装</span><br><span class="line">npm install -g hexo-cli</span><br><span class="line"># 等上一个命令完成后，在输入下面的命令</span><br><span class="line">hexo init &lt;新建文件夹的名称&gt;  #初始化文件夹</span><br><span class="line">cd &lt;新建文件夹的名称&gt;</span><br><span class="line">npm install  # 安装博客所需要的依赖文件</span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200604174748.png" alt=""></p><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200604174754.png" alt=""></p><p>等待运行完成，此时文件夹中多了许多文件。 注意：后续的命令均需要在站点目录下（即文件夹内）使用Git Bash运行。 此时Hexo框架的本地搭建已经完成了。我们来运行一下看看，命令行依次输入以下命令 :</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200604175038.png" alt=""></p><p>浏览器中打开http://locakhost:4000或者127.0.0.1:4000，可以看到一个网页，说明Hexo博客已经成功在本地运行。</p><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200604175042.png" alt=""></p><h3 id="本地博客发布到github-pages"><a class="markdownIt-Anchor" href="#本地博客发布到github-pages"></a> 本地博客发布到Github Pages</h3><p>之前的步骤中，我们已经完成了对Github账户的注册以及Github Pages的创建，接下来是将本地博客发布至Github Pages。</p><ol><li>首先需要安装发布的插件，在站点目录下执行下面的命令，也就是创建的博客目录下：</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>紧接着，将本地目录与GitHub关联起来，输入下面的命令行：</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C "你的邮箱地址"</span><br></pre></td></tr></tbody></table></figure><p>输入后一直回车，然后在<strong>C:/Users/[username]<strong>目录下找到名为</strong>.ssh</strong>的文件夹， 文件夹内会有两个文件，一个<strong>id_rsa.pub</strong>一个<strong>id_rsa</strong>，用文本编辑器打开id_rsa.pub，复制里面的的内容。 然后打开Github，点击右上角的头像 Settings 选择SSH and GPG keys</p><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200604222057.png" alt=""></p><p>点击New SSH key 将之前复制的内容粘帖到Key的框中。 上面的Title可以随意，点击Add SSH key 完成添加。</p><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200604222136.png" alt=""></p><p>然后回到Git的命令行界面，测试一下是否与GitHub连接成功。输入下面的命令行：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></tbody></table></figure><p>点击回车，然后会出现一个询问内容，输入yes，回车，会出现一段内容，Hi ! You’ve successfully authenticated, but GitHub doesnot provide shell access.。 说明连接成功。此处这个``应该是你Github的用户名。</p><ol start="3"><li>进入博客站点目录，用文本编辑器打开<strong>config.yml</strong>， <strong>config.yml</strong>是博客的配置文件，在以后的博客修改，如个性化修改，博客SEO优化等都会使用到，修改如下图的几个地方：</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">title: 你的博客名</span><br><span class="line">subtitle: 博客的副标题，有些主题支持</span><br><span class="line">description: 博客描述</span><br><span class="line">keywords: 博客关键词</span><br><span class="line">author: 作者，在文章中显示</span><br><span class="line">language: 博客语言语种   </span><br><span class="line">timezone: 时区</span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200604222505.png" alt=""></p><p>滑到文件最底部，有一个deploy，在deploy下面添加一个repo项 ，一个branch项。填入如下代码，并如下图所示：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">type: git</span><br><span class="line">repo: git@github.com:Github用户名/github用户名.github.io.git  </span><br><span class="line">//也可使用https地址，如：https://github.com/Github用户名/Github用户名.github.io.git            </span><br><span class="line">branch: master</span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200604223045.png" alt=""></p><ol start="4"><li>最后就是生成页面，并发布至Github Pages，执行如下命令：</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"># Hexo会根据配置文件渲染出一套静态页面</span><br><span class="line">hexo g</span><br><span class="line"># 将上一步渲染出的一系列文件上传至至Github Pages</span><br><span class="line">hexo d</span><br><span class="line"># 也可以直接输入此命令，直接完成渲染和上传</span><br><span class="line">hexo g -d</span><br></pre></td></tr></tbody></table></figure><p>上传完成后，在浏览器中打开https://&lt;用户名&gt;.github.io，查看上传的网页。如果页面变成了之前本地调试时的样子，说明上传以及完成了。没变的话查看一下上传时命令行窗口的信息有没有错误信息，没有的话清除一下浏览器缓存试试。</p><h2 id="五-hexo博客主题安装以及一些个性化修改"><a class="markdownIt-Anchor" href="#五-hexo博客主题安装以及一些个性化修改"></a> 五、hexo博客主题安装以及一些个性化修改</h2><h3 id="主题特性"><a class="markdownIt-Anchor" href="#主题特性"></a> 主题特性</h3><ul><li>简单漂亮，文章内容美观易读</li><li>Material Design 设计</li><li>响应式设计，博客在桌面端、平板、手机等设备上均能很好的展现</li><li>首页轮播文章及每天动态切换 Banner 图片</li><li>瀑布流式的博客文章列表（文章无特色图片时会有 24 张漂亮的图片代替）</li><li>时间轴式的归档页</li><li>词云的标签页和雷达图的分类页</li><li>丰富的关于我页面（包括关于我、文章统计图、我的项目、我的技能、相册等）</li><li>可自定义的数据的友情链接页面</li><li>支持文章置顶和文章打赏</li><li>支持 MathJax</li><li>TOC 目录</li><li>可设置复制文章内容时追加版权信息</li><li>可设置阅读文章时做密码验证</li><li>Gitalk、Gitment、Valine 和 Disqus 评论模块（推荐使用 Gitalk）</li><li>集成了不蒜子统计、谷歌分析（Google Analytics）和文章字数统计等功能</li><li>支持在首页的音乐播放和视频播放功能</li><li>支持emoji表情，用markdown emoji语法书写直接生成对应的能跳跃的表情。</li><li>支持 DaoVoice、Tidio 在线聊天功能。</li></ul><h3 id="1-主题下载与安装"><a class="markdownIt-Anchor" href="#1-主题下载与安装"></a> 1. 主题下载与安装</h3><p>点击 <a href="https://github.com/blinkfox/hexo-theme-matery">传送门</a> 下载 master 分支的最新稳定版的代码，解压缩后，将 hexo-theme-matery 的文件夹复制到你 Hexo 的 themes 文件夹中即可。</p><p>当然你也可以在你的站点目录文件夹下使用 git clone 命令来下载：直接在站点根目录下执行下面的命令，即可进行主题的下载，主题有两个版本，稳定版本和最新版本(不定期更新优化)，自主选择版本。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">git clone https://github.com/blinkfox/hexo-theme-matery themes/matery     # 稳定版</span><br><span class="line">git clone -b develop https://github.com/blinkfox/hexo-theme-matery themes/matery   #最新版(不定期进行优化更新)</span><br></pre></td></tr></tbody></table></figure><h3 id="2-主题配置"><a class="markdownIt-Anchor" href="#2-主题配置"></a> 2. 主题配置</h3><h4 id="21-切换主题"><a class="markdownIt-Anchor" href="#21-切换主题"></a> 2.1 切换主题</h4><blockquote><p>注意：首先需要明白什么是站点配置文件，什么是主题配置文件，站点配置文件就是根目录下的配置文件，比如我的博客文件在<strong>F:\blog</strong>下，那么站点配置文件就是<strong>F:\blog_config.yml</strong>，主题配置文件就是<strong>F:\blog\themes\matery_config.yml</strong></p><p>另外注意，配置文件中的标点符号不要出现中文格式的标点符号，不然运行会出错。</p></blockquote><p>主题下载完成后，将站点配置文件中的<strong>theme</strong>值修改为你下载主题的文件名，此处为matery，那么值就修改为theme: matery。</p><p>一些站点配置文件的其他地方的修改：</p><ul><li>语言选择：如果为中文用户，则在language:后添加值zh-CN，如果不修改，默认为英语；</li><li>网址修改：url:的值为你的网址名，如<strong><a href="http://xxxx.github.io">http://xxxx.github.io</a></strong>，如果有域名，则修改为你的域名即可，至于有关域名的修改解析，后面我会说到，这里先不说了。</li><li>站点配置文件有个per_page属性，建议修改为6的倍数，这样网站在适应设备时，有较好的显示效果。</li></ul><h4 id="22-新建标签-tags-页面"><a class="markdownIt-Anchor" href="#22-新建标签-tags-页面"></a> 2.2 新建标签 tags 页面</h4><p><strong>tages</strong> 页是用来展示所有标签的页面，如果在你的博客<strong>source</strong>目录下还没有<strong>tags/index.md</strong>文件，那么你就需要新建一个，命令如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">hexo new page "tags"</span><br></pre></td></tr></tbody></table></figure><p>编辑你刚刚新建的页面文件 <strong>/source/tags/index.md</strong>，至少需要以下内容：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2020-05-1 18:23:38</span><br><span class="line">type: "tags"</span><br><span class="line">layout: "tags"</span><br><span class="line">---</span><br></pre></td></tr></tbody></table></figure><h4 id="23-新建分类-categories-页面"><a class="markdownIt-Anchor" href="#23-新建分类-categories-页面"></a> 2.3 新建分类 categories 页面</h4><p><strong>categories</strong>页是用来展示所有分类的页面，如果在你的博客<strong>source</strong>目录下还没有<strong>categories/index.md</strong>文件，那么你就需要新建一个，命令如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">hexo new page "categories"</span><br></pre></td></tr></tbody></table></figure><p>编辑你刚刚新建的页面文件 <strong>/source/categories/index.md</strong>，至少需要以下内容：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2020-05-1  17:25:30</span><br><span class="line">type: "categories"</span><br><span class="line">layout: "categories"</span><br><span class="line">---</span><br></pre></td></tr></tbody></table></figure><h4 id="24-新建关于我-about-页面"><a class="markdownIt-Anchor" href="#24-新建关于我-about-页面"></a> 2.4 新建关于我 about 页面</h4><p><strong>about</strong> 页是用来展示关于我和我的博客信息的页面，如果在你的博客<strong>source</strong>目录下还没有<strong>about/index.md</strong>文件，那么你就需要新建一个，命令如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">hexo new page "about"</span><br></pre></td></tr></tbody></table></figure><p>编辑你刚刚新建的页面文件 <strong>/source/about/index.md</strong>，至少需要以下内容：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2020-05-1  17:25:30</span><br><span class="line">type: "categories"</span><br><span class="line">layout: "categories"</span><br><span class="line">---</span><br></pre></td></tr></tbody></table></figure><h4 id="25-新建留言板-contact-页面-可选"><a class="markdownIt-Anchor" href="#25-新建留言板-contact-页面-可选"></a> 2.5 新建留言板 contact 页面 (可选)</h4><p><strong>contact</strong>页是用来展示留言板信息的页面，如果在你的博客<strong>source</strong>目录下还没有<strong>contact/index.md</strong>文件，那么你就需要新建一个，命令如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">hexo new page "contact"</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>编辑你刚刚新建的页面文件**/source/contact/index.md**，至少需要以下内容：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: contact</span><br><span class="line">date: 2020-05-1  17:25:30</span><br><span class="line">type: "contact"</span><br><span class="line">layout: "contact"</span><br><span class="line">---</span><br></pre></td></tr></tbody></table></figure><blockquote><p>注：本留言板功能依赖于第三方评论系统，请激活你的评论系统才有效果。并且在主题的 <strong>_config.yml</strong>文件中，第 19 至 21 行的“菜单”配置，取消关于留言板的注释即可。</p></blockquote><h4 id="26-新建友情链接-friends-页面-可选"><a class="markdownIt-Anchor" href="#26-新建友情链接-friends-页面-可选"></a> 2.6 新建友情链接 friends 页面 (可选)</h4><p><strong>friends</strong>页是用来展示友情链接信息的页面，如果在你的博客<strong>source</strong>目录下还没有<strong>friends/index.md</strong>文件，那么你就需要新建一个，命令如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">hexo new page "friends"</span><br></pre></td></tr></tbody></table></figure><p>编辑你刚刚新建的页面文件 <strong>/source/friends/index.md</strong>，至少需要以下内容：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: friends</span><br><span class="line">date: 2020-05-1  21:25:30</span><br><span class="line">type: "friends"</span><br><span class="line">layout: "friends"</span><br><span class="line">---</span><br></pre></td></tr></tbody></table></figure><p>同时，在你的博客<strong>source</strong>目录下新建<strong>data</strong>目录，在 <strong>data</strong> 目录中新建 <strong>friends.json</strong>文件，文件内容如下所示：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">[{</span><br><span class="line">    "avatar": "http://image.luokangyuan.com/1_qq_27922023.jpg",</span><br><span class="line">    "name": "码酱",</span><br><span class="line">    "introduction": "我不是大佬，只是在追寻大佬的脚步",</span><br><span class="line">    "url": "http://luokangyuan.com/",</span><br><span class="line">    "title": "前去学习"</span><br><span class="line">}, {</span><br><span class="line">    "avatar": "http://image.luokangyuan.com/4027734.jpeg",</span><br><span class="line">    "name": "闪烁之狐",</span><br><span class="line">    "introduction": "编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬",</span><br><span class="line">    "url": "https://blinkfox.github.io/",</span><br><span class="line">    "title": "前去学习"</span><br><span class="line">}, {</span><br><span class="line">    "avatar": "http://image.luokangyuan.com/avatar.jpg",</span><br><span class="line">    "name": "ja_rome",</span><br><span class="line">    "introduction": "平凡的脚步也可以走出伟大的行程",</span><br><span class="line">    "url": "https://me.csdn.net/jlh912008548",</span><br><span class="line">    "title": "前去学习"</span><br><span class="line">}]</span><br></pre></td></tr></tbody></table></figure><h4 id="27-菜单导航配置"><a class="markdownIt-Anchor" href="#27-菜单导航配置"></a> 2.7 菜单导航配置</h4><h5 id="271-配置基本菜单导航的名称-路径url和图标icon"><a class="markdownIt-Anchor" href="#271-配置基本菜单导航的名称-路径url和图标icon"></a> 2.7.1. 配置基本菜单导航的名称、路径url和图标icon.</h5><ul><li>菜单导航名称可以是中文也可以是英文(如：Index或主页)</li><li>图标icon 可以在<a href="https://fontawesome.com/icons">Font Awesome</a> 中查找</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  Index:</span><br><span class="line">    url: /</span><br><span class="line">    icon: fas fa-home</span><br><span class="line">  Tags:</span><br><span class="line">    url: /tags</span><br><span class="line">    icon: fas fa-tags</span><br><span class="line">  Categories:</span><br><span class="line">    url: /categories</span><br><span class="line">    icon: fas fa-bookmark</span><br><span class="line">  Archives:</span><br><span class="line">    url: /archives</span><br><span class="line">    icon: fas fa-archive</span><br><span class="line">  About:</span><br><span class="line">    url: /about</span><br><span class="line">    icon: fas fa-user-circle</span><br><span class="line">  Friends:</span><br><span class="line">    url: /friends</span><br><span class="line">    icon: fas fa-address-book</span><br></pre></td></tr></tbody></table></figure><h5 id="272-二级菜单配置方法"><a class="markdownIt-Anchor" href="#272-二级菜单配置方法"></a> 2.7.2. 二级菜单配置方法</h5><p>如果你需要二级菜单则可以在原基本菜单导航的基础上如下操作</p><ul><li>在需要添加二级菜单的一级菜单下添加children关键字(如:About菜单下添加children)</li><li>在children下创建二级菜单的 名称name,路径url和图标icon.</li><li>注意每个二级菜单模块前要加 -.</li><li>注意缩进格式</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  Index:</span><br><span class="line">    url: /</span><br><span class="line">    icon: fas fa-home</span><br><span class="line">  Tags:</span><br><span class="line">    url: /tags</span><br><span class="line">    icon: fas fa-tags</span><br><span class="line">  Categories:</span><br><span class="line">    url: /categories</span><br><span class="line">    icon: fas fa-bookmark</span><br><span class="line">  Archives:</span><br><span class="line">    url: /archives</span><br><span class="line">    icon: fas fa-archive</span><br><span class="line">  About:</span><br><span class="line">    url: /about</span><br><span class="line">    icon: fas fa-user-circle-o</span><br><span class="line">  Friends:</span><br><span class="line">    url: /friends</span><br><span class="line">    icon: fas fa-address-book</span><br><span class="line">  Medias:</span><br><span class="line">    icon: fas fa-list</span><br><span class="line">    children:</span><br><span class="line">      - name: Musics</span><br><span class="line">        url: /musics</span><br><span class="line">        icon: fas fa-music</span><br><span class="line">      - name: Movies</span><br><span class="line">        url: /movies</span><br><span class="line">        icon: fas fa-film</span><br><span class="line">      - name: Books</span><br><span class="line">        url: /books</span><br><span class="line">        icon: fas fa-book</span><br><span class="line">      - name: Galleries</span><br><span class="line">        url: /galleries</span><br><span class="line">        icon: fas fa-image</span><br></pre></td></tr></tbody></table></figure><h4 id="28-添加emoji表情支持可选的"><a class="markdownIt-Anchor" href="#28-添加emoji表情支持可选的"></a> 2.8 添加emoji表情支持（可选的）</h4><p>本主题新增了对<strong>emoji</strong>表情的支持，使用到了<a href="https://developer.aliyun.com/mirror/npm/package/hexo-filter-github-emojis"> hexo-filter-github-emojis </a>的 Hexo 插件来支持 <strong>emoji</strong>表情的生成，把对应的<strong>markdown emoji</strong>语法（<strong>::</strong>,例如：<strong>😄</strong>）转变成会跳跃的<strong>emoji</strong>表情，安装命令如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">npm install hexo-filter-github-emojis --save</span><br></pre></td></tr></tbody></table></figure><p>在 Hexo 根目录下的 <strong>config.yml</strong>文件中，新增以下的配置项：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">githubEmojis:</span><br><span class="line">  enable: true</span><br><span class="line">  className: github-emoji</span><br><span class="line">  inject: true</span><br><span class="line">  styles:</span><br><span class="line">  customEmojis:</span><br></pre></td></tr></tbody></table></figure><p>执行 <strong>hexo clean &amp;&amp; hexo g</strong> 重新生成博客文件，然后就可以在文章中对应位置看到你用<strong>emoji</strong>语法写的表情了。</p><h4 id="29-代码高亮"><a class="markdownIt-Anchor" href="#29-代码高亮"></a> 2.9 代码高亮</h4><p>由于 Hexo 自带的代码高亮主题显示不好看，所以主题中使用到了<a href="https://github.com/ele828/hexo-prism-plugin">hexo-prism-plugin</a> 的 Hexo 插件来做代码高亮，安装命令如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">npm i -S hexo-prism-plugin</span><br></pre></td></tr></tbody></table></figure><p>然后，修改 Hexo 根目录下 <strong>config.yml</strong>文件中<strong>highlight.enable</strong>的值为 false，并新增<strong>prism</strong>插件相关的配置，主要配置如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">prism_plugin:</span><br><span class="line">  mode: 'preprocess'    # realtime/preprocess</span><br><span class="line">  theme: 'tomorrow'</span><br><span class="line">  line_number: false    # default false</span><br><span class="line">  custom_css:</span><br></pre></td></tr></tbody></table></figure><h4 id="210-搜索"><a class="markdownIt-Anchor" href="#210-搜索"></a> 2.10 搜索</h4><p>本主题中还使用到了 <a href="https://github.com/wzpan/hexo-generator-search">hexo-generator-search</a> 的 Hexo 插件来做内容搜索，安装命令如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br></pre></td></tr></tbody></table></figure><p>在 Hexo 根目录下的<strong>config.yml</strong>文件中，新增以下的配置项：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br></pre></td></tr></tbody></table></figure><h4 id="211-中文链接转拼音可选的"><a class="markdownIt-Anchor" href="#211-中文链接转拼音可选的"></a> 2.11 中文链接转拼音（可选的）</h4><p>如果你的文章名称是中文的，那么 Hexo 默认生成的永久链接也会有中文，这样不利于 <strong>SEO</strong>，且 <strong>gitment</strong>评论对中文链接也不支持。我们可以用 <a href="https://github.com/viko16/hexo-permalink-pinyin">hexo-permalink-pinyin Hexo </a>插件使在生成文章时生成中文拼音的永久链接。</p><p>安装命令如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">npm i hexo-permalink-pinyin --save</span><br></pre></td></tr></tbody></table></figure><p>在 Hexo 根目录下的 **_config.yml **文件中，新增以下的配置项：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">permalink_pinyin:</span><br><span class="line">  enable: true</span><br><span class="line">  separator: '-' # default: '-'</span><br></pre></td></tr></tbody></table></figure><blockquote><p>注：除了此插件外，<a href="https://github.com/rozbo/hexo-abbrlink">hexo-abbrlink </a>插件也可以生成非中文的链接。</p></blockquote><h4 id="212-文章字数统计插件可选的"><a class="markdownIt-Anchor" href="#212-文章字数统计插件可选的"></a> 2.12 文章字数统计插件（可选的）</h4><p>如果你想要在文章中显示文章字数、阅读时长信息，可以安装 <a href="https://github.com/willin/hexo-wordcount">hexo-wordcount</a>插件。</p><p>安装命令如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">i --save hexo-wordcount</span><br></pre></td></tr></tbody></table></figure><p>然后只需在本主题下的 <strong>config.yml</strong> 文件中，激活以下配置项即可：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">wordCount:</span><br><span class="line">  enable: false # 将这个值设置为 true 即可.</span><br><span class="line">  postWordCount: true</span><br><span class="line">  min2read: true</span><br><span class="line">  totalCount: true</span><br></pre></td></tr></tbody></table></figure><h4 id="213-添加-rss-订阅支持可选的"><a class="markdownIt-Anchor" href="#213-添加-rss-订阅支持可选的"></a> 2.13 添加 RSS 订阅支持（可选的）</h4><p>本主题中还使用到了 <a href="https://github.com/hexojs/hexo-generator-feed">hexo-generator-feed</a> 的 Hexo 插件来做 RSS，安装命令如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">npm install hexo-generator-feed --save</span><br></pre></td></tr></tbody></table></figure><p>在 Hexo 根目录下的 <strong>config.yml</strong> 文件中，新增以下的配置项：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">feed:</span><br><span class="line">  type: atom</span><br><span class="line">  path: atom.xml</span><br><span class="line">  limit: 20</span><br><span class="line">  hub:</span><br><span class="line">  content:</span><br><span class="line">  content_limit: 140</span><br><span class="line">  content_limit_delim: ' '</span><br><span class="line">  order_by: -date</span><br></pre></td></tr></tbody></table></figure><p>执行<strong>hexo clean &amp;&amp; hexo g</strong>重新生成博客文件，然后在<strong>public</strong>文件夹中即可看到 <strong>atom.xml</strong>文件，说明你已经安装成功了。</p><h4 id="214-添加-daovoice-在线聊天功能可选的"><a class="markdownIt-Anchor" href="#214-添加-daovoice-在线聊天功能可选的"></a> 2.14 添加 DaoVoice 在线聊天功能（可选的）</h4><p>前往 <a href="http://www.daovoice.io">DaoVoice</a>官网注册并且获取 app_id，并将 app_id 填入主题的 <strong>config.yml</strong>文件中</p><h4 id="215-添加-tidio-在线聊天功能可选的"><a class="markdownIt-Anchor" href="#215-添加-tidio-在线聊天功能可选的"></a> 2.15 添加 Tidio 在线聊天功能（可选的）</h4><p>前往 Tidio 官网注册并且获取 Public Key，并将 Public Key 填入主题的 <strong>config.yml</strong>文件中。</p><h4 id="216-修改页脚"><a class="markdownIt-Anchor" href="#216-修改页脚"></a> 2.16 修改页脚</h4><p>页脚信息可能需要做定制化修改，而且它不便于做成配置信息，所以可能需要你自己去再修改和加工。修改的地方在主题文件的 <strong>/layout/_partial/footer.ejs</strong>文件中，包括站点、使用的主题、访问量等。</p><h4 id="217-修改社交链接"><a class="markdownIt-Anchor" href="#217-修改社交链接"></a> 2.17 修改社交链接</h4><p>在主题的<strong>config.yml</strong>文件中，默认支持 <strong>QQ</strong>、<strong>GitHub</strong>和邮箱等的配置，你可以在主题文件的 <strong>/layout/_partial/social-link.ejs</strong> 文件中，新增、修改你需要的社交链接地址，增加链接可参考如下代码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;% if (theme.socialLink.github) { %&gt;</span><br><span class="line">    &lt;a href="&lt;%= theme.socialLink.github %&gt;" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50"&gt;</span><br><span class="line">        &lt;i class="fab fa-github"&gt;&lt;/i&gt;</span><br><span class="line">    &lt;/a&gt;</span><br><span class="line">&lt;% } %&gt;</span><br></pre></td></tr></tbody></table></figure><p>其中，社交图标（如：<strong>fa-github</strong>）你可以在 <a href="https://fontawesome.com/icons">Font Awesome</a>中搜索找到。以下是常用社交图标的标识，供你参考：</p><ul><li>Facebook: fab fa-facebook</li><li>Twitter: fab fa-twitter</li><li>Google-plus: fab fa-google-plus</li><li>Linkedin: fab fa-linkedin</li><li>Tumblr: fab fa-tumblr</li><li>Medium: fab fa-medium</li><li>Slack: fab fa-slack</li><li>Sina Weibo: fab fa-weibo</li><li>Wechat: fab fa-weixin</li><li>QQ: fab fa-qq</li><li>Zhihu: fab fa-zhihu</li></ul><blockquote><p>注意: 本主题中使用的 <strong>Font Awesome</strong> 版本为 <strong>5.11.0</strong>。</p></blockquote><h4 id="218-修改打赏的二维码图片"><a class="markdownIt-Anchor" href="#218-修改打赏的二维码图片"></a> 2.18 修改打赏的二维码图片</h4><p>在主题文件的<strong>source/medias/reward</strong>文件中，你可以替换成你的的微信和支付宝的打赏二维码图片。</p><h4 id="219-配置音乐播放器可选的"><a class="markdownIt-Anchor" href="#219-配置音乐播放器可选的"></a> 2.19 配置音乐播放器（可选的）</h4><blockquote><p>新版主题支持接入第三方音乐，如QQ音乐，网易云音乐，酷狗音乐等等</p></blockquote><p>要支持音乐播放，在主题的<strong>config.yml</strong>配置文件中激活music配置即可：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"># 是否在首页显示音乐</span><br><span class="line">music:</span><br><span class="line">  enable: true</span><br><span class="line">  title:            #非吸底模式有效</span><br><span class="line">    enable: true</span><br><span class="line">    show: 听听音乐</span><br><span class="line">  server: netease   #require music platform: netease, tencent, kugou, xiami, baidu</span><br><span class="line">  type: playlist    #require song, playlist, album, search, artist</span><br><span class="line">  id: 503838841     #require song id / playlist id / album id / search keyword</span><br><span class="line">  fixed: false      # 开启吸底模式</span><br><span class="line">  autoplay: false   # 是否自动播放</span><br><span class="line">  theme: '#42b983'</span><br><span class="line">  loop: 'all'       # 音频循环播放, 可选值: 'all', 'one', 'none'</span><br><span class="line">  order: 'random'   # 音频循环顺序, 可选值: 'list', 'random'</span><br><span class="line">  preload: 'auto'   # 预加载，可选值: 'none', 'metadata', 'auto'</span><br><span class="line">  volume: 0.7       # 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效</span><br><span class="line">  listFolded: true  # 列表默认折叠</span><br></pre></td></tr></tbody></table></figure><blockquote><p>server可选netease（网易云音乐），tencent（QQ音乐），kugou（酷狗音乐），xiami（虾米音乐），baidu（百度音乐）。<br>type可选song（歌曲），playlist（歌单），album（专辑），search（搜索关键字），artist（歌手）<br>id获取示例: 浏览器打开网易云音乐，点击我喜欢的音乐歌单，地址栏有一串数字，playlist的id即为这串数字。</p></blockquote><h3 id="3-文章-front-matter-介绍"><a class="markdownIt-Anchor" href="#3-文章-front-matter-介绍"></a> 3. 文章 Front-matter 介绍</h3><h4 id="front-matter-选项详解"><a class="markdownIt-Anchor" href="#front-matter-选项详解"></a> Front-matter 选项详解</h4><p><strong>Front-matter</strong>选项中的所有内容均为<strong>非必填</strong>的。但我仍然建议至少填写 title 和 date 的值。</p><table><thead><tr><th>配置选项</th><th>默认值</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td>title</td><td>Markdown 的文件标题</td><td style="text-align:left">文章标题，强烈建议填写此选项</td></tr><tr><td>date</td><td>文件创建时的日期时间</td><td style="text-align:left">发布时间，强烈建议填写此选项，且最好保证全局唯一</td></tr><tr><td>author</td><td>根 _config.yml 中的 author</td><td style="text-align:left">文章作者</td></tr><tr><td>img</td><td>featureImages 中的某个值</td><td style="text-align:left">文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径。如: <a href="http://xxx.com/xxx.jpg">http://xxx.com/xxx.jpg</a></td></tr><tr><td>top</td><td>true</td><td style="text-align:left">推荐文章（文章是否置顶），如果 top 值为 true，则会作为首页推荐文章</td></tr><tr><td>cover</td><td>false</td><td style="text-align:left">v1.0.2版本新增，表示该文章是否需要加入到首页轮播封面中</td></tr><tr><td>coverImg</td><td>无</td><td style="text-align:left">v1.0.2版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td></tr><tr><td>password</td><td>无</td><td style="text-align:left">文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 password 的值，该值必须是用 SHA256 加密后的密码，防止被他人识破。前提是在主题的 config.yml 中激活了 verifyPassword选项</td></tr><tr><td>toc</td><td>true</td><td style="text-align:left">是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 config.yml 中激活了 toc 选项</td></tr><tr><td>mathjax</td><td>false</td><td style="text-align:left">是否开启数学公式支持 ，本文章是否开启 mathjax，且需要在主题的 _config.yml 文件中也需要开启才行</td></tr><tr><td>summary</td><td>无</td><td style="text-align:left">文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td></tr><tr><td>categories</td><td>无</td><td style="text-align:left">文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td></tr><tr><td>tags</td><td>无</td><td style="text-align:left">文章标签，一篇文章可以多个标签</td></tr><tr><td>reprintPolicy</td><td>cc_by</td><td style="text-align:left">文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个</td></tr></tbody></table><blockquote><p>注意:</p><ol><li>如果 img 属性不填写的话，文章特色图会根据文章标题的 hashcode 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章都的特色图各有特色。</li><li>date 的值尽量保证每篇文章是唯一的，因为本主题中 Gitalk 和 Gitment 识别 id 是通过 date 的值来作为唯一标识的。</li><li>如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 config.yml 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：开源中国在线工具、chahuo、站长工具。</li><li>您可以在文章md文件的 front-matter 中指定 reprintPolicy 来给单个文章配置转载规则</li></ol></blockquote><p>以下为文章的 <strong>Front-matter</strong> 示例。</p><p>最简示例</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">title: typora-vue-theme主题介绍</span><br><span class="line">date: 2018-09-07 09:25:00</span><br></pre></td></tr></tbody></table></figure><p>最全示例</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">title: typora-vue-theme主题介绍</span><br><span class="line">date: 2018-09-07 09:25:00</span><br><span class="line">author: 赵奇</span><br><span class="line">img: /source/images/xxx.jpg</span><br><span class="line">top: true</span><br><span class="line">cover: true</span><br><span class="line">coverImg: /images/1.jpg</span><br><span class="line">password: 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92</span><br><span class="line">toc: false</span><br><span class="line">mathjax: false</span><br><span class="line">summary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</span><br><span class="line">categories: Markdown</span><br><span class="line">tags:</span><br><span class="line">  - Typora</span><br><span class="line">  - Markdown</span><br><span class="line">---</span><br></pre></td></tr></tbody></table></figure><h3 id="4-效果截图"><a class="markdownIt-Anchor" href="#4-效果截图"></a> 4. 效果截图</h3><blockquote><p>最新版本进行了优化更新，效果图与最初的效果图有差别，下面的图不是最新版本的。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200605101735.png" alt="首页"></p><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200605101811.png" alt="首页推荐文章"></p><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200605101840.png" alt="首页文章列表"></p><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200605101919.png" alt="关于我页面"></p><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200605101951.png" alt="文章详情页面"></p><h3 id="5-自定制修改"><a class="markdownIt-Anchor" href="#5-自定制修改"></a> 5. 自定制修改</h3><p>在本主题的 <strong>config.yml</strong>中可以修改部分自定义信息，有以下几个部分：</p><ul><li>菜单</li><li>我的梦想</li><li>首页的音乐播放器和视频播放器配置</li><li>是否显示推荐文章名称和按钮配置</li><li>favicon 和 Logo</li><li>个人信息</li><li>TOC 目录</li><li>文章打赏信息</li><li>复制文章内容时追加版权信息</li><li>MathJax</li><li>文章字数统计、阅读时长</li><li>点击页面的’爱心’效果</li><li>我的项目</li><li>我的技能</li><li>我的相册</li><li>Gitalk、Gitment、Valine 和 disqus 评论配置</li><li>不蒜子统计和谷歌分析（Google Analytics）</li><li>默认特色图的集合。当文章没有设置特色图时，本主题会根据文章标题的 hashcode 值取余，来选择展示对应的特色图<br><strong>我认为个人博客应该都有自己的风格和特色</strong>。如果本主题中的诸多功能和主题色彩你不满意，可以在主题中自定义修改，很多更自由的功能和细节点的修改难以在主题的<strong>config.yml</strong>中完成，需要修改源代码才来完成。以下列出了可能对你有用的地方：</li></ul><h4 id="51-修改主题颜色"><a class="markdownIt-Anchor" href="#51-修改主题颜色"></a> 5.1 修改主题颜色</h4><p>在主题文件的**/source/css/matery.css<strong>文件中，搜索</strong>.bg-color** 来修改背景颜色：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">/* 整体背景颜色，包括导航、移动端的导航、页尾、标签页等的背景颜色. */</span><br><span class="line">.bg-color {</span><br><span class="line">    background-image: linear-gradient(to right, #4cbf30 0%, #0f9d58 100%);</span><br><span class="line">}</span><br><span class="line">/*如果想去掉banner图的颜色渐变效果，请将以下的css属性注释掉或者删除掉即可*/</span><br><span class="line">@-webkit-keyframes rainbow {</span><br><span class="line">   /* 动态切换背景颜色. */</span><br><span class="line">}</span><br><span class="line">@keyframes rainbow {</span><br><span class="line">    /* 动态切换背景颜色. */</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="52-修改-banner-图和文章特色图"><a class="markdownIt-Anchor" href="#52-修改-banner-图和文章特色图"></a> 5.2 修改 banner 图和文章特色图</h4><p>你可以直接在**/source/medias/banner<strong>文件夹中更换你喜欢的 <strong>banner</strong> 图片，主题代码中是每天动态切换一张，只需 7 张即可。如果你会 <strong>JavaScript</strong>代码，可以修改成你自己喜欢切换逻辑，如：随机切换等,<strong>banner</strong>切换的代码位置<br>在</strong>/layout/_partial/bg-cover-content.ejs**文件的 ``代码中：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">$('.bg-cover').css('background-image', 'url(/medias/banner/' + new Date().getDay() + '.jpg)');</span><br></pre></td></tr></tbody></table></figure><p>在 /source/medias/featureimages 文件夹中默认有 24 张特色图片，你可以再增加或者减少，并需要在 config.yml 做同步修改。</p><p>如果想改为每小时或者每分钟切换banner图的话，需要将**getDay()<strong>改为</strong>getHours()<strong>或者</strong>getMinutes()**即可。</p><h4 id="53-修改网站相关信息"><a class="markdownIt-Anchor" href="#53-修改网站相关信息"></a> 5.3 修改网站相关信息</h4><p>放上相关的配置文件信息：</p><ul><li>网站信息的修改</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">#这是根目录下的配置文件信息</span><br><span class="line">title: tlhg   #这是网站标题</span><br><span class="line">subtitle: tlhg    #这是网站副标题subtitler</span><br><span class="line"># 下面两个description,keywords，需要填上，如果想让搜索引擎收录，这个做SEO优化必不可忽视的两个属性</span><br><span class="line">description:   #网站描述</span><br><span class="line">keywords: [HTML, CSS, JavaScript, JQuery, React, Vue.js等]  #网站的关键词</span><br><span class="line">author: YangAir  #作者，文章版权所显示的</span><br><span class="line">language: zh-CN  #网站语言，不填写，默认为英文</span><br><span class="line">timezone:   #时区，可以不填写</span><br><span class="line"># 这是主题配置文件的相关信息</span><br><span class="line"># 配置网站favicon和网站LOGO</span><br><span class="line"># 此处我用的CDN，也可以使用本地文件</span><br><span class="line">favicon: #图片地址</span><br><span class="line">logo:  #图片地址</span><br><span class="line"># 网站副标题，打字效果</span><br><span class="line"># 如果有符号 ‘ ，请在 ’ 前面加上 \</span><br><span class="line">subtitle: </span><br><span class="line">  enable: true</span><br><span class="line">  loop: true # 是否循环</span><br><span class="line">  showCursor: true # 是否显示光标</span><br><span class="line">  startDelay: 300 # 开始延迟</span><br><span class="line">  typeSpeed: 100 # 打字速度</span><br><span class="line">  backSpeed: 50 # 删除速度</span><br><span class="line">  sub1: 志之所向，金石为开，谁能御之？</span><br><span class="line">  sub2: 花开不是为了花落，而是为了开的更加灿烂。</span><br><span class="line">  sub3: 没有伞的孩子必须努力奔跑！</span><br><span class="line">  sub4: 欲望以提升热忱，毅力以磨平高山。</span><br><span class="line">  sub5: 如果放弃太早，你永远都不知道自己会错过什么。</span><br><span class="line">  sub6: 没有礁石，就没有美丽的浪花；没有挫折，就没有壮丽的人生。</span><br></pre></td></tr></tbody></table></figure><p>注意：</p><p>网站打字效果副标题默认有两个，即<strong>sub1</strong>和<strong>sub2</strong>，如果想写多个，则需要修改两处地方，首先修改配置文件，如上面所示，在sub1和sub2后面继续添加即可，然后在去主题目录下的<strong>layout</strong>文件夹下的<strong>partial文件夹</strong>，修改<strong>bg-cover-content.ejs</strong>文件，大约在12行左右，如下面所示：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"> &lt;div class="description center-align"&gt;</span><br><span class="line">     &lt;% if (theme.subtitle.enable) { %&gt;</span><br><span class="line">         &lt;span id="subtitle"&gt;&lt;/span&gt;</span><br><span class="line">         &lt;script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11"&gt;&lt;/script&gt;</span><br><span class="line">        &lt;script&gt;</span><br><span class="line">            var typed = new Typed("#subtitle", {</span><br><span class="line">                strings: ['&lt;%= theme.subtitle.sub1 %&gt;',</span><br><span class="line">                          '&lt;%= theme.subtitle.sub2 %&gt;',</span><br><span class="line">                          '&lt;%= theme.subtitle.sub3 %&gt;',</span><br><span class="line">                          '&lt;%= theme.subtitle.sub4 %&gt;',</span><br><span class="line">                          '&lt;%= theme.subtitle.sub5 %&gt;',</span><br><span class="line">                          '&lt;%= theme.subtitle.sub6 %&gt;'],</span><br><span class="line">                 startDelay: &lt;%= theme.subtitle.startDelay %&gt;,</span><br><span class="line">                 typeSpeed: &lt;%= theme.subtitle.typeSpeed %&gt;,</span><br><span class="line">                 loop: &lt;%= theme.subtitle.loop %&gt;,   </span><br><span class="line">                 backSpeed: &lt;%= theme.subtitle.backSpeed %&gt;,</span><br><span class="line">                 showCursor: &lt;%= theme.subtitle.showCursor %&gt;</span><br><span class="line">              });</span><br><span class="line">          &lt;/script&gt;</span><br><span class="line">      &lt;% } else { %&gt;</span><br><span class="line">            &lt;%= config.description %&gt;</span><br><span class="line">      &lt;% } %&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></tbody></table></figure><ul><li>社交链接的修改<br>默认的配置信息为：</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"># 首页 banner 中的第二行个人信息配置，留空即不启用</span><br><span class="line">socialLink:</span><br><span class="line">  github:  https://github.com/blinkfox</span><br><span class="line">  email: 1181062873@qq.com</span><br><span class="line">  facebook: # https://www.facebook.com/xxx</span><br><span class="line">  twitter: # https://twitter.com/xxx</span><br><span class="line">  qq: 1181062873</span><br><span class="line">  weibo: # https://weibo.com/xxx</span><br><span class="line">  zhihu: # https://www.zhihu.com/xxx</span><br><span class="line">  rss: true # true、false</span><br></pre></td></tr></tbody></table></figure><p>如果想添加简书，CSDN，掘金，博客园等等，需要在主题配置文件添加相关配置，如下是我个人的配置：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">socialLink:</span><br><span class="line">  qq: 1035800145</span><br><span class="line">  weixin: https://cdn.jsdelivr.net/gh/Yafine/Yafine-imgs/images/wechat.png</span><br><span class="line">  github: https://github.com/tlhg-0</span><br><span class="line">  email: mailto:847607350@qq.com</span><br><span class="line">  facebook: # https://www.facebook.com/xxx</span><br><span class="line">  twitter: # https://twitter.com/xxx</span><br><span class="line">  weibo: # https://weibo.com/xxx</span><br><span class="line">  zhihu: #https://www.zhihu.com/people/xxx/activities</span><br><span class="line">  csdn: #https://blog.csdn.net/xxx</span><br><span class="line">  jianshu: #https://www.jianshu.com/u/xxxxxxxxx</span><br><span class="line">  cnblogs: #https://www.cnblogs.com/xxx/</span><br><span class="line">  rss: true # true、false</span><br></pre></td></tr></tbody></table></figure><p>其中的weixin我是用的图片链接，会跳转到一个新的标签页，之后还需要修改ejs文件，文件在主题目录下的<strong>layout</strong>文件夹下的<strong>partial</strong>文件夹，修改<strong>social-link.ejs</strong>，添加相关的配置，我个人添加的配置如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;% if (theme.socialLink.jianshu) { %&gt;</span><br><span class="line">    &lt;a href="&lt;%= theme.socialLink.jianshu %&gt;" class="tooltipped" target="_blank" data-tooltip="关注我的简书: &lt;%= theme.socialLink.jianshu %&gt;" data-position="top" data-delay="50"&gt;</span><br><span class="line">        &lt;i class="fab fa-jianshu"&gt;简&lt;/i&gt;</span><br><span class="line">    &lt;/a&gt;</span><br><span class="line">&lt;% } %&gt;</span><br><span class="line"></span><br><span class="line">&lt;% if (theme.socialLink.csdn) { %&gt;</span><br><span class="line">    &lt;a href="&lt;%= theme.socialLink.csdn %&gt;" class="tooltipped" target="_blank" data-tooltip="关注我的CSDN: &lt;%= theme.socialLink.csdn %&gt;" data-position="top" data-delay="50"&gt;</span><br><span class="line">        &lt;i class="fab fa-csdn"&gt;C&lt;/i&gt;</span><br><span class="line">    &lt;/a&gt;</span><br><span class="line">&lt;% } %&gt;</span><br><span class="line">&lt;% if (theme.socialLink.juejin) { %&gt;</span><br><span class="line">    &lt;a href="&lt;%= theme.socialLink.juejin %&gt;" class="tooltipped" target="_blank" data-tooltip="关注我的掘金: &lt;%= theme.socialLink.juejin %&gt;" data-position="top" data-delay="50"&gt;</span><br><span class="line">        &lt;i class="fab fa-juejin"&gt;掘&lt;/i&gt;</span><br><span class="line">    &lt;/a&gt;</span><br><span class="line">&lt;% } %&gt;</span><br><span class="line"></span><br><span class="line">&lt;% if (theme.socialLink.cnblogs) { %&gt;</span><br><span class="line">    &lt;a href="&lt;%= theme.socialLink.cnblogs %&gt;" class="tooltipped" target="_blank" data-tooltip="关注我的博客园: &lt;%= theme.socialLink.cnblogs %&gt;" data-position="top" data-delay="50"&gt;</span><br><span class="line">        &lt;i class="fab fa-juejin"&gt;博&lt;/i&gt;</span><br><span class="line">    &lt;/a&gt;</span><br><span class="line">&lt;% } %&gt;</span><br><span class="line">&lt;% if (theme.socialLink.weixin) { %&gt;</span><br><span class="line">    &lt;a href="&lt;%= theme.socialLink.weixin %&gt;" class="tooltipped" target="_blank" data-tooltip="微信联系我: &lt;%= theme.socialLink.weixin %&gt;" data-position="top" data-delay="50"&gt;</span><br><span class="line">        &lt;i class="fab fa-weixin"&gt;&lt;/i&gt;</span><br><span class="line">    &lt;/a&gt;</span><br><span class="line">&lt;% } %&gt;</span><br></pre></td></tr></tbody></table></figure><h3 id="6-版本记录"><a class="markdownIt-Anchor" href="#6-版本记录"></a> 6. 版本记录</h3><ul><li><p>v1.2.2</p><ul><li>新增了自定义文章 keywords 的功能；</li><li>新增静态彩带点击切换的功能和配置；</li><li>将文章字数统计、彩带和站点运行时间等功能默认设置为 false；</li><li>修改了文章的 description 的 meta 属性优先读取文章的 summary 属性；</li><li>修改了文章标题的 HTML 标签，从 div 改成了 h1 标题；</li><li>修改了页脚年份显示不正确的问题；</li><li>去掉了站点运行时间中多余的 setTimeout 代码；</li></ul></li><li><p>v1.2.1</p></li><li><p>新增了 TOC 的展开目录层级设置和滚动条功能，防止目录较多的时候目录溢出；</p></li><li><p>修改了首页的展示方式为以前的模式；</p></li><li><p>修复首页按钮没有边框的问题；</p></li><li><p>修复了音乐及吸底模式、视频、推荐文章等不激活时仍然生成首页卡片的问题；</p></li><li><p>修复 wordCount 插件未安装的问题，修改了部分配置；</p></li><li><p>修复音乐的 JSON 配置中有单引号的情况页面不显示的音乐的问题</p></li><li><p>修复标签云在Hexo4.0下链接失效的问题；</p></li><li><p>v1.2.0</p></li><li><p>新增了 DaoVoice、Tidio 的在线聊天功能；</p></li><li><p>新增了两级菜单的功能；</p></li><li><p>新增了打字效果的副标题；</p></li><li><p>新增了网页内容预加载的功能；</p></li><li><p>新增了首页 banner 是否每日切换的配置功能；</p></li><li><p>新增了显示 ICP 备案信息的功能，默认未开启；</p></li><li><p>新增了百度分析的配置；</p></li><li><p>新增了代码块的语言显示、一键复制、显示行号等功能；</p></li><li><p>新增了首页轮播图和推荐文章可自定义配置的功能；</p></li><li><p>新增了文章页面显示更新日期；</p></li><li><p>新增了转载规则的图标；</p></li><li><p>修改了分享的布局和显示方式；</p></li><li><p>升级更新了部分依赖库的版本；</p></li><li><p>其他细节修改和优化；</p></li><li><p>v1.1.0</p><ul><li>新增了 emoji 的支持；</li><li>新增了站点运行时间统计及配置；</li><li>新增了留言板的功能,默认未开启；</li><li>新增了 Twitter、Facebook、知乎的社交链接；</li><li>更新了 Valine 的版本为最新版；</li><li>其他小细节的修改；</li></ul></li><li><p>v1.0.4</p><ul><li>新增了能为每篇文章都自定义转载规则的功能；</li><li>修复上一页、下一页的自定义 summary 不显示的问题；</li><li>修复了友情链接显示错位的问题，改为了瀑布流的布局方式；</li><li>其他小细节 bug 的修改；</li></ul></li><li><p>v1.0.3</p><ul><li>新增了TOC展开、收缩的按钮和相关配置，默认显示此按钮；</li></ul></li><li><p>v1.0.2</p><ul><li>升级了 Materialize 框架版本为1.0.0，重构和修改了升级过程中的部分文件或问题；</li><li>新增了首页封面的全屏轮播特效，可以将更重要的文章设置到首页轮播中；</li><li>修复首页第一个按钮是中文的问题</li><li>修复了 iPhone 上点击搜索输入获取焦点的问题；</li><li>修复了 iPhone 上输入框获取焦点后页面放大的问题；</li><li>修复一些文章或 UI 显示问题；</li></ul></li><li><p>v1.0.1</p><ul><li>调整 css、js 的文件请求路径在主题的config.yml中配置，便于你更快捷的配置自己的 CDN；</li><li>新增代码是否折行为可配置，默认为折行；</li><li>默认激活 TOC 功能，并新增为某篇文章关闭 TOC 的 Front-matter 配置选项；</li><li>修复文章滚动时，高亮的目录选项不准确的问题；</li><li>IOS下移除搜索框自动获得焦点属性，防止自动获得焦点后导致视图上移；</li></ul></li><li><p>v1.0.0</p></li><li><p>新增了所有基础功能；</p></li></ul><h2 id="六-其他一些diy可选"><a class="markdownIt-Anchor" href="#六-其他一些diy可选"></a> 六 其他一些DIY(可选)</h2><blockquote><p>主题DIY会涉及到js文件和css文件等的修改，个人建议新增的js文件放在themes/matery/layout/layout.ejs这个文件下，这样会稍微加快博客访问的速度。不想花钱最好的方式是使用cdn.jsdeliver。以后会说到。</p></blockquote><h3 id="1-动态标题"><a class="markdownIt-Anchor" href="#1-动态标题"></a> 1. 动态标题</h3><p>先放上效果图再说：</p><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200605105900.png" alt="离开当前页面时"></p><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200605110047.png" alt="返回当前页面时"></p><p>实现方法，引入js文件，在主题文件下的**/source/js/<strong>下新建</strong>FunnyTitle.js**，然后在添加到<strong>themes/matery/layout/layout.ejs</strong>或者添加到<strong>themes/matery/layout/_partial/head.ejs</strong>，其代码如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;!--浏览器搞笑标题--&gt;</span><br><span class="line"> var OriginTitle = document.title;</span><br><span class="line"> var titleTime;</span><br><span class="line"> document.addEventListener('visibilitychange', function () {</span><br><span class="line">     if (document.hidden) {</span><br><span class="line">         $('[rel="icon"]').attr('href',"https://cdn.jsdelivr.net/gh/tlhg0/blogimage/images/favicon.png");</span><br><span class="line">         document.title = 'ヽ(●-`Д´-)ノ你要玩捉迷藏嘛';</span><br><span class="line">         clearTimeout(titleTime);</span><br><span class="line">     }</span><br><span class="line">     else {</span><br><span class="line">         $('[rel="icon"]').attr('href',"https://cdn.jsdelivr.net/gh/tlhg0/blogimage/images/favicon.png");</span><br><span class="line">         document.title = 'ヾ(Ő∀Ő3)ノ好哦！' + OriginTitle;</span><br><span class="line">         titleTime = setTimeout(function () {</span><br><span class="line">             document.title = OriginTitle;</span><br><span class="line">         }, 2000);</span><br><span class="line">     }</span><br><span class="line"> });</span><br></pre></td></tr></tbody></table></figure><p>或者直接在themes/matery/layout/layout.ejs文件中添加如下代码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;script type="text/javascript"&gt;</span><br><span class="line">    var OriginTitile=document.title,st;</span><br><span class="line">    document.addEventListener("visibilitychange",function(){</span><br><span class="line">        document.hidden?(document.title="ヽ(●-`Д´-)ノ你要玩捉迷藏嘛",clearTimeout(st)):(document.title="(Ő∀Ő3)ノ好哦！",st=setTimeout(function(){document.title=OriginTitile},3e3))</span><br><span class="line">    })</span><br><span class="line">&amp;rt/script&amp;gt</span><br></pre></td></tr></tbody></table></figure><h3 id="2-修改导航栏颜色以及透明效果"><a class="markdownIt-Anchor" href="#2-修改导航栏颜色以及透明效果"></a> 2. 修改导航栏颜色以及透明效果</h3><p>打开<strong>themes/matery/source/css/matery.css</strong>文件，大约在250行，有一个**.bg-color**属性，修改其属性值即可，代码如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">.bg-color {</span><br><span class="line">    background-image: linear-gradient(to right, #4cbf30 0%, #0f9d58 100%); //修改成自己喜欢的颜色值</span><br><span class="line">    opacity: 0.8;  //透明效果 值范围 0~1，看情况自己修改</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="3-添加动态诗词"><a class="markdownIt-Anchor" href="#3-添加动态诗词"></a> 3. 添加动态诗词</h3><p>采用的是<a href="https://www.jinrishici.com/">今日诗词</a>，每次返回一句诗词，根据时间、地点、天气、事件智能推荐。官网有API文档，可以去看一下，有多种安装方式，最简单的方式就是从官网获取代码，在**/themes/matery/layout/_partial/head.ejs**添加下面的一行代码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"&gt;&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><p>然后再将**/themes/matery/layout/_partial/bg-cover-content.ejs<strong>中的</strong>&lt;%= config.description %&gt;<strong>修改为把</strong>&lt;%= config.description %&gt;<strong>改为</strong>&lt;%- ‘正在加载今日诗词…’ %&gt;<strong>，这个使用前提是将主题配置文件的</strong>subtitle<strong>的值改为</strong>false**。</p><h3 id="4-鼠标点击文字特效"><a class="markdownIt-Anchor" href="#4-鼠标点击文字特效"></a> 4. 鼠标点击文字特效</h3><p>实现方法，引入js文件，在主题文件下的**/source/js/<strong>下新建</strong>click_show_text.js**，其代码如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">var a_idx = 0;</span><br><span class="line">jQuery(document).ready(function ($) {</span><br><span class="line">    $("body").click(function (e) {</span><br><span class="line">        var a = new Array("富强", "民主", "文明", "和谐", "自由", "平等", "公正", "法治", "爱国", "敬业", "诚信", "友善");</span><br><span class="line">        var $i = $("&lt;span/&gt;").text(a[a_idx]);</span><br><span class="line">        a_idx = (a_idx + 1) % a.length;</span><br><span class="line">        var x = e.pageX,</span><br><span class="line">            y = e.pageY;</span><br><span class="line">        $i.css({</span><br><span class="line">            "z-index": 5,</span><br><span class="line">            "top": y - 20,</span><br><span class="line">            "left": x,</span><br><span class="line">            "position": "absolute",</span><br><span class="line">            "font-weight": "bold",</span><br><span class="line">            "color": "#FF0000"</span><br><span class="line">        });</span><br><span class="line">        $("body").append($i);</span><br><span class="line">        $i.animate({</span><br><span class="line">                "top": y - 180,</span><br><span class="line">                "opacity": 0</span><br><span class="line">            },</span><br><span class="line">            3000,</span><br><span class="line">            function () {</span><br><span class="line">                $i.remove();</span><br><span class="line">            });</span><br><span class="line">    });</span><br><span class="line">    setTimeout('delay()', 2000);</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">function delay() {</span><br><span class="line">    $(".buryit").removeAttr("onclick");</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="5-添加天气小插件"><a class="markdownIt-Anchor" href="#5-添加天气小插件"></a> 5. 添加天气小插件</h3><p>首先去<a href="https://cj.weather.com.cn/plugin/pc">中国天气官网：</a>，配置自己的插件，选择自定义插件—&gt;自定义样式——&gt;生成代码，然后会生成一段代码，复制粘贴到<strong>themes/matery/layout/layout.ejs</strong>即可。</p><h3 id="6-关于我页面添加个人简历"><a class="markdownIt-Anchor" href="#6-关于我页面添加个人简历"></a> 6. 关于我页面添加个人简历</h3><p>打开<strong>theme/matery/layout/about.ejs</strong>文件，大约在13行。有一个``标签，找出其对应结尾的标签，大约在61行左右，然后在新增如下代码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;div class="card"&gt;</span><br><span class="line">     &lt;div class="card-content"&gt;</span><br><span class="line">         &lt;div class="card-content article-card-content"&gt;</span><br><span class="line">             &lt;div class="title center-align" data-aos="zoom-in-up"&gt;</span><br><span class="line">                 &lt;i class="fa fa-address-book"&gt;&lt;/i&gt;&amp;nbsp;&amp;nbsp;&lt;%- __('个人简历') %&gt;</span><br><span class="line">              &lt;/div&gt;</span><br><span class="line">                 &lt;div id="articleContent" data-aos="fade-up"&gt;</span><br><span class="line">                     &lt;%- page.content %&gt;</span><br><span class="line">                 &lt;/div&gt;</span><br><span class="line">           &lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></tbody></table></figure><p>注意粘贴的位置和空格要正确，这里的位置随你自己设置，你也可以把简历作为第一个card，然后**/source/about/index.md**下面写上你的简历了（就像写博客一样）。</p><h3 id="7-豆瓣书单电影页面"><a class="markdownIt-Anchor" href="#7-豆瓣书单电影页面"></a> 7. 豆瓣书单电影页面</h3><blockquote><p>注意：首先需要检查你的hexo版本是多少，在你的博客目录下执行命令 hexo -v 即可，这个豆瓣插件需要的版本需要&lt;4.2.0，否则会出现bug，比如点击书单的在读，想读或者已读会出现一个新的弹出页面，解决办法就是降低hexo的版本，先卸载目前的hexo版本，再安装4.0.0版本的hexo即可，我的版本为4.0.0。</p></blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">npm uninstall hexo</span><br><span class="line">npm install hexo@4.0.0 -g</span><br></pre></td></tr></tbody></table></figure><ol><li>首先在博客站点目录执行下面的命令安装豆瓣插件：</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">npm install hexo-douban --save</span><br></pre></td></tr></tbody></table></figure><p>紧接着在博客站点目录的配置文件**_config.yml**下，添加如下配置：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">douban: </span><br><span class="line">  user: 252345665    #这个需要修改为你个人的id  </span><br><span class="line">  builtin: false   #如果想生成豆瓣页面，这个需要设置为true</span><br><span class="line">  book: </span><br><span class="line">    title: 'This is my book title' </span><br><span class="line">    quote: 'This is my book quote' </span><br><span class="line">  movie: </span><br><span class="line">    title: 'This is my movie title' </span><br><span class="line">    quote: 'This is my movie quote' </span><br><span class="line">  game: </span><br><span class="line">    title: 'This is my game title' </span><br><span class="line">    quote: 'This is my game quote' </span><br><span class="line">  timeout: 10000</span><br></pre></td></tr></tbody></table></figure><ul><li>user:：你的豆瓣ID。打开豆瓣，登入账户，然后在右上角点击 ”个人主页“，这时候地址栏的URL大概是这样：<a href="https://www.douban.com/people/xxxxxx/">https://www.douban.com/people/xxxxxx/</a> ，其中的”xxxxxx”就是你的个人ID了。</li><li>builtin：是否将生成页面的功能嵌入 hexo s 和 hexo g 中，默认是 false ，另一可选项为 true 。</li><li>title： 该页面的标题。</li><li>quote： 写在页面开头的一段话,支持html语法。</li><li>timeout： 爬取数据的超时时间，默认是 10000ms，如果在使用时发现报了超时的错(ETIMEOUT)可以把这个数据设置的大  一点。</li></ul><p>如果只想显示某一个页面(比如movie)，那就把其他的配置项注释掉即可。</p><ol><li>然后再主题配置文件<strong>config.yml</strong>中添加关于此页面的菜单：(下面是我的配置)</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">    媒体:</span><br><span class="line">       url: /</span><br><span class="line">       icon: fas fa-list</span><br><span class="line">       children:</span><br><span class="line">         - name: 电影</span><br><span class="line">           url: /movies</span><br><span class="line">           icon: fas fa-film</span><br><span class="line">         - name: 书单</span><br><span class="line">           url: /books</span><br><span class="line">           icon: fas fa-book</span><br><span class="line">         - name: 游戏</span><br><span class="line">           url: /games</span><br><span class="line">           icon: fas fa-gamepad</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>适配Matery主题：在 <strong>/themes/hexo-theme-matery/layout</strong> 文件夹下面创建一个名为** douban.ejs **的文件，并将下面的内容复制进去：</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;%- partial('_partial/post-cover') %&gt; </span><br><span class="line">&lt;style&gt; </span><br><span class="line">    .hexo-douban-picture img {</span><br><span class="line">        width: 100%; </span><br><span class="line">    } </span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;main class="content"&gt; </span><br><span class="line">    &lt;div id="contact" class="container chip-container"&gt; </span><br><span class="line">        &lt;div class="card"&gt; </span><br><span class="line">            &lt;div class="card-content" style="padding: 30px"&gt; </span><br><span class="line">                &lt;h1 style="margin: 10px 0 10px 0px;"&gt;&lt;%= page.title %&gt;&lt;/h1&gt; </span><br><span class="line">                &lt;%- page.content %&gt; </span><br><span class="line">            &lt;/div&gt; </span><br><span class="line">        &lt;/div&gt; </span><br><span class="line">        &lt;div class="card"&gt; </span><br><span class="line">            &lt;div class="card-content" style="text-align: center"&gt; </span><br><span class="line">                &lt;h3 style="margin: 5px 0 5px 5px;"&gt;如果你有好的内容推荐，欢迎在下面留言！&lt;/h3&gt; </span><br><span class="line">            &lt;/div&gt; </span><br><span class="line">        &lt;/div&gt; </span><br><span class="line">        &lt;div class="card"&gt; </span><br><span class="line">            &lt;% if (theme.gitalk &amp;&amp; theme.gitalk.enable) { %&gt;</span><br><span class="line">                &lt;%- partial('_partial/gitalk') %&gt;</span><br><span class="line">            &lt;% } %&gt; </span><br><span class="line">            &lt;% if (theme.gitment.enable) { %&gt; </span><br><span class="line">                &lt;%- partial('_partial/gitment') %&gt; </span><br><span class="line">            &lt;% } %&gt; </span><br><span class="line">            &lt;% if (theme.disqus.enable) { %&gt; </span><br><span class="line">                &lt;%- partial('_partial/disqus') %&gt; </span><br><span class="line">            &lt;% } %&gt; </span><br><span class="line">            &lt;% if (theme.livere &amp;&amp; theme.livere.enable) { %&gt; </span><br><span class="line">                &lt;%- partial('_partial/livere') %&gt; </span><br><span class="line">            &lt;% } %&gt; </span><br><span class="line">            &lt;% if (theme.valine &amp;&amp; theme.valine.enable) { %&gt; </span><br><span class="line">                &lt;%- partial('_partial/valine') %&gt; </span><br><span class="line">            &lt;% } %&gt; </span><br><span class="line">        &lt;/div&gt; </span><br><span class="line">    &lt;/div&gt; </span><br><span class="line">&lt;/main&gt;</span><br></pre></td></tr></tbody></table></figure><ol start="3"><li>然后在博客站点目录下的<strong>node_modules</strong>文件夹下找到<strong>hexo-douban/lib</strong>，文件夹下有三个js文件，分别为：<strong>books-generator.js</strong> 、<strong>games-generator.js</strong> 、<strong>movies-generator.js</strong>，用文本编辑器打开这三个文件，并将其文件内容末尾的代码修改为一下内容：</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">/* 原文件内容为 layout: [`page`, `post`] ，将其修改为下面的内容*/</span><br><span class="line">layout: [`page`, `douban`]</span><br></pre></td></tr></tbody></table></figure><ol start="4"><li>最后就是使用并生成相应的页面，执行命令如下:</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">hexo douban</span><br></pre></td></tr></tbody></table></figure><p>需要注意的是，通常大家都喜欢用 hexo d 来作为 hexo deploy 命令的简化，但是当安装了 hexo douban 之后，就不能用 hexo d 了，因为 hexo douban 跟 hexo deploy 的前缀都是 hexo d ，你以后执行的 hexo d 将不再是 Hexo 页面的生成，而是豆瓣页面的生成。</p><p>以下是可选的命令参数：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">-h, --help    # 帮助页面</span><br><span class="line">-b, --books   # 只生成书单页面</span><br><span class="line">-g, --games   # 只生成游戏页面</span><br><span class="line">-m, --movies  # 只生成电影页面</span><br></pre></td></tr></tbody></table></figure><p><strong>当站点配置文件的builtin的值为true时，生成页面的功能会嵌入到hexo g和hexo s中，在进行部署生成操作，会自动生成相应的页面。</strong></p><h3 id="8-外链跳转插件"><a class="markdownIt-Anchor" href="#8-外链跳转插件"></a> 8. 外链跳转插件</h3><blockquote><p>hexo-external-link是一个跳转外链相关插件。自动为所有html文件中外链的a标签生成对应的属性。 比如 设置**target=’_blank’, rel=’external nofollow noopener noreferrer’ **告诉搜索引擎这是外部链接,不要将该链接计入权重。 同时自动生成外链跳转页面,默认在根目录下 go.html;</p></blockquote><p>使用 npm 或者 yarn 安装</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">## npm 安装</span><br><span class="line">npm install hexo-external-link --save</span><br><span class="line">## yarn 安装</span><br><span class="line">yarn add hexo-external-link</span><br></pre></td></tr></tbody></table></figure><p>之后再hexo博客站点根目录下添加如下配置：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">hexo_external_link:</span><br><span class="line">  enable: true</span><br><span class="line">  enable_base64_encode: true</span><br><span class="line">  url_param_name: 'u'</span><br><span class="line">  html_file_name: 'go.html'</span><br><span class="line">  target_blank: true</span><br><span class="line">  link_rel: 'external nofollow noopener noreferrer'</span><br><span class="line">  domain: 'your_domain' # 如果开启了防盗链，填写你的域名</span><br><span class="line">  safety_chain: true</span><br></pre></td></tr></tbody></table></figure><ul><li>enable - 是否开启hexo_external_link插件 - 默认 false</li><li>enable_base64_encode - 是否对跳转url使用base64编码 - 默认 fasle</li><li>url_param_name - url参数名,在跳转到外链传递给html_file_name的参数名 - 默认 ‘u’</li><li>html_file_name - 跳转到外链的页面文件路径 - 默认 ‘go.html’</li><li>target_blank - 是否为外链的a标签添加target=’_blank’ - 默认 true</li><li>link_rel - 设置外链的a标签的rel属性 - 默认 ‘external nofollow noopener noreferrer’</li><li>domain - 如果开启了防盗链,除了 localhost 和 domain(你的域名) 之外调用会跳到主页,同时也是判断链接是否为外链的依据 - 默认 window.location.host</li><li>safety_chain - go.html 为了防止外链盗用 对域名进行的判断 - 默认 false</li></ul><h3 id="9添加动态科技线条背景"><a class="markdownIt-Anchor" href="#9添加动态科技线条背景"></a> 9.添加动态科技线条背景</h3><p>在themes/matery/layout/layout.ejs文件中添加如下代码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;!--动态线条背景--&gt;</span><br><span class="line">&lt;script type="text/javascript"</span><br><span class="line">color="122 103 238" opacity='0.7' zIndex="-2" count="200" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"&gt;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><p>其中：</p><ul><li>color：表示线条颜色，三个数字分别为(R,G,B)，默认：（0,0,0）</li><li>opacity：表示线条透明度（0~1），默认：0.5</li><li>count：表示线条的总数量，默认：150</li><li>zIndex：表示背景的z-index属性，css属性用于控制所在层的位置，默认：-1</li></ul><h3 id="10-添加鼠标点击烟花爆炸效果"><a class="markdownIt-Anchor" href="#10-添加鼠标点击烟花爆炸效果"></a> 10. 添加鼠标点击烟花爆炸效果</h3><p>首先在<strong>themes/matery/source/js</strong>目录下新建<strong>fireworks.js</strong>文件，打开这个网址<a href="https://cdn.jsdelivr.net/gh/Yafine/cdn@3.3.1/source/js/fireworks.js">传送门</a>,将内容复制粘贴到**fireworks.js即可。</p><h3 id="11-添加樱花飘落效果"><a class="markdownIt-Anchor" href="#11-添加樱花飘落效果"></a> 11. 添加樱花飘落效果</h3><p>在<strong>themes/matery/source/js</strong>目录下新建<strong>sakura.js</strong>文件，打开这个<a href="https://cdn.jsdelivr.net/gh/Yafine/cdn@3.3.1/source/js/fireworks.js">网址传送门</a>，将内容复制粘贴到<strong>sakura.js</strong>即可。</p><p>然后再<strong>themes/matery/layout/layout.ejs</strong>文件内添加下面的内容：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;script type="text/javascript"&gt;</span><br><span class="line">//只在桌面版网页启用特效</span><br><span class="line">var windowWidth = $(window).width();</span><br><span class="line">if (windowWidth &gt; 768) {</span><br><span class="line">    document.write('&lt;script type="text/javascript" src="/js/sakura.js"&gt;&lt;\/script&gt;');</span><br><span class="line">}</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><h3 id="12-添加鼠标彩虹星星掉落跟随效果"><a class="markdownIt-Anchor" href="#12-添加鼠标彩虹星星掉落跟随效果"></a> 12. 添加鼠标彩虹星星掉落跟随效果</h3><p>在<strong>themes/matery/source/js</strong>目录下新建<strong>cursor.js</strong>文件，打开这个网址<a href="https://cdn.jsdelivr.net/gh/Yafine/cdn@3.3.1/source/js/cursor.js">传送门</a>，将内容复制粘贴到<strong>cursor.js</strong>即可。</p><p>然后再<strong>themes/matery/layout/layout.ejs</strong>文件内添加下面的内容：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;script src="/js/cursor.js"&gt;&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><h3 id="13-添加雪花飘落效果"><a class="markdownIt-Anchor" href="#13-添加雪花飘落效果"></a> 13. 添加雪花飘落效果</h3><p>在<strong>themes/matery/source/js</strong>目录下新建<strong>snow.js</strong>文件，打开这个网址<a href="https://cdn.jsdelivr.net/gh/Yafine/cdn@3.3.1/source/js/snow1.js">传送门</a>，将内容复制粘贴到<strong>cursor.js</strong>即可。</p><p>然后再<strong>themes/matery/layout/layout.ejs</strong>文件内添加下面的内容：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">&lt;script src="/js/snow.js"&gt;&lt;/script&gt;</span><br></pre></td></tr></tbody></table></figure><h3 id="14-文章生成永久链接"><a class="markdownIt-Anchor" href="#14-文章生成永久链接"></a> 14. 文章生成永久链接</h3><p>主题默认的文章链接配置是</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">permalink: :year/:month/:day/:title</span><br></pre></td></tr></tbody></table></figure><p>这种生成的链接地址很长，文章版权的链接地址会出现一大串字符编码，一点也不好看。因此需要修改文章生成链接的格式。</p><p>首先到根目录下执行下面的命令：</p><p><a href="https://github.com/rozbo/hexo-abbrlink">hexo-abbrlinkGitHub地址</a></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></tbody></table></figure><p>然后再站点配置文件下添加如下配置：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">abbrlink:</span><br><span class="line">    alg: crc16   #算法： crc16(default) and crc32</span><br><span class="line">    rep: hex     #进制： dec(default) and hex: dec #输出进制：十进制和十六进制，默认为10进制。丨dec为十进制，hex为十六进制</span><br></pre></td></tr></tbody></table></figure><p>再将站点配置文件的<strong>permalink</strong>的值修改为：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">permalink: posts/:abbrlink.html  # 此处可以自己设置，也可以直接使用 :/abbrlink</span><br></pre></td></tr></tbody></table></figure><p>生成文章的链接格式就会是如下样例（官方样例）:</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">crc16 &amp; hex</span><br><span class="line">https://post.zz173.com/posts/66c8.html</span><br><span class="line"></span><br><span class="line">crc16 &amp; dec</span><br><span class="line">https://post.zz173.com/posts/65535.html</span><br><span class="line">crc32 &amp; hex</span><br><span class="line">https://post.zz173.com/posts/8ddf18fb.html</span><br><span class="line"></span><br><span class="line">crc32 &amp; dec</span><br><span class="line">https://post.zz173.com/posts/1690090958.html</span><br></pre></td></tr></tbody></table></figure><p>生成完后，原md文件的Front-matter 内会增加<strong>abbrlink 字段</strong>，值为生成的ID 。这个字段确保了在我们修改了<strong>Front-matter</strong> 内的博客标题title或创建日期date字段之后而不会改变链接地址。</p><h2 id="七-添加评论系统"><a class="markdownIt-Anchor" href="#七-添加评论系统"></a> 七、添加评论系统</h2><p>我只说几个常用的评论系统的配置方法，其他的就不说了。</p><h3 id="71-添加来必力评论系统"><a class="markdownIt-Anchor" href="#71-添加来必力评论系统"></a> 7.1 添加来必力评论系统</h3><p>首先去<a href="https://livere.com/">来必力</a>官网，点击导航栏上的安装，会出现如下图的页面：</p><p>City 版：是一款适合所有人使用的免费版本；<br>Premium 版：是一款能够帮助企业实现自动化管理的多功能收费版本。</p><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200605140159.png" alt=""></p><p>注册完之后，会提示你填写网站的相关信息，如网站链接，网站名称等等，填写完毕之后，会给你一段代码，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200605140448.png" alt=""></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"># Livere comment configuration, the default is not activated</span><br><span class="line"># Livere 来必力评论模块的配置，默认为不激活</span><br><span class="line">livere:</span><br><span class="line">  enable: true   # true即为开启评论系统</span><br><span class="line">  uid: #这里填写你的uid</span><br></pre></td></tr></tbody></table></figure><p>然后在执行相关的部署命令，然后查看效果即可。</p><h3 id="72-添加valine评论系统"><a class="markdownIt-Anchor" href="#72-添加valine评论系统"></a> 7.2 添加Valine评论系统</h3><p><a href="https://valine.js.org/">Valine</a>官方文档</p><p>如果注册过LeanCloud，请点击此处进行<a href="https://leancloud.cn/dashboard/login.html#/signin">登录</a>，未注册的请点击<a href="https://leancloud.cn/dashboard/login.html#/signup">注册</a></p><p>经过登录或者注册之后再登录，就会进入如下的页面：</p><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200605140803.png" alt=""></p><p>创建应用完成后，会出现如下页面，然后点击设置</p><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200605140837.png" alt=""></p><p>会出现下面的页面，将其中APPID和APPKey复制，添加到配置文件中。</p><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200605140923.png" alt=""></p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"># The configuration of the Valine comment module is not activated by default.</span><br><span class="line"># To use it, activate the configuration item and set appId and appKey.</span><br><span class="line"># Valine 评论模块的配置，默认为不激活，如要使用，就请激活该配置项，并设置 appId 和 appKey.</span><br><span class="line">valine:</span><br><span class="line">  enable: false  # true即为开启评论系统</span><br><span class="line">  appId:   #此处填写你的appid</span><br><span class="line">  appKey:  #此处填写你的appkey</span><br><span class="line">  notify: false</span><br><span class="line">  verify: false</span><br><span class="line">  visitor: true</span><br><span class="line">  avatar: 'mm' # Gravatar style : mm/identicon/monsterid/wavatar/retro/hide</span><br><span class="line">  pageSize: 10</span><br><span class="line">  placeholder: 'just go go' # Comment Box placeholder</span><br><span class="line">  background:  https://cdn.jsdelivr.net/gh/Yafine/cdn@3.1.1/social/comment_bg.png</span><br></pre></td></tr></tbody></table></figure><p>然后执行相关部署命令，查看效果即可。</p><h3 id="73-添加gitalk评论模块"><a class="markdownIt-Anchor" href="#73-添加gitalk评论模块"></a> 7.3 添加Gitalk评论模块</h3><p>首先去这个地方看一下Gitalk的效果吧！<a href="https://gitalk.github.io/">传送门</a></p><p>安装步骤如下：</p><ol><li>注册 OAuth Application<br>当别人评论你的文章时，会需要它是授权。点击<a href="https://github.com/settings/applications/new">注册 OAuth Application</a>进行注册，注册界面如下：</li></ol><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200605141218.png" alt=""></p><ul><li>Application name：应用名称，自己随意起名。</li><li>Homepage URL：博客主页地址，如果有域名，此处填写域名，无域名，填写你的默认github地址：如    <a href="https://username.github.io">https://username.github.io</a>。</li><li>Application description：应用描述，可选，可以写也可以不写。</li><li>Authorization callback URL：授权后返回的地址，需要与Homepage URL一致。</li></ul><p>点击 Register application（注册）会出现 Client ID/Secret，接下来就是将信息填入配置文件中。</p><p>Client ID 和 Client Secret的值要复制下来</p><ol><li><p>新建GitHub仓库<br>新建仓库就不在多说了，相信大家都会，如果不会的话，上面有写。</p></li><li><p>配置 <strong>config.yml</strong> 文件</p></li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"># the Gitalk config，default disabled</span><br><span class="line"># Gitalk 评论模块的配置，默认为不激活</span><br><span class="line">gitalk:</span><br><span class="line">  enable: true    # true即开启评论模块</span><br><span class="line">  owner: Yafine  # 填写你的 github 账户名即可</span><br><span class="line">  repo: Yafine-gitalks   # 新建一个仓库或者使用博客托管的仓库也可</span><br><span class="line">  oauth:</span><br><span class="line">    clientId: #填写你的clientId</span><br><span class="line">    clientSecret:  #填写你的clientSecret</span><br><span class="line">  admin: Yafine  #填写你的 github 账户名即可</span><br></pre></td></tr></tbody></table></figure><ol start="3"><li>然后再进行部署步骤即可，第一次查看效果需要登录github账号，关联授权后，就可以使用评论系统了。</li></ol><blockquote><p>友情提醒：开启这个评论系统会对主题中的表格有影响，所以根据个人喜好决定是否开启。</p></blockquote><h3 id="74-添加disqus评论模块"><a class="markdownIt-Anchor" href="#74-添加disqus评论模块"></a> 7.4 添加Disqus评论模块</h3><p>还在完善，这个貌似得通过特殊途径才能注册。有时间再写吧。</p><p>你也可以参考这位作者的文档，作者自己搭建的代理：<a href="https://disqusjs.skk.moe/">https://disqusjs.skk.moe/</a></p><h2 id="八-域名解析与绑定"><a class="markdownIt-Anchor" href="#八-域名解析与绑定"></a> 八、域名解析与绑定</h2><p>域名的购买流程我就不说了，相信大家应该都会购买吧，一般都会去阿里云或者腾讯云购买域名。下面就简单的说一下，如何绑定域名并进行解析。</p><p>在这里以阿里云解析为例（我的域名是在阿里云购买的），登录阿里云的控制台，进入到域名管理页面，然后点击解析，进行域名的解析，如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200605141931.png" alt=""></p><p>进入云解析列表，添加记录值如下图所示：</p><p>IP地址可以提供cmd命令得到，命令为ping <a href="http://username.github.com">username.github.com</a>，会得到来自xxx.xxx.xxx.xxx的回复，这个就是github的IP地址，将得到的IP地址填入记录值即可，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200605142055.png" alt=""></p><blockquote><p>上面第一个行的线路类型第一次先选择默认，上面的境外路线，这是我后来配置的双部署，国内访问走coding路线，国外访问走GitHub路线。</p></blockquote><p><strong>说明：</strong></p><p>以我的域名为例：tlhg.top</p><blockquote><p>提示：要解析www.tlhg.top, 请填写 www。主机记录就是域名前缀，常见用法如下：</p></blockquote><table><thead><tr><th>主机记录</th><th>说明</th></tr></thead><tbody><tr><td>www</td><td>解析后的域名为www.tlhg.top</td></tr><tr><td>@</td><td>直接解析主域名tlhg.top</td></tr><tr><td>*</td><td>泛解析，匹配其他所有域名*.tlhg.top</td></tr><tr><td>mail</td><td>将域名解析为mail.tlhg.top，通常用于解析邮箱服务器</td></tr><tr><td>二级域名</td><td>如abc..tlhg.top，填写abc</td></tr><tr><td>手机网站</td><td>如m.tlhg.top，填写m</td></tr></tbody></table><blockquote><p>提示:<br>将域名指向云服务器，请选择**「A」<strong>； 将域名指向另一个域名，请选择</strong>「CNAME」<strong>； 建立邮箱请选择</strong>「MX」**，根据邮箱服务商提供的MX记录填写。</p></blockquote><table><thead><tr><th>主机记录</th><th>说明</th></tr></thead><tbody><tr><td>A</td><td>用来指定域名的IPv4地址（如8.8.8.8），如果需要将域名指向一个IP地址，就需要添加A记录。</td></tr><tr><td>CNAME</td><td>如果需要将域名指向另一个域名，再由另一个域名提供IP地址，就需要添加CNAME记录。</td></tr><tr><td>MX</td><td>如果需要设置邮箱，让邮箱能收到邮件，就需要添加MX记录。</td></tr><tr><td>TXT</td><td>在这里可以填写任何东西，长度限制255。绝大多数的TXT记录是用来做SPF记录（反垃圾邮件）</td></tr><tr><td>NS</td><td>域名服务器记录，如果需要将子域名交给其他DNS服务商解析，就需要添加NS记录。</td></tr><tr><td>AAAA</td><td>用来指定主机名（或域名）对应的IPv6地址（例如：ff06:0:0:0:0:0:0:c3）记录。</td></tr><tr><td>SRV</td><td>记录了哪台计算机提供了哪个服务。格式为：服务的名字、点、协议的类型，例如：_xmpp-server_tcp。</td></tr><tr><td>SRV</td><td>从一个地址301重定向到另一个地址的时候，就需要添加显性URL记录（注：DNSPod目前只支持301重定向）。</td></tr><tr><td>SRV</td><td>类似于显性URL，区别在于隐性URL不会改变地址栏的域名。</td></tr></tbody></table><blockquote><p>注意：在这之前需要在站点根目录的source目录下新建一个CNAME文件，里面写入自己的域名，然后保存，在进行如下的步骤。这样到最后当你在地址栏输入xxx.github.io时，才会自动跳转到你的域名。</p></blockquote><p>然后在你的GitHub仓库的设置里找到GitHub Pages页面，将你的域名填到Custom domain选项下，强制开启https，即当你在地址栏输入域名，会自动识别域名为https开头。然后进行保存。</p><h2 id="九-博客优化"><a class="markdownIt-Anchor" href="#九-博客优化"></a> 九、 博客优化</h2><h3 id="1-图片懒加载"><a class="markdownIt-Anchor" href="#1-图片懒加载"></a> 1. 图片懒加载</h3><blockquote><p>知识小课堂：图片加载方式有两种，一个是预加载，另一个就是懒加载，那你了解什么是预加载和懒加载吗？下面来学习一下。</p></blockquote><p>参考：<a href="https://blog.csdn.net/alex8046/article/details/50388050">图片预加载与图片懒加载（缓载）的区别与实现</a></p><ul><li>图片预加载：顾名思义，图片预加载就是在网页全部加载之前，提前加载图片。当用户需要查看时可直接从本地缓存中渲染，以提供给用户更好的体验，减少等待的时间。否则，如果一个页面的内容过于庞大，没有使用预加载技术的页面就会长时间的展现为一片空白，这样浏览者可能以为图片预览慢而没兴趣浏览，把网页关掉，这时，就需要图片预加载。当然这种做法实际上牺牲了服务器的性能换取了更好的用户体验。</li><li>图片懒加载（缓载）：延迟加载图片或符合某些条件时才加载某些图片。这样做的好处是减少不必要的访问数据库或延迟访问数据库的次数，因为每次访问数据库都是比较耗时的即只有真正使用该对象的数据时才会创建。懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数。</li></ul><p><strong>预加载与懒加载的区别之处：</strong></p><p>两者的行为是相反的，一个是提前加载，一个是迟缓甚至不加载。懒加载对服务器前端有一定的缓解压力作用，预载则会增加服务器前端压力。</p><p>使用图片懒加载需要安装插件：<a href="https://github.com/Troy-Yang/hexo-lazyload-image">hexo-lazyload-image</a></p><p>在站点根目录执行下面的命令：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">npm install hexo-lazyload-image --save</span><br></pre></td></tr></tbody></table></figure><p>之后在站点配置文件下添加下面的代码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">lazyload:</span><br><span class="line">  enable: true  # 是否开启图片懒加载</span><br><span class="line">  onlypost: false  # 是否只对文章的图片做懒加载</span><br><span class="line">  loadingImg: # eg ./images/loading.gif</span><br></pre></td></tr></tbody></table></figure><p>最后执行<strong>hexo clean &amp;&amp; hexo g &amp;&amp; hexo s</strong>就可以看到效果了。</p><h3 id="懒加载优化"><a class="markdownIt-Anchor" href="#懒加载优化"></a> 懒加载优化</h3><blockquote><p>经过以上操作就已经很完美了，以下内容可做可不做</p></blockquote><ul><li><p>其实第一次加载后本地都是有缓存的，如果每次都把loading显示出来就不那么好看</p></li><li><p>所以我们需要对插件进行魔改，让图片稍微提前加载，避开加载动画</p></li><li><p>打开 <strong>Hexo根目录&gt;node_modules &gt; hexo-lazyload-image &gt; lib &gt; simple-lazyload.js</strong>文件</p></li><li><p>第9行修改为：</p></li></ul><figure class="highlight javascript"><table><tbody><tr><td class="code"><pre><span class="line">&amp;&amp; rect.<span class="property">top</span> &lt;= (<span class="variable language_">window</span>.<span class="property">innerHeight</span> +<span class="number">240</span> || <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientHeight</span> +<span class="number">240</span>)</span><br></pre></td></tr></tbody></table></figure><ul><li>作用：提前240个像素加载图片；当然这个值也可以根据自己情况修改</li></ul><p>参考：<a href="https://blog.sky03.cn/posts/42790.html#toc-heading-5">https://blog.sky03.cn/posts/42790.html#toc-heading-5</a></p><h3 id="2-代码压缩"><a class="markdownIt-Anchor" href="#2-代码压缩"></a> 2. 代码压缩</h3><h4 id="方法一gulp代码压缩"><a class="markdownIt-Anchor" href="#方法一gulp代码压缩"></a> 方法一：gulp代码压缩</h4><p>因为hexo生成的html、css、js等都有很多的空格或者换行，而空格和换行也是占用字节的，所以需要将空格换行去掉也就是我要进行的“压缩”。</p><p>有人说空格换行能占多少字节？确实占不了多少，但是一个人访问是这么多字节，那么一百人，一万人呢？加起来这量就不少了吧，这都是流量啊！这也是很多css/js文件的后缀为.min.js或.min.css的原因。虽然我们可能没那么多访问量，但是能减小一点资源文件的大小也是对访问速度有那么一点提升的。</p><p>我们采用gulp代码压缩方式。</p><p>使用方法：</p><ol><li>进入站点根目录下依次执行下面的命令：</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"># 全局安装gulp模块</span><br><span class="line">npm install gulp -g</span><br><span class="line"># 安装各种小功能模块  执行这步的时候，可能会提示权限的问题，最好以管理员模式执行</span><br><span class="line">npm install gulp gulp-htmlclean gulp-htmlmin gulp-minify-css gulp-uglify gulp-imagemin --save</span><br><span class="line"># 额外的功能模块</span><br><span class="line">npm install gulp-debug gulp-clean-css gulp-changed gulp-if gulp-plumber gulp-babel babel-preset-es2015 del @babel/core --save</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>在Hexo根目录新建文件 gulpfile.js，并复制以下内容到文件中，有中文注释，可以根据自己需求修改。（注意：文件名不能错，一定为gulpfile.js，否则会出错！）</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">var gulp = require("gulp");</span><br><span class="line">var debug = require("gulp-debug");</span><br><span class="line">var cleancss = require("gulp-clean-css"); //css压缩组件</span><br><span class="line">var uglify = require("gulp-uglify"); //js压缩组件</span><br><span class="line">var htmlmin = require("gulp-htmlmin"); //html压缩组件</span><br><span class="line">var htmlclean = require("gulp-htmlclean"); //html清理组件</span><br><span class="line">var imagemin = require("gulp-imagemin"); //图片压缩组件</span><br><span class="line">var changed = require("gulp-changed"); //文件更改校验组件</span><br><span class="line">var gulpif = require("gulp-if"); //任务 帮助调用组件</span><br><span class="line">var plumber = require("gulp-plumber"); //容错组件（发生错误不跳出任务，并报出错误内容）</span><br><span class="line">var isScriptAll = true; //是否处理所有文件，(true|处理所有文件)(false|只处理有更改的文件)</span><br><span class="line">var isDebug = true; //是否调试显示 编译通过的文件</span><br><span class="line">var gulpBabel = require("gulp-babel");</span><br><span class="line">var es2015Preset = require("babel-preset-es2015");</span><br><span class="line">var del = require("del");</span><br><span class="line">var Hexo = require("hexo");</span><br><span class="line">var hexo = new Hexo(process.cwd(), {}); // 初始化一个hexo对象</span><br><span class="line">// 清除public文件夹</span><br><span class="line">gulp.task("clean", function () {</span><br><span class="line">    return del(["public/**/*"]);</span><br><span class="line">}); </span><br><span class="line">// 下面几个跟hexo有关的操作，主要通过hexo.call()去执行，注意return</span><br><span class="line">// 创建静态页面 （等同 hexo generate）</span><br><span class="line">gulp.task("generate", function () {</span><br><span class="line">    return hexo.init().then(function () {</span><br><span class="line">        return hexo</span><br><span class="line">            .call("generate", {</span><br><span class="line">                watch: false</span><br><span class="line">            })</span><br><span class="line">            .then(function () {</span><br><span class="line">                return hexo.exit();</span><br><span class="line">            })</span><br><span class="line">            .catch(function (err) {</span><br><span class="line">                return hexo.exit(err);</span><br><span class="line">            });</span><br><span class="line">    });</span><br><span class="line">}); </span><br><span class="line">// 启动Hexo服务器</span><br><span class="line">gulp.task("server", function () {</span><br><span class="line">    return hexo</span><br><span class="line">        .init()</span><br><span class="line">        .then(function () {</span><br><span class="line">            return hexo.call("server", {});</span><br><span class="line">        })</span><br><span class="line">        .catch(function (err) {</span><br><span class="line">            console.log(err);</span><br><span class="line">        });</span><br><span class="line">}); </span><br><span class="line">// 部署到服务器</span><br><span class="line">gulp.task("deploy", function () {</span><br><span class="line">    return hexo.init().then(function () {</span><br><span class="line">        return hexo</span><br><span class="line">            .call("deploy", {</span><br><span class="line">                watch: false</span><br><span class="line">            })</span><br><span class="line">            .then(function () {</span><br><span class="line">                return hexo.exit();</span><br><span class="line">            })</span><br><span class="line">            .catch(function (err) {</span><br><span class="line">                return hexo.exit(err);</span><br><span class="line">            });</span><br><span class="line">    });</span><br><span class="line">}); </span><br><span class="line">// 压缩public目录下的js文件</span><br><span class="line">gulp.task("compressJs", function () {</span><br><span class="line">    return gulp</span><br><span class="line">        .src(["./public/**/*.js", "!./public/libs/**"]) //排除的js</span><br><span class="line">        .pipe(gulpif(!isScriptAll, changed("./public")))</span><br><span class="line">        .pipe(gulpif(isDebug, debug({ title: "Compress JS:" })))</span><br><span class="line">        .pipe(plumber())</span><br><span class="line">        .pipe(</span><br><span class="line">            gulpBabel({</span><br><span class="line">                presets: [es2015Preset] // es5检查机制</span><br><span class="line">            })</span><br><span class="line">        )</span><br><span class="line">        .pipe(uglify()) //调用压缩组件方法uglify(),对合并的文件进行压缩</span><br><span class="line">        .pipe(gulp.dest("./public")); //输出到目标目录</span><br><span class="line">});  </span><br><span class="line">// 压缩public目录下的css文件</span><br><span class="line">gulp.task("compressCss", function () {</span><br><span class="line">    var option = {</span><br><span class="line">        rebase: false,</span><br><span class="line">        //advanced: true, //类型：Boolean 默认：true [是否开启高级优化（合并选择器等）]</span><br><span class="line">        compatibility: "ie7" //保留ie7及以下兼容写法 类型：String 默认：''or'*' [启用兼容模式； 'ie7'：IE7兼容模式，'ie8'：IE8兼容模式，'*'：IE9+兼容模式]</span><br><span class="line">        //keepBreaks: true, //类型：Boolean 默认：false [是否保留换行]</span><br><span class="line">        //keepSpecialComments: '*' //保留所有特殊前缀 当你用autoprefixer生成的浏览器前缀，如果不加这个参数，有可能将会删除你的部分前缀</span><br><span class="line">    };</span><br><span class="line">    return gulp</span><br><span class="line">        .src(["./public/**/*.css", "!./public/**/*.min.css"]) //排除的css</span><br><span class="line">        .pipe(gulpif(!isScriptAll, changed("./public")))</span><br><span class="line">        .pipe(gulpif(isDebug, debug({ title: "Compress CSS:" })))</span><br><span class="line">        .pipe(plumber())</span><br><span class="line">        .pipe(cleancss(option))</span><br><span class="line">        .pipe(gulp.dest("./public"));</span><br><span class="line">});  </span><br><span class="line">// 压缩public目录下的html文件</span><br><span class="line">gulp.task("compressHtml", function () {</span><br><span class="line">    var cleanOptions = {</span><br><span class="line">        protect: /&lt;\!--%fooTemplate\b.*?%--&gt;/g, //忽略处理</span><br><span class="line">        unprotect: /&lt;script [^&gt;]*\btype="text\/x-handlebars-template"[\s\S]+?&lt;\/script&gt;/gi //特殊处理</span><br><span class="line">    };</span><br><span class="line">    var minOption = {</span><br><span class="line">        collapseWhitespace: true, //压缩HTML</span><br><span class="line">        collapseBooleanAttributes: true, //省略布尔属性的值 &lt;input checked="true"/&gt; ==&gt; &lt;input /&gt;</span><br><span class="line">        removeEmptyAttributes: true, //删除所有空格作属性值 &lt;input id="" /&gt; ==&gt; &lt;input /&gt;</span><br><span class="line">        removeScriptTypeAttributes: true, //删除&lt;script&gt;的type="text/javascript"</span><br><span class="line">        removeStyleLinkTypeAttributes: true, //删除&lt;style&gt;和&lt;link&gt;的type="text/css"</span><br><span class="line">        removeComments: true, //清除HTML注释</span><br><span class="line">        minifyJS: true, //压缩页面JS</span><br><span class="line">        minifyCSS: true, //压缩页面CSS</span><br><span class="line">        minifyURLs: true //替换页面URL</span><br><span class="line">    };</span><br><span class="line">    return gulp</span><br><span class="line">        .src("./public/**/*.html")</span><br><span class="line">        .pipe(gulpif(isDebug, debug({ title: "Compress HTML:" })))</span><br><span class="line">        .pipe(plumber())</span><br><span class="line">        .pipe(htmlclean(cleanOptions))</span><br><span class="line">        .pipe(htmlmin(minOption))</span><br><span class="line">        .pipe(gulp.dest("./public"));</span><br><span class="line">});  </span><br><span class="line">// 压缩 public/medias 目录内图片</span><br><span class="line">gulp.task("compressImage", function () {</span><br><span class="line">    var option = {</span><br><span class="line">        optimizationLevel: 5, //类型：Number 默认：3 取值范围：0-7（优化等级）</span><br><span class="line">        progressive: true, //类型：Boolean 默认：false 无损压缩jpg图片</span><br><span class="line">        interlaced: false, //类型：Boolean 默认：false 隔行扫描gif进行渲染</span><br><span class="line">        multipass: false //类型：Boolean 默认：false 多次优化svg直到完全优化</span><br><span class="line">    };</span><br><span class="line">    return gulp</span><br><span class="line">        .src("./public/medias/**/*.*")</span><br><span class="line">        .pipe(gulpif(!isScriptAll, changed("./public/medias")))</span><br><span class="line">        .pipe(gulpif(isDebug, debug({ title: "Compress Images:" })))</span><br><span class="line">        .pipe(plumber())</span><br><span class="line">        .pipe(imagemin(option))</span><br><span class="line">        .pipe(gulp.dest("./public"));</span><br><span class="line">});</span><br><span class="line">// 执行顺序： 清除public目录 -&gt; 产生原始博客内容 -&gt; 执行压缩混淆 -&gt; 部署到服务器</span><br><span class="line">gulp.task(</span><br><span class="line">    "build",</span><br><span class="line">    gulp.series(</span><br><span class="line">        "clean",</span><br><span class="line">        "generate",</span><br><span class="line">        "compressHtml",</span><br><span class="line">        "compressCss",</span><br><span class="line">        "compressJs",</span><br><span class="line">        "compressImage",</span><br><span class="line">        gulp.parallel("deploy")</span><br><span class="line">    )</span><br><span class="line">);  </span><br><span class="line">// 默认任务</span><br><span class="line">gulp.task(</span><br><span class="line">    "default",</span><br><span class="line">    gulp.series(</span><br><span class="line">        "clean",</span><br><span class="line">        "generate",</span><br><span class="line">        gulp.parallel("compressHtml", "compressCss", "compressJs","compressImage")</span><br><span class="line">    )</span><br><span class="line">);</span><br><span class="line">//Gulp4最大的一个改变就是gulp.task函数现在只支持两个参数，分别是任务名和运行任务的函数</span><br></pre></td></tr></tbody></table></figure><ol start="3"><li>以后的执行方式有两种：<ul><li>直接在Hexo根目录执行 gulp或者 gulp default ，这个命令相当于 hexo cl&amp;&amp;hexo g 并且再把代码和图片压缩。</li><li>在Hexo根目录执行 gulp build ，这个命令与第1种相比是：在最后又加了个 hexo d ，等于说生成、压缩文件后又帮你自动部署了。</li></ul></li></ol><blockquote><p>值得注意的是：这个加入了图片压缩，如果不想用图片压缩可以把第154行的 “compressImage”, 和第165行的 ,“compressImage” 去掉即可</p></blockquote><h4 id="方法二hexo-neat插件实现代码压缩"><a class="markdownIt-Anchor" href="#方法二hexo-neat插件实现代码压缩"></a> 方法二：hexo-neat插件实现代码压缩</h4><p>可能以上方法比较复杂，来介绍个简单的，<a href="https://github.com/rozbo/hexo-neat">hexo-neat</a>插件也是用来压缩代码的，底层也是通过gulp来实现的。</p><p>但是这个插件是有Bug的：</p><ul><li>压缩 md 文件会使 markdown 语法的代码块消失</li><li>会删除全角空格</li></ul><p>在博客站点根目录执行安装代码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">npm install hexo-neat --save</span><br></pre></td></tr></tbody></table></figure><p>紧接着在站点根目录下的配置文件添加如下代码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">neat_enable: true</span><br><span class="line">neat_html:</span><br><span class="line">  enable: true</span><br><span class="line">  exclude:</span><br><span class="line">neat_css:</span><br><span class="line">  enable: true</span><br><span class="line">  exclude:</span><br><span class="line">    - '*.min.css'</span><br><span class="line">neat_js:</span><br><span class="line">  enable: true</span><br><span class="line">  mangle: true</span><br><span class="line">  output:</span><br><span class="line">  compress:</span><br><span class="line">  exclude:</span><br><span class="line">    - '*.min.js'</span><br></pre></td></tr></tbody></table></figure><p>然后直接** hexo cl&amp;&amp;hexo g **就可以了，会自动压缩文件 。</p><p>补充：为了解决以上Bug，对于matery主题（其他主题自行解决）需要将以上默认配置修改为：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">#hexo-neat 优化提速插件（去掉HTML、css、js的blank字符）</span><br><span class="line">neat_enable: true</span><br><span class="line">neat_html:</span><br><span class="line">  enable: true</span><br><span class="line">  exclude:</span><br><span class="line">    - '**/*.md'</span><br><span class="line">neat_css:</span><br><span class="line">  enable: true</span><br><span class="line">  exclude:</span><br><span class="line">    - '**/*.min.css'</span><br><span class="line">neat_js:</span><br><span class="line">  enable: true</span><br><span class="line">  mangle: true</span><br><span class="line">  output:</span><br><span class="line">  compress:</span><br><span class="line">  exclude:</span><br><span class="line">    - '**/*.min.js'</span><br><span class="line">    - '**/**/instantpage.js'</span><br><span class="line">    - '**/matery.js'</span><br></pre></td></tr></tbody></table></figure><h2 id="十-seo优化"><a class="markdownIt-Anchor" href="#十-seo优化"></a> 十、SEO优化</h2><p>请参考这篇博文：<a href="https://blog.sky03.cn/posts/42790.html#toc-heading-18">https://blog.sky03.cn/posts/42790.html#toc-heading-18</a></p><h2 id="十一-新建文章自动打开本地markdown编辑器"><a class="markdownIt-Anchor" href="#十一-新建文章自动打开本地markdown编辑器"></a> 十一、新建文章自动打开本地Markdown编辑器</h2><p>写新文章时，需要控制台执行hexo new “文章名字”，这样就会在<strong>posts</strong>下生成一篇新文章，但需要手动打开，挺麻烦，只需要在站点根目录下新建scripts目录，然后在新建<strong>auto_open.js</strong>，在文件填入一下内容：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">var spawn = require('child_process').exec;</span><br><span class="line"></span><br><span class="line">// Hexo 2.x 用户复制这段</span><br><span class="line">//hexo.on('new', function(path){</span><br><span class="line">  //spawn('start  "markdown编辑器绝对路径.exe" ' + path);</span><br><span class="line">//});</span><br><span class="line"></span><br><span class="line">// Hexo 3 用户复制这段</span><br><span class="line">hexo.on('new', function(data){</span><br><span class="line">  spawn('start  "D:\Program Files\Typora\Typora.exe" ' + data.path);</span><br><span class="line">});</span><br><span class="line">其中"D:\Program Files\Typorae\Typora.exe"是我本地编辑器的路径，只需要改为你本地编辑器的路径即可，然后在执行hexo cl &amp;&amp; hexo g -d，部署到GitHub即可，以后在发布文章就会自动打开编辑器。</span><br></pre></td></tr></tbody></table></figure><p>文章参考来源</p><ul><li>matery主题文档</li><li>Matery主题配置豆瓣插件</li><li>Hexo博客主题个性化</li><li>Hexo进阶之各种优化</li><li>hexo博客美化</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> matery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter07-类.md</title>
      <link href="/posts/88d3.html"/>
      <url>/posts/88d3.html</url>
      
        <content type="html"><![CDATA[<p>类的基本思想是数据抽象（data abstraction）和封装（encapsulation）。数据抽象是一种依赖于接口（interface）和实现（implementation）分离的编程及设计技术。类的接口包括用户所能执行的操作；类的实现包括类的数据成员、负责接口实现的函数体以及其他私有函数。</p><h2 id="定义抽象数据类型defining-abstract-data-types"><a class="markdownIt-Anchor" href="#定义抽象数据类型defining-abstract-data-types"></a> 定义抽象数据类型（Defining Abstract Data Types）</h2><h3 id="设计sales_data类designing-the-sales_data-class"><a class="markdownIt-Anchor" href="#设计sales_data类designing-the-sales_data-class"></a> 设计Sales_data类（Designing the Sales_data Class）</h3><p>类的用户是程序员，而非应用程序的最终使用者。</p><h3 id="定义改进的sales_data类defining-the-revised-sales_data-class"><a class="markdownIt-Anchor" href="#定义改进的sales_data类defining-the-revised-sales_data-class"></a> 定义改进的Sales_data类（Defining the Revised Sales_data Class）</h3><p>成员函数（member function）的声明必须在类的内部，定义则既可以在类的内部也可以在类的外部。定义在类内部的函数是隐式的内联函数。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Sales_data</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// new members: operations on Sales_data objects</span></span><br><span class="line">    <span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> bookNo; }</span><br><span class="line">    <span class="function">Sales_data&amp; <span class="title">combine</span><span class="params">(<span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">avg_price</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// data members</span></span><br><span class="line">    std::string bookNo;</span><br><span class="line">    <span class="type">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>成员函数通过一个名为<code>this</code>的隐式额外参数来访问调用它的对象。<code>this</code>参数是一个常量指针，被初始化为调用该函数的对象地址。在函数体内可以显式使用<code>this</code>指针。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">total.<span class="built_in">isbn</span>()</span><br><span class="line"><span class="comment">// pseudo-code illustration of how a call to a member function is translated</span></span><br><span class="line">Sales_data::<span class="built_in">isbn</span>(&amp;total)</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> <span class="keyword">this</span>-&gt;bookNo; }</span><br><span class="line"><span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> bookNo; }</span><br></pre></td></tr></tbody></table></figure><p>默认情况下，<code>this</code>的类型是指向类类型非常量版本的常量指针。<code>this</code>也遵循初始化规则，所以默认不能把<code>this</code>绑定到一个常量对象上，即不能在常量对象上调用普通的成员函数。</p><p>C++允许在成员函数的参数列表后面添加关键字<code>const</code>，表示<code>this</code>是一个指向常量的指针。使用关键字<code>const</code>的成员函数被称作常量成员函数（const member function）。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// pseudo-code illustration of how the implicit this pointer is used</span></span><br><span class="line"><span class="comment">// this code is illegal: we may not explicitly define the this pointer ourselves</span></span><br><span class="line"><span class="comment">// note that this is a pointer to const because isbn is a const member</span></span><br><span class="line"><span class="function">std::string <span class="title">Sales_data::isbn</span><span class="params">(<span class="type">const</span> Sales_data *<span class="type">const</span> <span class="keyword">this</span>)</span></span></span><br><span class="line"><span class="function"></span>{ </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;isbn;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>常量对象和指向常量对象的引用或指针都只能调用常量成员函数。</p><p>类本身就是一个作用域，成员函数的定义嵌套在类的作用域之内。编译器处理类时，会先编译成员声明，再编译成员函数体（如果有的话），因此成员函数可以随意使用类的其他成员而无须在意这些成员的出现顺序。</p><p>在类的外部定义成员函数时，成员函数的定义必须与它的声明相匹配。如果成员函数被声明为常量成员函数，那么它的定义也必须在参数列表后面指定<code>const</code>属性。同时，类外部定义的成员名字必须包含它所属的类名。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">Sales_data::avg_price</span><span class="params">()</span> <span class="type">const</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (units_sold)</span><br><span class="line">        <span class="keyword">return</span> revenue / units_sold;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以定义返回<code>this</code>对象的成员函数。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">Sales_data&amp; <span class="title">Sales_data::combine</span><span class="params">(<span class="type">const</span> Sales_data &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    units_sold += rhs.units_sold;   <span class="comment">// add the members of rhs into</span></span><br><span class="line">    revenue += rhs.revenue;     <span class="comment">// the members of 'this' object</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;       <span class="comment">// return the object on which the function was called</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="定义类相关的非成员函数defining-nonmember-class-related-functions"><a class="markdownIt-Anchor" href="#定义类相关的非成员函数defining-nonmember-class-related-functions"></a> 定义类相关的非成员函数（Defining Nonmember Class-Related Functions）</h3><p>类的作者通常会定义一些辅助函数，尽管这些函数从概念上来说属于类接口的组成部分，但实际上它们并不属于类本身。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// input transactions contain ISBN, number of copies sold, and sales price</span></span><br><span class="line"><span class="function">istream &amp;<span class="title">read</span><span class="params">(istream &amp;is, Sales_data &amp;item)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">double</span> price = <span class="number">0</span>;</span><br><span class="line">    is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price;</span><br><span class="line">    item.revenue = price * item.units_sold;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="type">const</span> Sales_data &amp;item)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    os &lt;&lt; item.<span class="built_in">isbn</span>() &lt;&lt; <span class="string">" "</span> &lt;&lt; item.units_sold &lt;&lt; <span class="string">" "</span></span><br><span class="line">        &lt;&lt; item.revenue &lt;&lt; <span class="string">" "</span> &lt;&lt; item.<span class="built_in">avg_price</span>();</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果非成员函数是类接口的组成部分，则这些函数的声明应该与类放在同一个头文件中。</p><p>一般来说，执行输出任务的函数应该尽量减少对格式的控制。</p><h3 id="构造函数constructors"><a class="markdownIt-Anchor" href="#构造函数constructors"></a> 构造函数（Constructors）</h3><p>类通过一个或几个特殊的成员函数来控制其对象的初始化操作，这些函数被称作构造函数。只要类的对象被创建，就会执行构造函数。</p><p>构造函数的名字和类名相同，没有返回类型，且不能被声明为<code>const</code>函数。构造函数在<code>const</code>对象的构造过程中可以向其写值。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Sales_data</span> </span><br><span class="line">{</span><br><span class="line">    <span class="comment">// constructors added</span></span><br><span class="line">    <span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="type">const</span> std::string &amp;s): <span class="built_in">bookNo</span>(s) { }</span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="type">const</span> std::string &amp;s, <span class="type">unsigned</span> n, <span class="type">double</span> p):</span><br><span class="line">        <span class="built_in">bookNo</span>(s), <span class="built_in">units_sold</span>(n), <span class="built_in">revenue</span>(p*n) { }</span><br><span class="line">    <span class="built_in">Sales_data</span>(std::istream &amp;);</span><br><span class="line">    <span class="comment">// other members as before</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>类通过默认构造函数（default constructor）来控制默认初始化过程，默认构造函数无须任何实参。</p><p>如果类没有显式地定义构造函数，则编译器会为类隐式地定义一个默认构造函数，该构造函数也被称为合成的默认构造函数（synthesized default constructor）。对于大多数类来说，合成的默认构造函数初始化数据成员的规则如下：</p><ul><li>如果存在类内初始值，则用它来初始化成员。</li><li>否则默认初始化该成员。</li></ul><p>某些类不能依赖于合成的默认构造函数。</p><ul><li>只有当类没有声明任何构造函数时，编译器才会自动生成默认构造函数。一旦类定义了其他构造函数，那么除非再显式地定义一个默认的构造函数，否则类将没有默认构造函数。</li><li>如果类包含内置类型或者复合类型的成员，则只有当这些成员全部存在类内初始值时，这个类才适合使用合成的默认构造函数。否则用户在创建类的对象时就可能得到未定义的值。</li><li>编译器不能为某些类合成默认构造函数。例如类中包含一个其他类类型的成员，且该类型没有默认构造函数，那么编译器将无法初始化该成员。</li></ul><p>在C++11中，如果类需要默认的函数行为，可以通过在参数列表后面添加<code>=default</code>来要求编译器生成构造函数。其中<code>=default</code>既可以和函数声明一起出现在类的内部，也可以作为定义出现在类的外部。和其他函数一样，如果<code>=default</code>在类的内部，则默认构造函数是内联的。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br></pre></td></tr></tbody></table></figure><p>构造函数初始值列表（constructor initializer list）负责为新创建对象的一个或几个数据成员赋初始值。形式是每个成员名字后面紧跟括号括起来的（或者在花括号内的）成员初始值，不同成员的初始值通过逗号分隔。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">Sales_data</span>(<span class="type">const</span> std::string &amp;s): <span class="built_in">bookNo</span>(s) { }</span><br><span class="line"><span class="built_in">Sales_data</span>(<span class="type">const</span> std::string &amp;s, <span class="type">unsigned</span> n, <span class="type">double</span> p):</span><br><span class="line">    <span class="built_in">bookNo</span>(s), <span class="built_in">units_sold</span>(n), <span class="built_in">revenue</span>(p*n) { }</span><br></pre></td></tr></tbody></table></figure><p>当某个数据成员被构造函数初始值列表忽略时，它会以与合成默认构造函数相同的方式隐式初始化。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// has the same behavior as the original constructor defined above</span></span><br><span class="line"><span class="built_in">Sales_data</span>(<span class="type">const</span> std::string &amp;s):</span><br><span class="line">    <span class="built_in">bookNo</span>(s), <span class="built_in">units_sold</span>(<span class="number">0</span>), <span class="built_in">revenue</span>(<span class="number">0</span>) { }</span><br></pre></td></tr></tbody></table></figure><p>构造函数不应该轻易覆盖掉类内初始值，除非新值与原值不同。如果编译器不支持类内初始值，则所有构造函数都应该显式初始化每个内置类型的成员。</p><h3 id="拷贝-赋值和析构copy-assignmentand-destruction"><a class="markdownIt-Anchor" href="#拷贝-赋值和析构copy-assignmentand-destruction"></a> 拷贝、赋值和析构（Copy、Assignment，and Destruction）</h3><p>编译器能合成拷贝、赋值和析构函数，但是对于某些类来说合成的版本无法正常工作。特别是当类需要分配类对象之外的资源时，合成的版本通常会失效。</p><h2 id="访问控制与封装access-control-and-encapsulation"><a class="markdownIt-Anchor" href="#访问控制与封装access-control-and-encapsulation"></a> 访问控制与封装（Access Control and Encapsulation）</h2><p>使用访问说明符（access specifier）可以加强类的封装性：</p><ul><li>定义在<code>public</code>说明符之后的成员在整个程序内都可以被访问。<code>public</code>成员定义类的接口。</li><li>定义在<code>private</code>说明符之后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问。<code>private</code>部分封装了类的实现细节。</li></ul><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span> </span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>: <span class="comment">// access specifier added</span></span><br><span class="line">    <span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="type">const</span> std::string &amp;s, <span class="type">unsigned</span> n, <span class="type">double</span> p):</span><br><span class="line">    <span class="built_in">bookNo</span>(s), <span class="built_in">units_sold</span>(n), <span class="built_in">revenue</span>(p*n) { }</span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="type">const</span> std::string &amp;s): <span class="built_in">bookNo</span>(s) { }</span><br><span class="line">    <span class="built_in">Sales_data</span>(std::istream&amp;);</span><br><span class="line">    <span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> bookNo; }</span><br><span class="line">    <span class="function">Sales_data &amp;<span class="title">combine</span><span class="params">(<span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>: <span class="comment">// access specifier added</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">avg_price</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> units_sold ? revenue/units_sold : <span class="number">0</span>; }   </span><br><span class="line">    std::string bookNo;</span><br><span class="line">    <span class="type">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>一个类可以包含零或多个访问说明符，每个访问说明符指定了接下来的成员的访问级别，其有效范围到出现下一个访问说明符或类的结尾处为止。</p><p>使用关键字<code>struct</code>定义类时，定义在第一个访问说明符之前的成员是<code>public</code>的；而使用关键字<code>class</code>时，这些成员是<code>private</code>的。二者唯一的区别就是默认访问权限不同。</p><h3 id="友元friends"><a class="markdownIt-Anchor" href="#友元friends"></a> 友元（Friends）</h3><p>类可以允许其他类或函数访问它的非公有成员，方法是使用关键字<code>friend</code>将其他类或函数声明为它的友元。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span> </span><br><span class="line">{</span><br><span class="line">    <span class="comment">// friend declarations for nonmember Sales_data operations added</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> Sales_data <span class="title">add</span><span class="params">(<span class="type">const</span> Sales_data&amp;, <span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> std::istream &amp;<span class="title">read</span><span class="params">(std::istream&amp;, Sales_data&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> std::ostream &amp;<span class="title">print</span><span class="params">(std::ostream&amp;, <span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// other members and access specifiers as before</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="type">const</span> std::string &amp;s, <span class="type">unsigned</span> n, <span class="type">double</span> p):</span><br><span class="line">    <span class="built_in">bookNo</span>(s), <span class="built_in">units_sold</span>(n), <span class="built_in">revenue</span>(p*n) { }</span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="type">const</span> std::string &amp;s): <span class="built_in">bookNo</span>(s) { }</span><br><span class="line">    <span class="built_in">Sales_data</span>(std::istream&amp;);</span><br><span class="line">    <span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span> </span>{ <span class="keyword">return</span> bookNo; }</span><br><span class="line">    <span class="function">Sales_data &amp;<span class="title">combine</span><span class="params">(<span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string bookNo;</span><br><span class="line">    <span class="type">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// declarations for nonmember parts of the Sales_data interface</span></span><br><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="type">const</span> Sales_data&amp;, <span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="function">std::istream &amp;<span class="title">read</span><span class="params">(std::istream&amp;, Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="function">std::ostream &amp;<span class="title">print</span><span class="params">(std::ostream&amp;, <span class="type">const</span> Sales_data&amp;)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>友元声明只能出现在类定义的内部，具体位置不限。友元不是类的成员，也不受它所在区域访问级别的约束。</p><p>通常情况下，最好在类定义开始或结束前的位置集中声明友元。</p><p>封装的好处：</p><ul><li>确保用户代码不会无意间破坏封装对象的状态。</li><li>被封装的类的具体实现细节可以随时改变，而无须调整用户级别的代码。</li></ul><p>友元声明仅仅指定了访问权限，而并非一个通常意义上的函数声明。如果希望类的用户能调用某个友元函数，就必须在友元声明之外再专门对函数进行一次声明（部分编译器没有该限制）。</p><p>为了使友元对类的用户可见，通常会把友元的声明（类的外部）与类本身放在同一个头文件中。</p><h2 id="类的其他特性additional-class-features"><a class="markdownIt-Anchor" href="#类的其他特性additional-class-features"></a> 类的其他特性（Additional Class Features）</h2><h3 id="类成员再探class-members-revisited"><a class="markdownIt-Anchor" href="#类成员再探class-members-revisited"></a> 类成员再探（Class Members Revisited）</h3><p>由类定义的类型名字和其他成员一样存在访问限制，可以是<code>public</code>或<code>private</code>中的一种。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span> </span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// alternative way to declare a type member using a type alias</span></span><br><span class="line">    <span class="keyword">using</span> pos = std::string::size_type;</span><br><span class="line">    <span class="comment">// other members as before</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>与普通成员不同，用来定义类型的成员必须先定义后使用。类型成员通常位于类起始处。</p><p>定义在类内部的成员函数是自动内联的。</p><p>如果需要显式声明内联成员函数，建议只在类外部定义的位置说明<code>inline</code>。</p><p><code>inline</code>成员函数该与类定义在同一个头文件中。</p><p>使用关键字<code>mutable</code>可以声明可变数据成员（mutable data member）。可变数据成员永远不会是<code>const</code>的，即使它在<code>const</code>对象内。因此<code>const</code>成员函数可以修改可变成员的值。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span> </span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">some_member</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">size_t</span> access_ctr;  <span class="comment">// may change even in a const object</span></span><br><span class="line">    <span class="comment">// other members as before</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Screen::some_member</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    ++access_ctr;   <span class="comment">// keep a count of the calls to any member function</span></span><br><span class="line">    <span class="comment">// whatever other work this member needs to do</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>提供类内初始值时，必须使用<code>=</code>或花括号形式。</p><h3 id="返回this的成员函数functions-that-return-this"><a class="markdownIt-Anchor" href="#返回this的成员函数functions-that-return-this"></a> 返回*this的成员函数（Functions That Return *this）</h3><p><code>const</code>成员函数如果以引用形式返回<code>*this</code>，则返回类型是常量引用。</p><p>通过区分成员函数是否为<code>const</code>的，可以对其进行重载。在常量对象上只能调用<code>const</code>版本的函数；在非常量对象上，尽管两个版本都能调用，但会选择非常量版本。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span> </span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// display overloaded on whether the object is const or not</span></span><br><span class="line">    <span class="function">Screen &amp;<span class="title">display</span><span class="params">(std::ostream &amp;os)</span></span></span><br><span class="line"><span class="function">    </span>{ <span class="built_in">do_display</span>(os); <span class="keyword">return</span> *<span class="keyword">this</span>; }</span><br><span class="line">    <span class="function"><span class="type">const</span> Screen &amp;<span class="title">display</span><span class="params">(std::ostream &amp;os)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>{ <span class="built_in">do_display</span>(os); <span class="keyword">return</span> *<span class="keyword">this</span>; }</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// function to do the work of displaying a Screen</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">do_display</span><span class="params">(std::ostream &amp;os)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>{ os &lt;&lt; contents; }</span><br><span class="line">    <span class="comment">// other members as before</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function">Screen <span class="title">myScreen</span><span class="params">(<span class="number">5</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">const</span> Screen <span class="title">blank</span><span class="params">(<span class="number">5</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">myScreen.<span class="built_in">set</span>(<span class="string">'#'</span>).<span class="built_in">display</span>(cout);    <span class="comment">// calls non const version</span></span><br><span class="line">blank.<span class="built_in">display</span>(cout);    <span class="comment">// calls const version</span></span><br></pre></td></tr></tbody></table></figure><h3 id="类类型class-types"><a class="markdownIt-Anchor" href="#类类型class-types"></a> 类类型（Class Types）</h3><p>每个类定义了唯一的类型。即使两个类的成员列表完全一致，它们也是不同的类型。</p><p>可以仅仅声明一个类而暂时不定义它。这种声明被称作前向声明（forward declaration），用于引入类的名字。在类声明之后定义之前都是一个不完全类型（incomplete type）。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span>;   <span class="comment">// declaration of the Screen class</span></span><br></pre></td></tr></tbody></table></figure><p>可以定义指向不完全类型的指针或引用，也可以声明（不能定义）以不完全类型作为参数或返回类型的函数。</p><p>只有当类全部完成后才算被定义，所以一个类的成员类型不能是该类本身。但是一旦类的名字出现，就可以被认为是声明过了，因此类可以包含指向它自身类型的引用或指针。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Link_screen</span></span><br><span class="line">{</span><br><span class="line">    Screen window;</span><br><span class="line">    Link_screen *next;</span><br><span class="line">    Link_screen *prev;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h3 id="友元再探friendship-revisited"><a class="markdownIt-Anchor" href="#友元再探friendship-revisited"></a> 友元再探（Friendship Revisited）</h3><p>除了普通函数，类还可以把其他类或其他类的成员函数声明为友元。友元类的成员函数可以访问此类包括非公有成员在内的所有成员。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span> </span><br><span class="line">{</span><br><span class="line">    <span class="comment">// Window_mgr members can access the private parts of class Screen</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">Window_mgr</span>;</span><br><span class="line">    <span class="comment">// ... rest of the Screen class</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>友元函数可以直接定义在类的内部，这种函数是隐式内联的。但是必须在类外部提供相应声明令函数可见。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>{ <span class="comment">/* friend function can be defined in the class body */</span> }</span><br><span class="line">    <span class="built_in">X</span>() { <span class="built_in">f</span>(); }   <span class="comment">// error: no declaration for f</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">h</span><span class="params">()</span></span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">X::g</span><span class="params">()</span> </span>{ <span class="keyword">return</span> <span class="built_in">f</span>(); }     <span class="comment">// error: f hasn't been declared</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;   <span class="comment">// declares the function defined inside X</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">X::h</span><span class="params">()</span> </span>{ <span class="keyword">return</span> <span class="built_in">f</span>(); }     <span class="comment">// ok: declaration for f is now in scope</span></span><br></pre></td></tr></tbody></table></figure><p>友元关系不存在传递性。</p><p>把其他类的成员函数声明为友元时，必须明确指定该函数所属的类名。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// Window_mgr::clear must have been declared before class Screen</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">Window_mgr::clear</span><span class="params">(ScreenIndex)</span></span>;</span><br><span class="line">    <span class="comment">// ... rest of the Screen class</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>如果类想把一组重载函数声明为友元，需要对这组函数中的每一个分别声明。</p><h2 id="类的作用域class-scope"><a class="markdownIt-Anchor" href="#类的作用域class-scope"></a> 类的作用域（Class Scope）</h2><p>当成员函数定义在类外时，返回类型中使用的名字位于类的作用域之外，此时返回类型必须指明它是哪个类的成员。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Window_mgr</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// add a Screen to the window and returns its index</span></span><br><span class="line">    <span class="function">ScreenIndex <span class="title">addScreen</span><span class="params">(<span class="type">const</span> Screen&amp;)</span></span>;</span><br><span class="line">    <span class="comment">// other members as before</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// return type is seen before we're in the scope of Window_mgr</span></span><br><span class="line"><span class="function">Window_mgr::ScreenIndex <span class="title">Window_mgr::addScreen</span><span class="params">(<span class="type">const</span> Screen &amp;s)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    screens.<span class="built_in">push_back</span>(s);</span><br><span class="line">    <span class="keyword">return</span> screens.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="名字查找与作用域name-lookup-and-class-scope"><a class="markdownIt-Anchor" href="#名字查找与作用域name-lookup-and-class-scope"></a> 名字查找与作用域（Name Lookup and Class Scope）</h3><p>成员函数体直到整个类可见后才会被处理，因此它能使用类中定义的任何名字。</p><p>声明中使用的名字，包括返回类型或参数列表，都必须确保使用前可见。</p><p>如果类的成员使用了外层作用域的某个名字，而该名字表示一种类型，则类不能在之后重新定义该名字。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> Money;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Money <span class="title">balance</span><span class="params">()</span> </span>{ <span class="keyword">return</span> bal; } <span class="comment">// uses Money from the outer scop</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">double</span> Money; <span class="comment">// error: cannot redefine Money</span></span><br><span class="line">    Money bal;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>类型名定义通常出现在类起始处，这样能确保所有使用该类型的成员都位于类型名定义之后。</p><p>成员函数中名字的解析顺序：</p><ul><li>在成员函数内查找该名字的声明，只有在函数使用之前出现的声明才会被考虑。</li><li>如果在成员函数内没有找到，则会在类内继续查找，这时会考虑类的所有成员。</li><li>如果类内也没有找到，会在成员函数定义之前的作用域查找。</li></ul><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// it is generally a bad idea to use the same name for a parameter and a member</span></span><br><span class="line"><span class="type">int</span> height;   <span class="comment">// defines a name subsequently used inside Screen</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> std::string::size_type pos;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dummy_fcn</span><span class="params">(pos height)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        cursor = width * height;  <span class="comment">// which height? the parameter</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    pos cursor = <span class="number">0</span>;</span><br><span class="line">    pos height = <span class="number">0</span>, width = <span class="number">0</span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>可以通过作用域运算符<code>::</code>或显式<code>this</code>指针来强制访问被隐藏的类成员。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// bad practice: names local to member functions shouldn't hide member names</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Screen::dummy_fcn</span><span class="params">(pos height)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cursor = width * <span class="keyword">this</span>-&gt;height;  <span class="comment">// member height</span></span><br><span class="line">    <span class="comment">// alternative way to indicate the member</span></span><br><span class="line">    cursor = width * Screen::height;  <span class="comment">// member height</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// good practice: don't use a member name for a parameter or other local variable</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Screen::dummy_fcn</span><span class="params">(pos ht)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cursor = width * height;  <span class="comment">// member height</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="构造函数再探constructors-revisited"><a class="markdownIt-Anchor" href="#构造函数再探constructors-revisited"></a> 构造函数再探（Constructors Revisited）</h2><h3 id="构造函数初始值列表constructor-initializer-list"><a class="markdownIt-Anchor" href="#构造函数初始值列表constructor-initializer-list"></a> 构造函数初始值列表（Constructor Initializer List）</h3><p>如果没有在构造函数初始值列表中显式初始化成员，该成员会在构造函数体之前执行默认初始化。</p><p>如果成员是<code>const</code>、引用，或者是某种未定义默认构造函数的类类型，必须在初始值列表中将其初始化。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConstRef</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ConstRef</span>(<span class="type">int</span> ii);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> ci;</span><br><span class="line">    <span class="type">int</span> &amp;ri;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// ok: explicitly initialize reference and const members</span></span><br><span class="line">ConstRef::<span class="built_in">ConstRef</span>(<span class="type">int</span> ii): <span class="built_in">i</span>(ii), <span class="built_in">ci</span>(ii), <span class="built_in">ri</span>(i) { }</span><br></pre></td></tr></tbody></table></figure><p>最好令构造函数初始值的顺序与成员声明的顺序一致，并且尽量避免使用某些成员初始化其他成员。</p><p>如果一个构造函数为所有参数都提供了默认实参，则它实际上也定义了默认构造函数。</p><h3 id="委托构造函数delegating-constructors"><a class="markdownIt-Anchor" href="#委托构造函数delegating-constructors"></a> 委托构造函数（Delegating Constructors）</h3><p>C++11扩展了构造函数初始值功能，可以定义委托构造函数。委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// defines the default constructor as well as one that takes a string argument</span></span><br><span class="line">    <span class="built_in">Sales_data</span>(std::string s = <span class="string">""</span>): <span class="built_in">bookNo</span>(s) { }</span><br><span class="line">    <span class="comment">// remaining constructors unchanged</span></span><br><span class="line">    <span class="built_in">Sales_data</span>(std::string s, <span class="type">unsigned</span> cnt, <span class="type">double</span> rev):</span><br><span class="line">        <span class="built_in">bookNo</span>(s), <span class="built_in">units_sold</span>(cnt), <span class="built_in">revenue</span>(rev*cnt) { }</span><br><span class="line">    <span class="built_in">Sales_data</span>(std::istream &amp;is) { <span class="built_in">read</span>(is, *<span class="keyword">this</span>); }</span><br><span class="line">    <span class="comment">// remaining members as before</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="默认构造函数的作用the-role-of-the-default-constructor"><a class="markdownIt-Anchor" href="#默认构造函数的作用the-role-of-the-default-constructor"></a> 默认构造函数的作用（The Role of the Default Constructor）</h3><p>当对象被默认初始化或值初始化时会自动执行默认构造函数。</p><p>默认初始化的发生情况：</p><ul><li>在块作用域内不使用初始值定义非静态变量或数组。</li><li>类本身含有类类型的成员且使用合成默认构造函数。</li><li>类类型的成员没有在构造函数初始值列表中显式初始化。</li></ul><p>值初始化的发生情况：</p><ul><li>数组初始化时提供的初始值数量少于数组大小。</li><li>不使用初始值定义局部静态变量。</li><li>通过<code>T()</code>形式（<em>T</em>为类型）的表达式显式地请求值初始化。</li></ul><p>类必须包含一个默认构造函数。</p><p>如果想定义一个使用默认构造函数进行初始化的对象，应该去掉对象名后的空括号对。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">Sales_data <span class="title">obj</span><span class="params">()</span></span>;   <span class="comment">// oops! declares a function, not an object</span></span><br><span class="line">Sales_data obj2;    <span class="comment">// ok: obj2 is an object, not a function</span></span><br></pre></td></tr></tbody></table></figure><h3 id="隐式的类类型转换implicit-class-type-conversions"><a class="markdownIt-Anchor" href="#隐式的类类型转换implicit-class-type-conversions"></a> 隐式的类类型转换（Implicit Class-Type Conversions）</h3><p>如果构造函数只接受一个实参，则它实际上定义了转换为此类类型的隐式转换机制。这种构造函数被称为转换构造函数（converting constructor）。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">string null_book = <span class="string">"9-999-99999-9"</span>;</span><br><span class="line"><span class="comment">// constructs a temporary Sales_data object</span></span><br><span class="line"><span class="comment">// with units_sold and revenue equal to 0 and bookNo equal to null_book</span></span><br><span class="line">item.<span class="built_in">combine</span>(null_book);</span><br></pre></td></tr></tbody></table></figure><p>编译器只会自动执行一步类型转换。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// error: requires two user-defined conversions:</span></span><br><span class="line"><span class="comment">//   (1) convert "9-999-99999-9" to string</span></span><br><span class="line"><span class="comment">//   (2) convert that (temporary) string to Sales_data</span></span><br><span class="line">item.<span class="built_in">combine</span>(<span class="string">"9-999-99999-9"</span>);</span><br><span class="line"><span class="comment">// ok: explicit conversion to string, implicit conversion to Sales_data</span></span><br><span class="line">item.<span class="built_in">combine</span>(<span class="built_in">string</span>(<span class="string">"9-999-99999-9"</span>));</span><br><span class="line"><span class="comment">// ok: implicit conversion to string, explicit conversion to Sales_data</span></span><br><span class="line">item.<span class="built_in">combine</span>(<span class="built_in">Sales_data</span>(<span class="string">"9-999-99999-9"</span>));</span><br></pre></td></tr></tbody></table></figure><p>在要求隐式转换的程序上下文中，可以通过将构造函数声明为<code>explicit</code>的加以阻止。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="type">const</span> std::string &amp;s, <span class="type">unsigned</span> n, <span class="type">double</span> p):</span><br><span class="line">        <span class="built_in">bookNo</span>(s), <span class="built_in">units_sold</span>(n), <span class="built_in">revenue</span>(p*n) { }</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Sales_data</span><span class="params">(<span class="type">const</span> std::string &amp;s)</span>: bookNo(s) {</span> }</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Sales_data</span><span class="params">(std::istream&amp;)</span></span>;</span><br><span class="line">    <span class="comment">// remaining members as before</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><code>explicit</code>关键字只对接受一个实参的构造函数有效。</p><p>只能在类内声明构造函数时使用<code>explicit</code>关键字，在类外定义时不能重复。</p><p>执行拷贝初始化时（使用<code>=</code>）会发生隐式转换，所以<code>explicit</code>构造函数只能用于直接初始化。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">Sales_data <span class="title">item1</span> <span class="params">(null_book)</span></span>;   <span class="comment">// ok: direct initialization</span></span><br><span class="line"><span class="comment">// error: cannot use the copy form of initialization with an explicit constructor</span></span><br><span class="line">Sales_data item2 = null_book;</span><br></pre></td></tr></tbody></table></figure><p>可以使用<code>explicit</code>构造函数显式地强制转换类型。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// ok: the argument is an explicitly constructed Sales_data object</span></span><br><span class="line">item.<span class="built_in">combine</span>(<span class="built_in">Sales_data</span>(null_book));</span><br><span class="line"><span class="comment">// ok: static_cast can use an explicit constructor</span></span><br><span class="line">item.<span class="built_in">combine</span>(<span class="built_in">static_cast</span>&lt;Sales_data&gt;(cin));</span><br></pre></td></tr></tbody></table></figure><h3 id="聚合类aggregate-classes"><a class="markdownIt-Anchor" href="#聚合类aggregate-classes"></a> 聚合类（Aggregate Classes）</h3><p>聚合类满足如下条件：</p><ul><li>所有成员都是<code>public</code>的。</li><li>没有定义任何构造函数。</li><li>没有类内初始值。</li><li>没有基类。</li><li>没有虚函数。</li></ul><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Data</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> ival;</span><br><span class="line">    string s;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>可以使用一个用花括号包围的成员初始值列表初始化聚合类的数据成员。初始值顺序必须与声明顺序一致。如果初始值列表中的元素个数少于类的成员个数，则靠后的成员被值初始化。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// val1.ival = 0; val1.s = string("Anna")</span></span><br><span class="line">Data val1 = { <span class="number">0</span>, <span class="string">"Anna"</span> };</span><br></pre></td></tr></tbody></table></figure><h3 id="字面值常量类literal-classes"><a class="markdownIt-Anchor" href="#字面值常量类literal-classes"></a> 字面值常量类（Literal Classes）</h3><p>数据成员都是字面值类型的聚合类是字面值常量类。或者一个类不是聚合类，但符合下列条件，则也是字面值常量类：</p><ul><li>数据成员都是字面值类型。</li><li>类至少含有一个<code>constexpr</code>构造函数。</li><li>如果数据成员含有类内初始值，则内置类型成员的初始值必须是常量表达式。如果成员属于类类型，则初始值必须使用成员自己的<code>constexpr</code>构造函数。</li><li>类必须使用析构函数的默认定义。</li></ul><p><code>constexpr</code>构造函数用于生成<code>constexpr</code>对象以及<code>constexpr</code>函数的参数或返回类型。</p><p><code>constexpr</code>构造函数必须初始化所有数据成员，初始值使用<code>constexpr</code>构造函数或常量表达式。</p><h2 id="类的静态成员static-class-members"><a class="markdownIt-Anchor" href="#类的静态成员static-class-members"></a> 类的静态成员（static Class Members）</h2><p>使用关键字<code>static</code>可以声明类的静态成员。静态成员存在于任何对象之外，对象中不包含与静态成员相关的数据。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">calculate</span><span class="params">()</span> </span>{ amount += amount * interestRate; }</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">rate</span><span class="params">()</span> </span>{ <span class="keyword">return</span> interestRate; }</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">rate</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string owner;</span><br><span class="line">    <span class="type">double</span> amount;</span><br><span class="line">    <span class="type">static</span> <span class="type">double</span> interestRate;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">initRate</span><span class="params">()</span></span>;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>由于静态成员不与任何对象绑定，因此静态成员函数不能声明为<code>const</code>的，也不能在静态成员函数内使用<code>this</code>指针。</p><p>用户代码可以使用作用域运算符访问静态成员，也可以通过类对象、引用或指针访问。类的成员函数可以直接访问静态成员。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">double</span> r;</span><br><span class="line">r = Account::<span class="built_in">rate</span>(); <span class="comment">// access a static member using the scope operator</span></span><br><span class="line"></span><br><span class="line">Account ac1;</span><br><span class="line">Account *ac2 = &amp;ac1;</span><br><span class="line"><span class="comment">// equivalent ways to call the static member rate function</span></span><br><span class="line">r = ac1.<span class="built_in">rate</span>(); <span class="comment">// through an Account object or reference</span></span><br><span class="line">r = ac2-&gt;<span class="built_in">rate</span>(); <span class="comment">// through a pointer to an Account object</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">calculate</span><span class="params">()</span> </span>{ amount += amount * interestRate; }</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">double</span> interestRate;</span><br><span class="line">    <span class="comment">// remaining members as before</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>在类外部定义静态成员时，不能重复<code>static</code>关键字，其只能用于类内部的声明语句。</p><p>由于静态数据成员不属于类的任何一个对象，因此它们并不是在创建类对象时被定义的。通常情况下，不应该在类内部初始化静态成员。而必须在类外部定义并初始化每个静态成员。一个静态成员只能被定义一次。一旦它被定义，就会一直存在于程序的整个生命周期中。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// define and initialize a static class member</span></span><br><span class="line"><span class="type">double</span> Account::interestRate = <span class="built_in">initRate</span>();</span><br></pre></td></tr></tbody></table></figure><p>建议把静态数据成员的定义与其他非内联函数的定义放在同一个源文件中，这样可以确保对象只被定义一次。</p><p>尽管在通常情况下，不应该在类内部初始化静态成员。但是可以为静态成员提供<code>const</code>整数类型的类内初始值，不过要求静态成员必须是字面值常量类型的<code>constexpr</code>。初始值必须是常量表达式。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">rate</span><span class="params">()</span> </span>{ <span class="keyword">return</span> interestRate; }</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">rate</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> period = <span class="number">30</span>;  <span class="comment">// period is a constant</span></span><br><span class="line">    <span class="type">double</span> daily_tbl[period];</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>静态数据成员的类型可以是它所属的类类型。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">static</span> Bar mem1;   <span class="comment">// ok: static member can have incomplete type</span></span><br><span class="line">    Bar *mem2;    <span class="comment">// ok: pointer member can have incomplete type</span></span><br><span class="line">    Bar mem3;   <span class="comment">// error: data members must have complete type</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以使用静态成员作为函数的默认实参。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// bkground refers to the static member</span></span><br><span class="line">    <span class="comment">// declared later in the class definition</span></span><br><span class="line">    <span class="function">Screen&amp; <span class="title">clear</span><span class="params">(<span class="type">char</span> = bkground)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">char</span> bkground;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter06 函数</title>
      <link href="/posts/8bc5.html"/>
      <url>/posts/8bc5.html</url>
      
        <content type="html"><![CDATA[<h2 id="函数基础function-basics"><a class="markdownIt-Anchor" href="#函数基础function-basics"></a> 函数基础（Function Basics）</h2><p>典型的函数定义包括返回类型（return type）、函数名字、由0个或多个形式参数（parameter，简称形参）组成的列表和函数体（function body）。函数执行的操作在函数体中指明。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// factorial of val is val * (val - 1) * (val - 2) . . . * ((val - (val - 1)) * 1)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fact</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">1</span>;    <span class="comment">// local variable to hold the result as we calculate it</span></span><br><span class="line">    <span class="keyword">while</span> (val &gt; <span class="number">1</span>)</span><br><span class="line">    ret *= val--;   <span class="comment">// assign ret * val to ret and decrement val</span></span><br><span class="line">    <span class="keyword">return</span> ret;     <span class="comment">// return the result</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序通过调用运算符（call operator）来执行函数。调用运算符的形式之一是一对圆括号<code>()</code>，作用于一个表达式，该表达式是函数或者指向函数的指针；圆括号内是一个用逗号隔开的实际参数（argument，简称实参）列表，用来初始化函数形参。调用表达式的类型就是函数的返回类型。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> j = <span class="built_in">fact</span>(<span class="number">5</span>);    <span class="comment">// j equals 120, i.e., the result of fact(5)</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"5! is "</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>函数调用完成两项工作：</p><ul><li>用实参初始化对应的形参。</li><li>将控制权从主调函数转移给被调函数。此时，主调函数（calling function）的执行被暂时中断，被调函数（called function）开始执行。</li></ul><p><code>return</code>语句结束函数的执行过程，完成两项工作：</p><ul><li>返回<code>return</code>语句中的值（可能没有值）。</li><li>将控制权从被调函数转移回主调函数，函数的返回值用于初始化调用表达式的结果。</li></ul><p>实参是形参的初始值，两者的顺序和类型必须一一对应。</p><p>函数的形参列表可以为空，但是不能省略。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">()</span> </span>{ <span class="comment">/* ... */</span> }      <span class="comment">// implicit void parameter list</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(<span class="type">void</span>)</span> </span>{ <span class="comment">/* ... */</span> }  <span class="comment">// explicit void parameter list</span></span><br></pre></td></tr></tbody></table></figure><p>形参列表中的形参通常用逗号隔开，每个形参都是含有一个声明符的声明，即使两个形参类型一样，也必须把两个类型声明都写出来。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f3</span><span class="params">(<span class="type">int</span> v1, v2)</span> </span>{ <span class="comment">/* ... */</span> }      <span class="comment">// error</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f4</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> </span>{ <span class="comment">/* ... */</span> }  <span class="comment">// ok</span></span><br></pre></td></tr></tbody></table></figure><p>函数的任意两个形参不能同名，函数最外层作用域中的局部变量也不能使用与函数形参一样的名字。</p><p>形参的名字是可选的，但是无法使用未命名的形参。即使某个形参不被函数使用，也必须为它提供一个实参。</p><p>函数的返回类型不能是数组类型或者函数类型，但可以是指向数组或函数的指针。</p><h3 id="局部对象local-objects"><a class="markdownIt-Anchor" href="#局部对象local-objects"></a> 局部对象（Local Objects）</h3><p>形参和函数体内定义的变量统称为局部变量（local variable）。</p><p>局部静态对象（local static object）在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序结束才被销毁，对象所在的函数结束执行并不会对它产生影响。在变量类型前添加关键字<code>static</code>可以定义局部静态对象。</p><p>如果局部静态对象没有显式的初始值，它将执行值初始化。</p><h3 id="函数声明function-declarations"><a class="markdownIt-Anchor" href="#函数声明function-declarations"></a> 函数声明（Function Declarations）</h3><p>和变量类似，函数只能定义一次，但可以声明多次。函数声明也叫做函数原型（function prototype）。</p><p>函数应该在头文件中声明，在源文件中定义。定义函数的源文件应该包含含有函数声明的头文件。</p><h3 id="分离式编译separate-compilation"><a class="markdownIt-Anchor" href="#分离式编译separate-compilation"></a> 分离式编译（Separate Compilation）</h3><p>分离式编译允许我们把程序按照逻辑关系分割到几个文件中去，每个文件独立编译。这一过程通常会产生后缀名是*.obj<em>或</em>.o*的文件，该文件包含对象代码（object code）。之后编译器把对象文件链接（link）在一起形成可执行文件。</p><h2 id="参数传递argument-passing"><a class="markdownIt-Anchor" href="#参数传递argument-passing"></a> 参数传递（Argument Passing）</h2><p>形参初始化的机理与变量初始化一样。</p><p>形参的类型决定了形参和实参交互的方式：</p><ul><li>当形参是引用类型时，它对应的实参被引用传递（passed by reference），函数被传引用调用（called by reference）。引用形参是它对应实参的别名。</li><li>当形参不是引用类型时，形参和实参是两个相互独立的对象，实参的值会被拷贝给形参（值传递，passed by value），函数被传值调用（called by value）。</li></ul><h3 id="传值参数passing-arguments-by-value"><a class="markdownIt-Anchor" href="#传值参数passing-arguments-by-value"></a> 传值参数（Passing Arguments by Value）</h3><p>如果形参不是引用类型，则函数对形参做的所有操作都不会影响实参。</p><p>使用指针类型的形参可以访问或修改函数外部的对象。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// function that takes a pointer and sets the pointed-to value to zero</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(<span class="type">int</span> *ip)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    *ip = <span class="number">0</span>;  <span class="comment">// changes the value of the object to which ip points</span></span><br><span class="line">    ip = <span class="number">0</span>;   <span class="comment">// changes only the local copy of ip; the argument is unchanged</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果想在函数体内访问或修改函数外部的对象，建议使用引用形参代替指针形参。</p><h3 id="传引用参数passing-arguments-by-reference"><a class="markdownIt-Anchor" href="#传引用参数passing-arguments-by-reference"></a> 传引用参数（Passing Arguments by Reference）</h3><p>通过使用引用形参，函数可以改变实参的值。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// function that takes a reference to an int and sets the given object to zero</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(<span class="type">int</span> &amp;i)</span>  <span class="comment">// i is just another name for the object passed to reset</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    i = <span class="number">0</span>;  <span class="comment">// changes the value of the object to which i refers</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>使用引用形参可以避免拷贝操作，拷贝大的类类型对象或容器对象比较低效。另外有的类类型（如IO类型）根本就不支持拷贝操作，这时只能通过引用形参访问该类型的对象。</p><p>除了内置类型、函数对象和标准库迭代器外，其他类型的参数建议以引用方式传递。</p><p>如果函数无须改变引用形参的值，最好将其声明为常量引用。</p><p>一个函数只能返回一个值，但利用引用形参可以使函数返回额外信息。</p><h3 id="const形参和实参const-parameters-and-arguments"><a class="markdownIt-Anchor" href="#const形参和实参const-parameters-and-arguments"></a> const形参和实参（const Parameters and Arguments）</h3><p>当形参有顶层<code>const</code>时，传递给它常量对象或非常量对象都是可以的。</p><p>可以使用非常量对象初始化一个底层<code>const</code>形参，但是反过来不行。</p><p>把函数不会改变的形参定义成普通引用会极大地限制函数所能接受的实参类型，同时也会给别人一种误导，即函数可以修改实参的值。</p><h3 id="数组形参array-parameters"><a class="markdownIt-Anchor" href="#数组形参array-parameters"></a> 数组形参（Array Parameters）</h3><p>因为不能拷贝数组，所以无法以值传递的方式使用数组参数，但是可以把形参写成类似数组的形式。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// each function has a single parameter of type const int*</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span>[])</span></span>;    <span class="comment">// shows the intent that the function takes an array</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span>[<span class="number">10</span>])</span></span>;  <span class="comment">// dimension for documentation purposes (at best)</span></span><br></pre></td></tr></tbody></table></figure><p>因为数组会被转换成指针，所以当我们传递给函数一个数组时，实际上传递的是指向数组首元素的指针。</p><p>因为数组是以指针的形式传递给函数的，所以一开始函数并不知道数组的确切尺寸，调用者应该为此提供一些额外信息。</p><p>以数组作为形参的函数必须确保使用数组时不会越界。</p><p>如果函数不需要对数组元素执行写操作，应该把数组形参定义成指向常量的指针。</p><p>形参可以是数组的引用，但此时维度是形参类型的一部分，函数只能作用于指定大小的数组。</p><p>将多维数组传递给函数时，数组第二维（以及后面所有维度）的大小是数组类型的一部分，不能省略。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">f</span>(<span class="type">int</span> &amp;arr[<span class="number">10</span>])     <span class="comment">// error: declares arr as an array of references</span></span><br><span class="line"><span class="built_in">f</span>(<span class="built_in">int</span> (&amp;arr)[<span class="number">10</span>])   <span class="comment">// ok: arr is a reference to an array of ten ints</span></span><br></pre></td></tr></tbody></table></figure><h3 id="main处理命令行选项mainhandling-command-line-options"><a class="markdownIt-Anchor" href="#main处理命令行选项mainhandling-command-line-options"></a> main：处理命令行选项（main：Handling Command-Line Options）</h3><p>可以在命令行中向<code>main</code>函数传递参数，形式如下：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>{ <span class="comment">/*...*/</span> }</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>{ <span class="comment">/*...*/</span> }</span><br></pre></td></tr></tbody></table></figure><p>第二个形参<em>argv</em>是一个数组，数组元素是指向C风格字符串的指针；第一个形参<em>argc</em>表示数组中字符串的数量。</p><p>当实参传递给<code>main</code>函数后，<em>argv</em>的第一个元素指向程序的名字或者一个空字符串，接下来的元素依次传递命令行提供的实参。最后一个指针之后的元素值保证为0。</p><p>在<em>Visual Studio</em>中可以设置<code>main</code>函数调试参数：</p><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200825173626.png" alt=""></p><h3 id="含有可变形参的函数functions-with-varying-parameters"><a class="markdownIt-Anchor" href="#含有可变形参的函数functions-with-varying-parameters"></a> 含有可变形参的函数（Functions with Varying Parameters）</h3><p>C++11新标准提供了两种主要方法处理实参数量不定的函数。</p><ul><li><p>如果实参类型相同，可以使用<code>initializer_list</code>标准库类型。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_msg</span><span class="params">(initializer_list&lt;string&gt; il)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> beg = il.<span class="built_in">begin</span>(); beg != il.<span class="built_in">end</span>(); ++beg)</span><br><span class="line">    cout &lt;&lt; *beg &lt;&lt; <span class="string">" "</span> ;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>如果实参类型不同，可以定义可变参数模板。</p></li></ul><p>C++还可以使用省略符形参传递可变数量的实参，但这种功能一般只用在与C函数交换的接口程序中。</p><p><code>initializer_list</code>是一种标准库类型，定义在头文件<em>initializer_list</em>中，表示某种特定类型的值的数组。</p><p><code>initializer_list</code>提供的操作：</p><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200825173735.png" alt=""></p><p>拷贝或赋值一个<code>initializer_list</code>对象不会拷贝列表中的元素。拷贝后，原始列表和副本共享元素。</p><p><code>initializer_list</code>对象中的元素永远是常量值。</p><p>如果想向<code>initializer_list</code>形参传递一个值的序列，则必须把序列放在一对花括号内。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (expected != actual)</span><br><span class="line">    <span class="built_in">error_msg</span>(<span class="built_in">ErrCode</span>(<span class="number">42</span>), {<span class="string">"functionX"</span>, expected, actual});</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">error_msg</span>(<span class="built_in">ErrCode</span>(<span class="number">0</span>), {<span class="string">"functionX"</span>, <span class="string">"okay"</span>});</span><br></pre></td></tr></tbody></table></figure><p>因为<code>initializer_list</code>包含<code>begin</code>和<code>end</code>成员，所以可以使用范围<code>for</code>循环处理其中的元素。</p><p>省略符形参是为了便于C++程序访问某些特殊的C代码而设置的，这些代码使用了名为<code>varargs</code>的C标准库功能。通常，省略符形参不应该用于其他目的。</p><p>省略符形参应该仅仅用于C和C++通用的类型，大多数类类型的对象在传递给省略符形参时都无法正确拷贝。</p><h2 id="返回类型和return语句return-types-and-the-return-statement"><a class="markdownIt-Anchor" href="#返回类型和return语句return-types-and-the-return-statement"></a> 返回类型和return语句（Return Types and the return Statement）</h2><p><code>return</code>语句有两种形式，作用是终止当前正在执行的函数并返回到调用该函数的地方。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">return</span> expression;</span><br></pre></td></tr></tbody></table></figure><h3 id="无返回值函数functions-with-no-return-value"><a class="markdownIt-Anchor" href="#无返回值函数functions-with-no-return-value"></a> 无返回值函数（Functions with No Return Value）</h3><p>没有返回值的<code>return</code>语句只能用在返回类型是<code>void</code>的函数中。返回<code>void</code>的函数可以省略<code>return</code>语句，因为在这类函数的最后一条语句后面会隐式地执行<code>return</code>。</p><p>通常情况下，如果<code>void</code>函数想在其中间位置提前退出，可以使用<code>return</code>语句。</p><p>一个返回类型是<code>void</code>的函数也能使用<code>return</code>语句的第二种形式，不过此时<code>return</code>语句的<em>expression</em>必须是另一个返回<code>void</code>的函数。</p><p>强行令<code>void</code>函数返回其他类型的表达式将产生编译错误。</p><h3 id="有返回值函数functions-that-return-a-value"><a class="markdownIt-Anchor" href="#有返回值函数functions-that-return-a-value"></a> 有返回值函数（Functions That Return a Value）</h3><p><code>return</code>语句的第二种形式提供了函数的结果。只要函数的返回类型不是<code>void</code>，该函数内的每条<code>return</code>语句就必须返回一个值，并且返回值的类型必须与函数的返回类型相同，或者能隐式地转换成函数的返回类型（<code>main</code>函数例外）。</p><p>在含有<code>return</code>语句的循环后面应该也有一条<code>return</code>语句，否则程序就是错误的，但很多编译器无法发现此错误。</p><p>函数返回一个值的方式和初始化一个变量或形参的方式完全一样：返回的值用于初始化调用点的一个临时量，该临时量就是函数调用的结果。</p><p>如果函数返回引用类型，则该引用仅仅是它所引用对象的一个别名。</p><p>函数不应该返回局部对象的指针或引用，因为一旦函数完成，局部对象将被释放。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// disaster: this function returns a reference to a local object</span></span><br><span class="line"><span class="function"><span class="type">const</span> string &amp;<span class="title">manip</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    string ret;</span><br><span class="line">    <span class="comment">// transform ret in some way</span></span><br><span class="line">    <span class="keyword">if</span> (!ret.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">return</span> ret;   <span class="comment">// WRONG: returning a reference to a local object!</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Empty"</span>;   <span class="comment">// WRONG: "Empty" is a local temporary string</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果函数返回指针、引用或类的对象，则可以使用函数调用的结果访问结果对象的成员。</p><p>调用一个返回引用的函数会得到左值，其他返回类型得到右值。</p><p>C++11规定，函数可以返回用花括号包围的值的列表。同其他返回类型一样，列表也用于初始化表示函数调用结果的临时量。如果列表为空，临时量执行值初始化；否则返回的值由函数的返回类型决定。</p><ul><li><p>如果函数返回内置类型，则列表内最多包含一个值，且该值所占空间不应该大于目标类型的空间。</p></li><li><p>如果函数返回类类型，由类本身定义初始值如何使用。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">process</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// . . .</span></span><br><span class="line">    <span class="comment">// expected and actual are strings</span></span><br><span class="line">    <span class="keyword">if</span> (expected.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">return</span> {};  <span class="comment">// return an empty vector</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (expected == actual)</span><br><span class="line">        <span class="keyword">return</span> {<span class="string">"functionX"</span>, <span class="string">"okay"</span>};  <span class="comment">// return list-initialized vector</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> {<span class="string">"functionX"</span>, expected, actual};</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><p><code>main</code>函数可以没有<code>return</code>语句直接结束。如果控制流到达了<code>main</code>函数的结尾处并且没有<code>return</code>语句，编译器会隐式地插入一条返回0的<code>return</code>语句。</p><p><code>main</code>函数的返回值可以看作是状态指示器。返回0表示执行成功，返回其他值表示执行失败，其中非0值的具体含义依机器而定。</p><p>为了使<code>main</code>函数的返回值与机器无关，头文件<em>cstdlib</em>定义了<code>EXIT_SUCCESS</code>和<code>EXIT_FAILURE</code>这两个预处理变量，分别表示执行成功和失败。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (some_failure)</span><br><span class="line">        <span class="keyword">return</span> EXIT_FAILURE; <span class="comment">// defined in cstdlib</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> EXIT_SUCCESS; <span class="comment">// defined in cstdlib</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>建议使用预处理变量<code>EXIT_SUCCESS</code>和<code>EXIT_FAILURE</code>表示<code>main</code>函数的执行结果。</p><p>如果一个函数调用了它自身，不管这种调用是直接的还是间接的，都称该函数为递归函数（recursive function）。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// calculate val!, which is 1 * 2 * 3 . . . * val</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">factorial</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (val &gt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">factorial</span>(val<span class="number">-1</span>) * val;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在递归函数中，一定有某条路径是不包含递归调用的，否则函数会一直递归下去，直到程序栈空间耗尽为止。</p><p>相对于循环迭代，递归的效率较低。但在某些情况下使用递归可以增加代码的可读性。循环迭代适合处理线性问题（如链表，每个节点有唯一前驱、唯一后继），而递归适合处理非线性问题（如树，每个节点的前驱、后继不唯一）。</p><p><code>main</code>函数不能调用它自身。</p><h3 id="返回数组指针returning-a-pointer-to-an-array"><a class="markdownIt-Anchor" href="#返回数组指针returning-a-pointer-to-an-array"></a> 返回数组指针（Returning a Pointer to an Array）</h3><p>因为数组不能被拷贝，所以函数不能返回数组，但可以返回数组的指针或引用。</p><p>返回数组指针的函数形式如下：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">Type</span> (*<span class="built_in">function</span>(parameter_list))[dimension]</span><br></pre></td></tr></tbody></table></figure><p>其中<em>Type</em>表示元素类型，<em>dimension</em>表示数组大小，*(*function (parameter_list))*两端的括号必须存在。</p><p>C++11允许使用尾置返回类型（trailing return type）简化复杂函数声明。尾置返回类型跟在形参列表后面，并以一个<code>-&gt;</code>符号开头。为了表示函数真正的返回类型在形参列表之后，需要在本应出现返回类型的地方添加<code>auto</code>关键字。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// fcn takes an int argument and returns a pointer to an array of ten ints</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i)</span> -&gt; <span class="title">int</span><span class="params">(*)</span>[10]</span>;</span><br></pre></td></tr></tbody></table></figure><p>任何函数的定义都能使用尾置返回类型，但是这种形式更适用于返回类型比较复杂的函数。</p><p>如果我们知道函数返回的指针将指向哪个数组，就可以使用<code>decltype</code>关键字声明返回类型。但<code>decltype</code>并不会把数组类型转换成指针类型，所以还要在函数声明中添加一个<code>*</code>符号。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> odd[] = {<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>};</span><br><span class="line"><span class="type">int</span> even[] = {<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>};</span><br><span class="line"><span class="comment">// returns a pointer to an array of five int elements</span></span><br><span class="line"><span class="keyword">decltype</span>(odd) *<span class="built_in">arrPtr</span>(<span class="type">int</span> i)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> (i % <span class="number">2</span>) ? &amp;odd : &amp;even;  <span class="comment">// returns a pointer to the array</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="函数重载overloaded-functions"><a class="markdownIt-Anchor" href="#函数重载overloaded-functions"></a> 函数重载（Overloaded Functions）</h2><p>同一作用域内的几个名字相同但形参列表不同的函数叫做重载函数。</p><p><code>main</code>函数不能重载。</p><p>不允许两个函数除了返回类型以外的其他所有要素都相同。</p><p>顶层<code>const</code>不影响传入函数的对象，一个拥有顶层<code>const</code>的形参无法和另一个没有顶层<code>const</code>的形参区分开来。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Phone)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="type">const</span> Phone)</span></span>;  <span class="comment">// redeclares Record lookup(Phone)</span></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Phone*)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Phone* <span class="type">const</span>)</span></span>; <span class="comment">// redeclares Record lookup(Phone*)</span></span><br></pre></td></tr></tbody></table></figure><p>如果形参是某种类型的指针或引用，则通过区分其指向的对象是常量还是非常量可以实现函数重载，此时的<code>const</code>是底层的。当我们传递给重载函数一个非常量对象或者指向非常量对象的指针时，编译器会优先选用非常量版本的函数。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// functions taking const and nonconst references or pointers have different parameters</span></span><br><span class="line"><span class="comment">// declarations for four independent, overloaded functions</span></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Account&amp;)</span></span>;        <span class="comment">// function that takes a reference to Account</span></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="type">const</span> Account&amp;)</span></span>;  <span class="comment">// new function that takes a const reference</span></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Account*)</span></span>;        <span class="comment">// new function, takes a pointer to Account</span></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="type">const</span> Account*)</span></span>;  <span class="comment">// new function, takes a pointer to const</span></span><br></pre></td></tr></tbody></table></figure><p><code>const_cast</code>可以用于函数的重载。当函数的实参不是常量时，将得到普通引用。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// return a reference to the shorter of two strings</span></span><br><span class="line"><span class="function"><span class="type">const</span> string &amp;<span class="title">shorterString</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> s1.<span class="built_in">size</span>() &lt;= s2.<span class="built_in">size</span>() ? s1 : s2;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">string &amp;<span class="title">shorterString</span><span class="params">(string &amp;s1, string &amp;s2)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">auto</span> &amp;r = <span class="built_in">shorterString</span>(<span class="built_in">const_cast</span>&lt;<span class="type">const</span> string&amp;&gt;(s1),</span><br><span class="line">                    <span class="built_in">const_cast</span>&lt;<span class="type">const</span> string&amp;&gt;(s2));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">const_cast</span>&lt;string&amp;&gt;(r);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>函数匹配（function matching）也叫做重载确定（overload resolution），是指编译器将函数调用与一组重载函数中的某一个进行关联的过程。</p><p>调用重载函数时有三种可能的结果：</p><ul><li>编译器找到一个与实参最佳匹配（best match）的函数，并生成调用该函数的代码。</li><li>编译器找不到任何一个函数与实参匹配，发出无匹配（no match）的错误信息。</li><li>有一个以上的函数与实参匹配，但每一个都不是明显的最佳选择，此时编译器发出二义性调用（ambiguous call）的错误信息。</li></ul><h3 id="重载与作用域overloading-and-scope"><a class="markdownIt-Anchor" href="#重载与作用域overloading-and-scope"></a> 重载与作用域（Overloading and Scope）</h3><p>在不同的作用域中无法重载函数名。一旦在当前作用域内找到了所需的名字，编译器就会忽略掉外层作用域中的同名实体。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> string &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">double</span>)</span></span>;     <span class="comment">// overloads the print function</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fooBar</span><span class="params">(<span class="type">int</span> ival)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">bool</span> read = <span class="literal">false</span>;  <span class="comment">// new scope: hides the outer declaration of read</span></span><br><span class="line">    string s = <span class="built_in">read</span>();  <span class="comment">// error: read is a bool variable, not a function</span></span><br><span class="line">    <span class="comment">// bad practice: usually it's a bad idea to declare functions at local scope</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span>)</span></span>;    <span class="comment">// new scope: hides previous instances of print</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Value: "</span>);   <span class="comment">// error: print(const string &amp;) is hidden</span></span><br><span class="line">    <span class="built_in">print</span>(ival);    <span class="comment">// ok: print(int) is visible</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="number">3.14</span>);    <span class="comment">// ok: calls print(int); print(double) is hidden</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在C++中，名字查找发生在类型检查之前。</p><h2 id="特殊用途语言特性features-for-specialized-uses"><a class="markdownIt-Anchor" href="#特殊用途语言特性features-for-specialized-uses"></a> 特殊用途语言特性（Features for Specialized Uses）</h2><h3 id="默认实参default-arguments"><a class="markdownIt-Anchor" href="#默认实参default-arguments"></a> 默认实参（Default Arguments）</h3><p>默认实参作为形参的初始值出现在形参列表中。可以为一个或多个形参定义默认值，不过一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> string::size_type sz;</span><br><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(sz ht = <span class="number">24</span>, sz wid = <span class="number">80</span>, <span class="type">char</span> backgrnd = <span class="string">' '</span>)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>调用含有默认实参的函数时，可以包含该实参，也可以省略该实参。</p><p>如果想使用默认实参，只要在调用函数的时候省略该实参即可。</p><p>虽然多次声明同一个函数是合法的，但是在给定的作用域中一个形参只能被赋予一次默认实参。函数的后续声明只能为之前那些没有默认值的形参添加默认实参，而且该形参右侧的所有形参必须都有默认值。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// no default for the height or width parameters</span></span><br><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(sz, sz, <span class="type">char</span> = <span class="string">' '</span>)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(sz, sz, <span class="type">char</span> = <span class="string">'*'</span>)</span></span>;      <span class="comment">// error: redeclaration</span></span><br><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(sz = <span class="number">24</span>, sz = <span class="number">80</span>, <span class="type">char</span>)</span></span>;  <span class="comment">// ok: adds default</span></span><br></pre></td></tr></tbody></table></figure><p>默认实参只能出现在函数声明和定义其中一处。通常应该在函数声明中指定默认实参，并将声明放在合适的头文件中。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// Error: 编译器向前查找函数声明</span></span><br><span class="line">    <span class="comment">//        fun调用形式与声明不符</span></span><br><span class="line">    <span class="built_in">fun</span>();</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> n = <span class="number">0</span>)</span> </span>{ <span class="comment">/*...*/</span> }</span><br></pre></td></tr></tbody></table></figure><p>局部变量不能作为函数的默认实参。</p><p>用作默认实参的名字在函数声明所在的作用域内解析，但名字的求值过程发生在函数调用时。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// the declarations of wd, def, and ht must appear outside a function</span></span><br><span class="line">sz wd = <span class="number">80</span>;</span><br><span class="line"><span class="type">char</span> def = <span class="string">' '</span>;</span><br><span class="line"><span class="function">sz <span class="title">ht</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(sz = ht(), sz = wd, <span class="type">char</span> = def)</span></span>;</span><br><span class="line">string window = <span class="built_in">screen</span>();   <span class="comment">// calls screen(ht(), 80, ' ')</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    def = <span class="string">'*'</span>;      <span class="comment">// changes the value of a default argument</span></span><br><span class="line">    sz wd = <span class="number">100</span>;    <span class="comment">// hides the outer definition of wd but does not change the</span></span><br><span class="line">    <span class="keyword">default</span></span><br><span class="line">    window = <span class="built_in">screen</span>();  <span class="comment">// calls screen(ht(), 80, '*')</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="内联函数和constexpr函数inline-and-constexpr-functions"><a class="markdownIt-Anchor" href="#内联函数和constexpr函数inline-and-constexpr-functions"></a> 内联函数和constexpr函数（Inline and constexpr Functions）</h3><p>内联函数会在每个调用点上“内联地”展开，省去函数调用所需的一系列工作。定义内联函数时需要在函数的返回类型前添加关键字<code>inline</code>。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// inline version: find the shorter of two strings</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">const</span> string &amp;<span class="title">horterString</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> s1.<span class="built_in">size</span>() &lt;= s2.<span class="built_in">size</span>() ? s1 : s2;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在函数声明和定义中都能使用关键字<code>inline</code>，但是建议只在函数定义时使用。</p><p>一般来说，内联机制适用于优化规模较小、流程直接、调用频繁的函数。内联函数中不允许有循环语句和<code>switch</code>语句，否则函数会被编译为普通函数。</p><p><code>constexpr</code>函数是指能用于常量表达式的函数。<code>constexpr</code>函数的返回类型及所有形参的类型都得是字面值类型。另外C<ins>11标准要求<code>constexpr</code>函数体中必须有且只有一条<code>return</code>语句，但是此限制在C</ins>14标准中被删除。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">new_sz</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> foo = <span class="built_in">new_sz</span>();   <span class="comment">// ok: foo is a constant expression</span></span><br></pre></td></tr></tbody></table></figure><p><code>constexpr</code>函数的返回值可以不是一个常量。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// scale(arg) is a constant expression if arg is a constant expression</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">size_t</span> <span class="title">scale</span><span class="params">(<span class="type">size_t</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">new_sz</span>() * cnt;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[<span class="built_in">scale</span>(<span class="number">2</span>)];  <span class="comment">// ok: scale(2) is a constant expression</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">2</span>;          <span class="comment">// i is not a constant expression</span></span><br><span class="line"><span class="type">int</span> a2[<span class="built_in">scale</span>(i)];   <span class="comment">// error: scale(i) is not a constant expression</span></span><br></pre></td></tr></tbody></table></figure><p><code>constexpr</code>函数被隐式地指定为内联函数。</p><p>和其他函数不同，内联函数和<code>constexpr</code>函数可以在程序中多次定义。因为在编译过程中，编译器需要函数的定义来随时展开函数。对于某个给定的内联函数或<code>constexpr</code>函数，它的多个定义必须完全一致。因此内联函数和<code>constexpr</code>函数通常定义在头文件中。</p><h3 id="调试帮助aids-for-debugging"><a class="markdownIt-Anchor" href="#调试帮助aids-for-debugging"></a> 调试帮助（Aids for Debugging）</h3><table><thead><tr><th style="text-align:center">变量名称</th><th style="text-align:center">内容</th></tr></thead><tbody><tr><td style="text-align:center"><code>__func__</code></td><td style="text-align:center">当前函数名称</td></tr><tr><td style="text-align:center"><code>__FILE__</code></td><td style="text-align:center">当前文件名称</td></tr><tr><td style="text-align:center"><code>__LINE__</code></td><td style="text-align:center">当前行号</td></tr><tr><td style="text-align:center"><code>__TIME__</code></td><td style="text-align:center">文件编译时间</td></tr><tr><td style="text-align:center"><code>__DATE__</code></td><td style="text-align:center">文件编译日期</td></tr></tbody></table><h2 id="函数匹配function-matching"><a class="markdownIt-Anchor" href="#函数匹配function-matching"></a> 函数匹配（Function Matching）</h2><p>函数实参类型与形参类型越接近，它们匹配得越好。</p><p>重载函数集中的函数称为候选函数（candidate function）。</p><p>可行函数（viable function）的形参数量与函数调用所提供的实参数量相等，并且每个实参的类型与对应的形参类型相同，或者能转换成形参的类型。</p><p>调用重载函数时应该尽量避免强制类型转换。</p><h3 id="实参类型转换argument-type-conversions"><a class="markdownIt-Anchor" href="#实参类型转换argument-type-conversions"></a> 实参类型转换（Argument Type Conversions）</h3><p>所有算术类型转换的级别都一样。</p><p>如果载函数的区别在于它们的引用或指针类型的形参是否含有底层<code>const</code>，则调用发生时编译器通过实参是否是常量来决定函数的版本。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Account&amp;)</span></span>;    <span class="comment">// function that takes a reference to Account</span></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="type">const</span> Account&amp;)</span></span>;  <span class="comment">// new function that takes a const reference</span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> Account a;</span><br><span class="line">Account b;</span><br><span class="line"><span class="built_in">lookup</span>(a);  <span class="comment">// calls lookup(const Account&amp;)</span></span><br><span class="line"><span class="built_in">lookup</span>(b);  <span class="comment">// calls lookup(Account&amp;)</span></span><br></pre></td></tr></tbody></table></figure><h2 id="函数指针pointers-to-functions"><a class="markdownIt-Anchor" href="#函数指针pointers-to-functions"></a> 函数指针（Pointers to Functions）</h2><p>要想声明一个可以指向某种函数的指针，只需要用指针替换函数名称即可。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// compares lengths of two strings</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">lengthCompare</span><span class="params">(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;)</span></span>;</span><br><span class="line"><span class="comment">// pf points to a function returning bool that takes two const string references</span></span><br><span class="line"><span class="built_in">bool</span> (*pf)(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;); <span class="comment">// uninitialized</span></span><br></pre></td></tr></tbody></table></figure><p>可以直接使用指向函数的指针来调用函数，无须提前解引用指针。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">pf = lengthCompare; <span class="comment">// pf now points to the function named lengthCompare</span></span><br><span class="line">pf = &amp;lengthCompare; <span class="comment">// equivalent assignment: address-of operator is optional</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> b1 = <span class="built_in">pf</span>(<span class="string">"hello"</span>, <span class="string">"goodbye"</span>);       <span class="comment">// calls lengthCompare</span></span><br><span class="line"><span class="type">bool</span> b2 = (*pf)(<span class="string">"hello"</span>, <span class="string">"goodbye"</span>);    <span class="comment">// equivalent call</span></span><br><span class="line"><span class="type">bool</span> b3 = <span class="built_in">lengthCompare</span>(<span class="string">"hello"</span>, <span class="string">"goodbye"</span>);    <span class="comment">// equivalent call</span></span><br></pre></td></tr></tbody></table></figure><p>对于重载函数，编译器通过指针类型决定函数版本，指针类型必须与重载函数中的某一个精确匹配。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ff</span><span class="params">(<span class="type">int</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ff</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="built_in">void</span> (*pf1)(<span class="type">unsigned</span> <span class="type">int</span>) = ff; <span class="comment">// pf1 points to ff(unsigned)</span></span><br></pre></td></tr></tbody></table></figure><p>可以把函数的形参定义成指向函数的指针。调用时允许直接把函数名当作实参使用，它会自动转换成指针。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// third parameter is a function type and is automatically treated as a pointer to function</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useBigger</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2, <span class="type">bool</span> pf(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;))</span></span>;</span><br><span class="line"><span class="comment">// equivalent declaration: explicitly define the parameter as a pointer to function</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useBigger</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2, <span class="type">bool</span> (*pf)(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// automatically converts the function lengthCompare to a pointer to function</span></span><br><span class="line"><span class="built_in">useBigger</span>(s1, s2, lengthCompare);</span><br></pre></td></tr></tbody></table></figure><p>关键字<code>decltype</code>作用于函数时，返回的是函数类型，而不是函数指针类型。</p><p>函数可以返回指向函数的指针。但返回类型不会像函数类型的形参一样自动地转换成指针，必须显式地将其指定为指针类型。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Exercise of chapter 05</title>
      <link href="/posts/3ea6.html"/>
      <url>/posts/3ea6.html</url>
      
        <content type="html"><![CDATA[<h2 id="exercise_51"><a class="markdownIt-Anchor" href="#exercise_51"></a> exercise_5.1</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    什么是空语句？什么时候会用到空语句？</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    只含义一个单独的分号的语句是空语句。如： ;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    如果在程序的某个地方，语法上需要一条语句但是逻辑上不需要，此时应该使用空语句。</span></span><br><span class="line"><span class="comment">    while (cin &gt;&gt; s &amp;&amp; s != sought)</span></span><br><span class="line"><span class="comment">;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><h2 id="exercise_52"><a class="markdownIt-Anchor" href="#exercise_52"></a> exercise_5.2</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    什么是块？什么时候会用到块？</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    用花括号括起来的语句和声明的序列就是块。</span></span><br><span class="line"><span class="comment">    {</span></span><br><span class="line"><span class="comment">    // ...</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment">    如果在程序的某个地方，语法上需要一条语句，而逻辑上需要多条语句，此时应该使用块</span></span><br><span class="line"><span class="comment">    while (val &lt;= 10) {</span></span><br><span class="line"><span class="comment">        sum += val;</span></span><br><span class="line"><span class="comment">        ++val;</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><h2 id="exercise_53"><a class="markdownIt-Anchor" href="#exercise_53"></a> exercise_5.3</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    使用逗号运算符重写1.4.1节的 while 循环，使它不再需要块，</span></span><br><span class="line"><span class="comment">    观察改写之后的代码可读性提高了还是降低了。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    while (val &lt;= 10)</span></span><br><span class="line"><span class="comment">    sum += val, ++val;.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    代码的可读性反而降低了。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><h2 id="exercise_54"><a class="markdownIt-Anchor" href="#exercise_54"></a> exercise_5.4</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    说明下列例子的含义，如果存在问题，试着修改它。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    (a) while (string::iterator iter != s.end()) {  . . .  }</span></span><br><span class="line"><span class="comment">    (b) while (bool status = find(word)) {  . . .  }</span></span><br><span class="line"><span class="comment">            if (!status) {  . . .  }</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    (a) 这个循环试图用迭代器遍历string，但是变量的定义应该放在循环的外面，目前每次循环都会重新定义一个变量，明显是错误的。</span></span><br><span class="line"><span class="comment">    (b) 这个循环的 while 和 if 是两个独立的语句，if 语句中无法访问 status 变量，正确的做法是应该将 if 语句包含在 while 里面，</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><h2 id="exercise_55"><a class="markdownIt-Anchor" href="#exercise_55"></a> exercise_5.5</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> score; cin &gt;&gt; score;)</span><br><span class="line">    {</span><br><span class="line">        vector&lt;string&gt; garden{<span class="string">"F"</span>, <span class="string">"D"</span>, <span class="string">"C"</span>, <span class="string">"B"</span>, <span class="string">"A"</span>, <span class="string">"A++"</span>};</span><br><span class="line"></span><br><span class="line">        string lettergrade;</span><br><span class="line">        <span class="keyword">if</span>(score&lt;<span class="number">60</span>)</span><br><span class="line">            lettergrade = garden[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span>{</span><br><span class="line">            lettergrade = garden[(score - <span class="number">50</span>) / <span class="number">10</span>];</span><br><span class="line">            <span class="keyword">if</span>(score!=<span class="number">100</span>)</span><br><span class="line">                lettergrade = score % <span class="number">10</span> &gt; <span class="number">7</span> ? <span class="string">"+"</span> : score % <span class="number">10</span> &lt; <span class="number">3</span> ? <span class="string">"-"</span> : <span class="string">""</span>;</span><br><span class="line">            cout &lt;&lt; lettergrade &lt;&lt; endl;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="exercise_56"><a class="markdownIt-Anchor" href="#exercise_56"></a> exercise_5.6</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> score; cin &gt;&gt; score;){</span><br><span class="line">        vector&lt;string&gt; garden{<span class="string">"F"</span>, <span class="string">"D"</span>, <span class="string">"C"</span>, <span class="string">"B"</span>, <span class="string">"A"</span>, <span class="string">"A++"</span>};</span><br><span class="line">        string lettergrade;</span><br><span class="line">        score&lt;<span class="number">60</span>? lettergrade = garden[<span class="number">0</span>] :score!=<span class="number">100</span>? lettergrade = score % <span class="number">10</span> &gt; <span class="number">7</span> ? <span class="string">"+"</span> : score % <span class="number">10</span> &lt; <span class="number">3</span> ? <span class="string">"-"</span> : <span class="string">""</span>:lettergrade = garden[(score - <span class="number">50</span>) / <span class="number">10</span>];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="exercise_57"><a class="markdownIt-Anchor" href="#exercise_57"></a> exercise_5.7</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    改写下列代码段中的错误。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    (a) if (ival1 != ival2) </span></span><br><span class="line"><span class="comment">            ival1 = ival2</span></span><br><span class="line"><span class="comment">        else </span></span><br><span class="line"><span class="comment">            ival1 = ival2 = 0;</span></span><br><span class="line"><span class="comment">    (b) if (ival &lt; minval) </span></span><br><span class="line"><span class="comment">            minval = ival;</span></span><br><span class="line"><span class="comment">            occurs = 1;</span></span><br><span class="line"><span class="comment">    (c) if (int ival = get_value())</span></span><br><span class="line"><span class="comment">            cout &lt;&lt; "ival = " &lt;&lt; ival &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">        if (!ival)</span></span><br><span class="line"><span class="comment">            cout &lt;&lt; "ival = 0\n";</span></span><br><span class="line"><span class="comment">    (d) if (ival = 0)</span></span><br><span class="line"><span class="comment">            ival = get_value();</span></span><br><span class="line"><span class="comment">    (a) ival1 = ival2 后面少了分号。</span></span><br><span class="line"><span class="comment">    (b) 应该用花括号括起来。</span></span><br><span class="line"><span class="comment">    (c) if (!ival) 应该改为 else。</span></span><br><span class="line"><span class="comment">    (d) if (ival = 0) 应该改为 if (ival == 0)。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><h2 id="exercise_58"><a class="markdownIt-Anchor" href="#exercise_58"></a> exercise_5.8</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    什么是“悬垂else”？C++语言是如何处理else子句的？</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    C++语言规定else与它最近的尚未匹配的if匹配。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><h2 id="exercise_59"><a class="markdownIt-Anchor" href="#exercise_59"></a> exercise_5.9</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    编写一段程序，使用一系列if语句统计从cin读入的文本中有多少元音字母。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout; <span class="keyword">using</span> std::endl; <span class="keyword">using</span> std::cin;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="type">unsigned</span> aCnt = <span class="number">0</span>, eCnt = <span class="number">0</span>, iCnt = <span class="number">0</span>, oCnt = <span class="number">0</span>, uCnt = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; ch)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (ch == <span class="string">'a'</span>) ++aCnt;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">'e'</span>) ++eCnt;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">'i'</span>) ++iCnt;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">'o'</span>) ++oCnt;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">'u'</span>) ++uCnt;</span><br><span class="line">}</span><br><span class="line">cout &lt;&lt; <span class="string">"Number of vowel a: \t"</span> &lt;&lt; aCnt &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">&lt;&lt; <span class="string">"Number of vowel e: \t"</span> &lt;&lt; eCnt &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">&lt;&lt; <span class="string">"Number of vowel i: \t"</span> &lt;&lt; iCnt &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">&lt;&lt; <span class="string">"Number of vowel o: \t"</span> &lt;&lt; oCnt &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">&lt;&lt; <span class="string">"Number of vowel u: \t"</span> &lt;&lt; uCnt &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="exercise_510"><a class="markdownIt-Anchor" href="#exercise_510"></a> exercise_5.10</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    我们之前实现的统计元音字母的程序存在一个问题：</span></span><br><span class="line"><span class="comment">    如果元音字母以大写形式出现，不会被统计在内。</span></span><br><span class="line"><span class="comment">    编写一段程序，既统计元音字母的小写形式，也统计元音字母的大写形式，</span></span><br><span class="line"><span class="comment">    也就是说，新程序遇到'a'和'A'都应该递增 aCnt 的值，以此类推。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cin; <span class="keyword">using</span> std::cout; <span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">unsigned</span> aCnt = <span class="number">0</span>, eCnt = <span class="number">0</span>, iCnt = <span class="number">0</span>, oCnt = <span class="number">0</span>, uCnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; ch)</span><br><span class="line">        <span class="keyword">switch</span> (ch)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'a'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'A'</span>:</span><br><span class="line">                ++aCnt;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'e'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'E'</span>:</span><br><span class="line">                ++eCnt;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'i'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'I'</span>:</span><br><span class="line">                ++iCnt;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'o'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'O'</span>:</span><br><span class="line">                ++oCnt;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'u'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'U'</span>:</span><br><span class="line">                ++uCnt;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">           </span><br><span class="line">    cout &lt;&lt; <span class="string">"Number of vowel a(A): \t"</span> &lt;&lt; aCnt &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">         &lt;&lt; <span class="string">"Number of vowel e(E): \t"</span> &lt;&lt; eCnt &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">         &lt;&lt; <span class="string">"Number of vowel i(I): \t"</span> &lt;&lt; iCnt &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">         &lt;&lt; <span class="string">"Number of vowel o(O): \t"</span> &lt;&lt; oCnt &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">         &lt;&lt; <span class="string">"Number of vowel u(U): \t"</span> &lt;&lt; uCnt &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="exercise_511"><a class="markdownIt-Anchor" href="#exercise_511"></a> exercise_5.11</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    修改统计元音字母的程序，使其也能统计空格、制表符、和换行符的数量。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cin; <span class="keyword">using</span> std::cout; <span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">unsigned</span> aCnt = <span class="number">0</span>, eCnt = <span class="number">0</span>, iCnt = <span class="number">0</span>, oCnt = <span class="number">0</span>, uCnt = <span class="number">0</span>,</span><br><span class="line">             space = <span class="number">0</span>, table = <span class="number">0</span>, enter = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; ch)</span><br><span class="line">        <span class="keyword">switch</span> (ch)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'a'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'A'</span>:</span><br><span class="line">                ++aCnt;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'e'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'E'</span>:</span><br><span class="line">                ++eCnt;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'i'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'I'</span>:</span><br><span class="line">                ++iCnt;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'o'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'O'</span>:</span><br><span class="line">                ++oCnt;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'u'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'U'</span>:</span><br><span class="line">                ++uCnt;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">' '</span>:</span><br><span class="line">                ++space;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'/n'</span>:</span><br><span class="line">                ++enter;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'/t'</span>:</span><br><span class="line">                ++table;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"Number of vowel a(A): \t"</span> &lt;&lt; aCnt &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">         &lt;&lt; <span class="string">"Number of vowel e(E): \t"</span> &lt;&lt; eCnt &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">         &lt;&lt; <span class="string">"Number of vowel i(I): \t"</span> &lt;&lt; iCnt &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">         &lt;&lt; <span class="string">"Number of vowel o(O): \t"</span> &lt;&lt; oCnt &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">         &lt;&lt; <span class="string">"Number of vowel u(U): \t"</span> &lt;&lt; uCnt &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">         &lt;&lt; <span class="string">"Number of vowel space: \t"</span> &lt;&lt; space &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">         &lt;&lt; <span class="string">"Number of vowel table: \t"</span> &lt;&lt; table &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">         &lt;&lt; <span class="string">"Number of vowel enter: \t"</span> &lt;&lt; table &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="exercise_512"><a class="markdownIt-Anchor" href="#exercise_512"></a> exercise_5.12</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    修改统计元音字母的程序，使其能统计含以下两个字符的字符序列的数量： ff、fl和fi。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cin; <span class="keyword">using</span> std::cout; <span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">unsigned</span> aCnt = <span class="number">0</span>, eCnt = <span class="number">0</span>, iCnt = <span class="number">0</span>, oCnt = <span class="number">0</span>, uCnt = <span class="number">0</span>, spaceCnt = <span class="number">0</span>, tabCnt = <span class="number">0</span>, newLineCnt = <span class="number">0</span>, ffCnt = <span class="number">0</span>, flCnt = <span class="number">0</span>, fiCnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> ch, prech = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; std::noskipws &gt;&gt; ch)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">switch</span> (ch)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'a'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'A'</span>:</span><br><span class="line">                ++aCnt;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'e'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'E'</span>:</span><br><span class="line">                ++eCnt;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'i'</span>:</span><br><span class="line">                <span class="keyword">if</span> (prech == <span class="string">'f'</span>) ++fiCnt;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'I'</span>:</span><br><span class="line">                ++iCnt;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'o'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'O'</span>:</span><br><span class="line">                ++oCnt;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'u'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'U'</span>:</span><br><span class="line">                ++uCnt;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">' '</span>:</span><br><span class="line">                ++spaceCnt;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'\t'</span>:</span><br><span class="line">                ++tabCnt;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'\n'</span>:</span><br><span class="line">                ++newLineCnt;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'f'</span>:</span><br><span class="line">                <span class="keyword">if</span> (prech == <span class="string">'f'</span>) ++ffCnt;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'l'</span>:</span><br><span class="line">                <span class="keyword">if</span> (prech == <span class="string">'f'</span>) ++flCnt;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        prech = ch;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">"Number of vowel a(A): \t"</span> &lt;&lt; aCnt &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">        &lt;&lt; <span class="string">"Number of vowel e(E): \t"</span> &lt;&lt; eCnt &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">        &lt;&lt; <span class="string">"Number of vowel i(I): \t"</span> &lt;&lt; iCnt &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">        &lt;&lt; <span class="string">"Number of vowel o(O): \t"</span> &lt;&lt; oCnt &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">        &lt;&lt; <span class="string">"Number of vowel u(U): \t"</span> &lt;&lt; uCnt &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">        &lt;&lt; <span class="string">"Number of space: \t"</span> &lt;&lt; spaceCnt &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">        &lt;&lt; <span class="string">"Number of tab char: \t"</span> &lt;&lt; tabCnt &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">        &lt;&lt; <span class="string">"Number of new line: \t"</span> &lt;&lt; newLineCnt &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">        &lt;&lt; <span class="string">"Number of ff: \t"</span> &lt;&lt; ffCnt &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">        &lt;&lt; <span class="string">"Number of fl: \t"</span> &lt;&lt; flCnt &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">        &lt;&lt; <span class="string">"Number of fi: \t"</span> &lt;&lt; fiCnt &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="exercise_513"><a class="markdownIt-Anchor" href="#exercise_513"></a> exercise_5.13</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    下面显示的每个程序都含有一个常见的编码错误，指出错误在哪里，然后修改它们。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    (a) unsigned aCnt = 0, eCnt = 0, iouCnt = 0;</span></span><br><span class="line"><span class="comment">        char ch = next_text();</span></span><br><span class="line"><span class="comment">        switch (ch) {</span></span><br><span class="line"><span class="comment">            case 'a': aCnt++;</span></span><br><span class="line"><span class="comment">            case 'e': eCnt++;</span></span><br><span class="line"><span class="comment">            default: iouCnt++;</span></span><br><span class="line"><span class="comment">        }</span></span><br><span class="line"><span class="comment">    (b) unsigned index = some_value();</span></span><br><span class="line"><span class="comment">        switch (index) {</span></span><br><span class="line"><span class="comment">            case 1:</span></span><br><span class="line"><span class="comment">                int ix = get_value();</span></span><br><span class="line"><span class="comment">                ivec[ ix ] = index;</span></span><br><span class="line"><span class="comment">                break;</span></span><br><span class="line"><span class="comment">            default:</span></span><br><span class="line"><span class="comment">                ix = ivec.size()-1;</span></span><br><span class="line"><span class="comment">                ivec[ ix ] = index;</span></span><br><span class="line"><span class="comment">        }</span></span><br><span class="line"><span class="comment">    (c) unsigned evenCnt = 0, oddCnt = 0;</span></span><br><span class="line"><span class="comment">        int digit = get_num() % 10;</span></span><br><span class="line"><span class="comment">        switch (digit) {</span></span><br><span class="line"><span class="comment">            case 1, 3, 5, 7, 9:</span></span><br><span class="line"><span class="comment">                oddcnt++;</span></span><br><span class="line"><span class="comment">                break;</span></span><br><span class="line"><span class="comment">            case 2, 4, 6, 8, 10:</span></span><br><span class="line"><span class="comment">                evencnt++;</span></span><br><span class="line"><span class="comment">                break;</span></span><br><span class="line"><span class="comment">        }</span></span><br><span class="line"><span class="comment">    (d) unsigned ival=512, jval=1024, kval=4096;</span></span><br><span class="line"><span class="comment">        unsigned bufsize;</span></span><br><span class="line"><span class="comment">        unsigned swt = get_bufCnt();</span></span><br><span class="line"><span class="comment">        switch(swt) {</span></span><br><span class="line"><span class="comment">            case ival:</span></span><br><span class="line"><span class="comment">                bufsize = ival * sizeof(int);</span></span><br><span class="line"><span class="comment">                break;</span></span><br><span class="line"><span class="comment">            case jval:</span></span><br><span class="line"><span class="comment">                bufsize = jval * sizeof(int);</span></span><br><span class="line"><span class="comment">                break;</span></span><br><span class="line"><span class="comment">            case kval:</span></span><br><span class="line"><span class="comment">                bufsize = kval * sizeof(int);</span></span><br><span class="line"><span class="comment">                break;</span></span><br><span class="line"><span class="comment">        }</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    (a) 少了 break语句。应该为：</span></span><br><span class="line"><span class="comment">unsigned aCnt = 0, eCnt = 0, iouCnt = 0;</span></span><br><span class="line"><span class="comment">    char ch = next_text();</span></span><br><span class="line"><span class="comment">    switch (ch) {</span></span><br><span class="line"><span class="comment">    case 'a': aCnt++; break;</span></span><br><span class="line"><span class="comment">    case 'e': eCnt++; break;</span></span><br><span class="line"><span class="comment">    default: iouCnt++; break;</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment">    (b) 在 default 分支当中，ix 未定义。应该在外部定义ix。</span></span><br><span class="line"><span class="comment">        unsigned index = some_value();</span></span><br><span class="line"><span class="comment">        int ix;</span></span><br><span class="line"><span class="comment">        switch (index) {</span></span><br><span class="line"><span class="comment">            case 1:</span></span><br><span class="line"><span class="comment">                ix = get_value();</span></span><br><span class="line"><span class="comment">                ivec[ ix ] = index;</span></span><br><span class="line"><span class="comment">                break;</span></span><br><span class="line"><span class="comment">            default:</span></span><br><span class="line"><span class="comment">                ix = static_cast&lt;int&gt;(ivec.size())-1;</span></span><br><span class="line"><span class="comment">                ivec[ ix ] = index;</span></span><br><span class="line"><span class="comment">        }</span></span><br><span class="line"><span class="comment">    (c) case 后面应该用冒号而不是逗号。</span></span><br><span class="line"><span class="comment">        unsigned evenCnt = 0, oddCnt = 0;</span></span><br><span class="line"><span class="comment">        int digit = get_num() % 10;</span></span><br><span class="line"><span class="comment">        switch (digit) {</span></span><br><span class="line"><span class="comment">            case 1: case 3: case 5: case 7: case 9:</span></span><br><span class="line"><span class="comment">                oddcnt++;</span></span><br><span class="line"><span class="comment">                break;</span></span><br><span class="line"><span class="comment">            case 2: case 4: case 6: case 8: case 0:</span></span><br><span class="line"><span class="comment">                evencnt++;</span></span><br><span class="line"><span class="comment">                break;</span></span><br><span class="line"><span class="comment">        }</span></span><br><span class="line"><span class="comment">    (d) case 标签必须是整型常量表达式。</span></span><br><span class="line"><span class="comment">        const unsigned ival=512, jval=1024, kval=4096;</span></span><br><span class="line"><span class="comment">        unsigned bufsize;</span></span><br><span class="line"><span class="comment">        unsigned swt = get_bufCnt();</span></span><br><span class="line"><span class="comment">        switch(swt) {</span></span><br><span class="line"><span class="comment">            case ival:</span></span><br><span class="line"><span class="comment">                bufsize = ival * sizeof(int);</span></span><br><span class="line"><span class="comment">                break;</span></span><br><span class="line"><span class="comment">            case jval:</span></span><br><span class="line"><span class="comment">                bufsize = jval * sizeof(int);</span></span><br><span class="line"><span class="comment">                break;</span></span><br><span class="line"><span class="comment">            case kval:</span></span><br><span class="line"><span class="comment">                bufsize = kval * sizeof(int);</span></span><br><span class="line"><span class="comment">                break;</span></span><br><span class="line"><span class="comment">        }</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><h2 id="exercise_514"><a class="markdownIt-Anchor" href="#exercise_514"></a> exercise_5.14</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    编写一段程序，从标准输入中读取若干string对象并查找连续重复出现的单词，</span></span><br><span class="line"><span class="comment">    所谓连续重复出现的意思是：一个单词后面紧跟着这个单词本身。</span></span><br><span class="line"><span class="comment">    要求记录连续重复出现的最大次数以及对应的单词。如果这样的单词存在，输出重复出现的最大次数；</span></span><br><span class="line"><span class="comment">    如果不存在，输出一条信息说明任何单词都没有连续出现过。例如：如果输入是：</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout; <span class="keyword">using</span> std::cin; <span class="keyword">using</span> std::endl; <span class="keyword">using</span> std::string; <span class="keyword">using</span> std::pair;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">pair&lt;string, <span class="type">int</span>&gt; max_duplicated;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (string str, prestr; cin &gt;&gt; str; prestr = str)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (str == prestr) ++count;</span><br><span class="line"><span class="keyword">else</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (count &gt; max_duplicated.second) max_duplicated = { prestr, count };</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (max_duplicated.first.<span class="built_in">empty</span>()) cout &lt;&lt; <span class="string">"There's no duplicated string."</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span> cout &lt;&lt; <span class="string">"the word "</span> &lt;&lt; max_duplicated.first &lt;&lt; <span class="string">" occurred "</span> &lt;&lt; max_duplicated.second + <span class="number">1</span> &lt;&lt; <span class="string">" times. "</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="exercise_515"><a class="markdownIt-Anchor" href="#exercise_515"></a> exercise_5.15</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    说明下列循环的含义并改正错误:.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int sz;</span></span><br><span class="line"><span class="comment">    for (int ix = 0; ix != sz;++ix){</span></span><br><span class="line"><span class="comment">        if(ix!=sz)</span></span><br><span class="line"><span class="comment">        //......</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int ix;</span></span><br><span class="line"><span class="comment">    for (ix != sz; ++ix){...}</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    for (int ix; ix != sz;++ix,++sz){...}</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    应该改为下面这样：</span></span><br><span class="line"><span class="comment">    int ix;</span></span><br><span class="line"><span class="comment">    for (ix = 0; ix != sz; ++ix)  {  ...  }</span></span><br><span class="line"><span class="comment">    if (ix != sz)</span></span><br><span class="line"><span class="comment">    // . . .</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int ix;</span></span><br><span class="line"><span class="comment">    for (; ix != sz; ++ix) {  ...  }</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">     for (int ix = 0; ix != sz; ++ix) { ... }</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="exercise_516"><a class="markdownIt-Anchor" href="#exercise_516"></a> exercise_5.16</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    while 循环特别适用于那种条件不变、反复执行操作的情况，</span></span><br><span class="line"><span class="comment">    例如，当未达到文件末尾时不断读取下一个值。</span></span><br><span class="line"><span class="comment">    for 循环更像是在按步骤迭代，它的索引值在某个范围内一次变化。</span></span><br><span class="line"><span class="comment">    根据每种循环的习惯各自编写一段程序，然后分别用另一种循环改写。</span></span><br><span class="line"><span class="comment">    如果只能使用一种循环，你倾向于哪种？为什么？</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int i;</span></span><br><span class="line"><span class="comment">    while ( cin &gt;&gt; i )</span></span><br><span class="line"><span class="comment">        // ...</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    for (int i = 0; cin &gt;&gt; i;)</span></span><br><span class="line"><span class="comment">        // ...</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    for (int i = 0; i != size; ++i)</span></span><br><span class="line"><span class="comment">        // ...</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int i = 0;</span></span><br><span class="line"><span class="comment">    while (i != size)</span></span><br><span class="line"><span class="comment">    {</span></span><br><span class="line"><span class="comment">        // ...</span></span><br><span class="line"><span class="comment">        ++i;</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    如果只能用一种循环，我会更倾向使用 while，因为while 显得简洁，代码可读性强。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="exercise_517"><a class="markdownIt-Anchor" href="#exercise_517"></a> exercise_5.17</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    假设有两个包含整数的vector对象，编写一段程序，</span></span><br><span class="line"><span class="comment">    检验其中一个vector对象是否是另一个的前缀。</span></span><br><span class="line"><span class="comment">    为了实现这一目标，对于两个不等长的vector对象，只需挑出长度较短的那个，</span></span><br><span class="line"><span class="comment">    把它的所有元素和另一个vector对象比较即可。</span></span><br><span class="line"><span class="comment">    例如，如果两个vector对象的元素分别是0、1、1、2 和 0、1、1、2、3、5、8，则程序的返回结果为真。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout; <span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_prefix</span><span class="params">(vector&lt;<span class="type">int</span>&gt; <span class="type">const</span>&amp; lhs, vector&lt;<span class="type">int</span>&gt; <span class="type">const</span>&amp; rhs)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span>(lhs.<span class="built_in">size</span>() &gt; rhs.<span class="built_in">size</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">is_prefix</span>(rhs, lhs);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">unsigned</span> i = <span class="number">0</span>; i != lhs.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        <span class="keyword">if</span>(lhs[i] != rhs[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; l{ <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span> };</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; r{ <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span> };</span><br><span class="line">    cout &lt;&lt; (<span class="built_in">is_prefix</span>(r, l) ? <span class="string">"yes\n"</span> : <span class="string">"no\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="exercise_518"><a class="markdownIt-Anchor" href="#exercise_518"></a> exercise_5.18</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    说明下列循环的含义并改正其中的错误。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    (a) do { // 应该添加花括号</span></span><br><span class="line"><span class="comment">        int v1, v2;</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; "Please enter two numbers to sum:" ;</span></span><br><span class="line"><span class="comment">        if (cin &gt;&gt; v1 &gt;&gt; v2)</span></span><br><span class="line"><span class="comment">            cout &lt;&lt; "Sum is: " &lt;&lt; v1 + v2 &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">    }while (cin);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    (b) int ival;</span></span><br><span class="line"><span class="comment">        do {</span></span><br><span class="line"><span class="comment">            // . . .</span></span><br><span class="line"><span class="comment">        } while (ival = get_response()); // 应该将ival 定义在循环外</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    (c) int ival = get_response();</span></span><br><span class="line"><span class="comment">        do {</span></span><br><span class="line"><span class="comment">            ival = get_response();</span></span><br><span class="line"><span class="comment">        } while (ival); // 应该将ival 定义在循环外</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><h2 id="exercise_519"><a class="markdownIt-Anchor" href="#exercise_519"></a> exercise_5.19</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    编写一段程序，使用do while 循环重复地执行下述任务：</span></span><br><span class="line"><span class="comment">    首先提示用户输入两个string对象，然后挑出较短的那个并输出它。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout; <span class="keyword">using</span> std::cin; <span class="keyword">using</span> std::endl; <span class="keyword">using</span> std::string;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">string rsp;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; <span class="string">"Input two strings: "</span>;</span><br><span class="line">string str1, str2;</span><br><span class="line">cin &gt;&gt; str1 &gt;&gt; str2;</span><br><span class="line">cout &lt;&lt; (str1 &lt;= str2 ? str1 : str2)</span><br><span class="line">&lt;&lt; <span class="string">" is less than the other. "</span> &lt;&lt; <span class="string">"\n\n"</span></span><br><span class="line">&lt;&lt; <span class="string">"More? Enter yes or no: "</span>;</span><br><span class="line">cin &gt;&gt; rsp;</span><br><span class="line">} <span class="keyword">while</span> (<span class="built_in">tolower</span>(rsp[<span class="number">0</span>]) == <span class="string">'y'</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="exercise_520"><a class="markdownIt-Anchor" href="#exercise_520"></a> exercise_5.20</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    编写一段程序，从标准输入中读取string对象的序列直到连续出现两个相同的单词或者所有的单词都读完为止。</span></span><br><span class="line"><span class="comment">    使用while循环一次读取一个单词，当一个单词连续出现两次时使用break语句终止循环。输出连续重复出现的单词，</span></span><br><span class="line"><span class="comment">    或者输出一个消息说明没有任何单词是连续重复出现的。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout; <span class="keyword">using</span> std::cin; <span class="keyword">using</span> std::endl; <span class="keyword">using</span> std::string;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">string read, tmp;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; read)</span><br><span class="line"><span class="keyword">if</span> (read == tmp) <span class="keyword">break</span>; <span class="keyword">else</span> tmp = read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cin.<span class="built_in">eof</span>())  cout &lt;&lt; <span class="string">"no word was repeated."</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span>            cout &lt;&lt; read &lt;&lt; <span class="string">" occurs twice in succession."</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="exercise_521"><a class="markdownIt-Anchor" href="#exercise_521"></a> exercise_5.21</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    修改5.5.1节练习题的程序，使其找到的重复单词必须以大写字母开头。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">string curr, prev;</span><br><span class="line"><span class="type">bool</span> no_twice = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; curr)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">isupper</span>(curr[<span class="number">0</span>]) &amp;&amp; prev == curr)</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; curr &lt;&lt; <span class="string">": occurs twice in succession."</span> &lt;&lt; endl;</span><br><span class="line">no_twice = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">prev = curr;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (no_twice)</span><br><span class="line">cout &lt;&lt; <span class="string">"no word was repeated."</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="exercise_522"><a class="markdownIt-Anchor" href="#exercise_522"></a> exercise_5.22</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    本节的最后一个例子跳回到 begin，其实使用循环能更好的完成该任务，</span></span><br><span class="line"><span class="comment">    重写这段代码，注意不再使用goto语句。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    // 向后跳过一个带初始化的变量定义是合法的</span></span><br><span class="line"><span class="comment">    begin:</span></span><br><span class="line"><span class="comment">        int sz = get_size();</span></span><br><span class="line"><span class="comment">        if (sz &lt;= 0) {</span></span><br><span class="line"><span class="comment">            goto begin;</span></span><br><span class="line"><span class="comment">        }</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    用 for 循环修改的话就是这样</span></span><br><span class="line"><span class="comment">    for (int sz = get_size(); sz &lt;=0; sz = get_size())</span></span><br><span class="line"><span class="comment">    ;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="exercise_523"><a class="markdownIt-Anchor" href="#exercise_523"></a> exercise_5.23</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    编写一段程序，从标准输入读取两个整数，输出第一个数除以第二个数的结果。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="type">int</span> i, j;</span><br><span class="line">cin &gt;&gt; i &gt;&gt; j;</span><br><span class="line">cout &lt;&lt; i / j &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="exercise_524"><a class="markdownIt-Anchor" href="#exercise_524"></a> exercise_5.24</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    修改你的程序，使得当第二个数是0时抛出异常。先不要设定catch子句，</span></span><br><span class="line"><span class="comment">    运行程序并真的为除数输入0，看看会发生什么？</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="type">int</span> i, j;</span><br><span class="line">std::cin &gt;&gt; i &gt;&gt; j;</span><br><span class="line"><span class="keyword">if</span> (j == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">"divisor is 0"</span>);</span><br><span class="line">std::cout &lt;&lt; i / j &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    terminate called after throwing an instance of 'std::runtime_error'</span></span><br><span class="line"><span class="comment">    what():  divisor is 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><h2 id="exercise_525"><a class="markdownIt-Anchor" href="#exercise_525"></a> exercise_5.25</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    修改上一题的程序，使用try语句块去捕获异常。catch子句应该为用户输出一条提示信息，</span></span><br><span class="line"><span class="comment">    询问其是否输入新数并重新执行try语句块的内容。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cin; <span class="keyword">using</span> std::cout; <span class="keyword">using</span> std::endl; <span class="keyword">using</span> std::runtime_error;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="type">int</span> i, j;</span><br><span class="line">cout &lt;&lt; <span class="string">"please input tow numbers: "</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; i &gt;&gt; j)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (j == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">"divisor is 0"</span>);</span><br><span class="line">cout &lt;&lt; i / j &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="built_in">catch</span> (runtime_error err)</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; err.<span class="built_in">what</span>() &lt;&lt; <span class="string">"\nTry Again? Enter y or n"</span> &lt;&lt; endl;</span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line">cin &gt;&gt; c;</span><br><span class="line"><span class="keyword">if</span> (c != <span class="string">'y'</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">}</span><br><span class="line">cout &lt;&lt; <span class="string">"please input tow numbers: "</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter05 语句</title>
      <link href="/posts/eada.html"/>
      <url>/posts/eada.html</url>
      
        <content type="html"><![CDATA[<h2 id="简单语句simple-statements"><a class="markdownIt-Anchor" href="#简单语句simple-statements"></a> 简单语句（Simple Statements）</h2><p>如果在程序的某个地方，语法上需要一条语句但是逻辑上不需要，则应该使用空语句（null statement）。空语句中只含有一个单独的分号<code>;</code>。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// read until we hit end-of-file or find an input equal to sought</span></span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; s &amp;&amp; s != sought)</span><br><span class="line">    ;   <span class="comment">// null statement</span></span><br></pre></td></tr></tbody></table></figure><p>使用空语句时应该加上注释，从而令读这段代码的人知道该语句是有意省略的。</p><p>多余的空语句并非总是无害的。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// disaster: extra semicolon: loop body is this null statement</span></span><br><span class="line"><span class="keyword">while</span> (iter != svec.<span class="built_in">end</span>()) ;    <span class="comment">// the while body is the empty statement</span></span><br><span class="line">    ++iter;     <span class="comment">// increment is not part of the loop</span></span><br></pre></td></tr></tbody></table></figure><p>复合语句（compound statement）是指用花括号括起来的（可能为空）语句和声明的序列。复合语句也叫做块（block），一个块就是一个作用域。在块中引入的名字只能在块内部以及嵌套在块中的子块里访问。通常，名字在有限的区域内可见，该区域从名字定义处开始，到名字所在（最内层）块的结尾处为止。</p><p>语句块不以分号作为结束。</p><p>空块的作用等价于空语句。</p><h2 id="语句作用域statement-scope"><a class="markdownIt-Anchor" href="#语句作用域statement-scope"></a> 语句作用域（Statement Scope）</h2><p>可以在<code>if</code>、<code>switch</code>、<code>while</code>和<code>for</code>语句的控制结构内定义变量，这些变量只在相应语句的内部可见，一旦语句结束，变量也就超出了其作用范围。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="type">int</span> i = <span class="built_in">get_num</span>())   <span class="comment">// i is created and initialized on each iteration</span></span><br><span class="line">    cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">i = <span class="number">0</span>;  <span class="comment">// error: i is not accessible outside the loop</span></span><br></pre></td></tr></tbody></table></figure><h2 id="条件语句conditional-statements"><a class="markdownIt-Anchor" href="#条件语句conditional-statements"></a> 条件语句（Conditional Statements）</h2><h3 id="if语句the-if-statement"><a class="markdownIt-Anchor" href="#if语句the-if-statement"></a> if语句（The if Statement）</h3><p><code>if</code>语句的形式：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">    statement</span><br></pre></td></tr></tbody></table></figure><p><code>if-else</code>语句的形式：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">    statement</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    statement2</span><br></pre></td></tr></tbody></table></figure><p>其中<em>condition</em>是判断条件，可以是一个表达式或者初始化了的变量声明。<em>condition</em>必须用圆括号括起来。</p><ul><li>如果<em>condition</em>为真，则执行<em>statement</em>。执行完成后，程序继续执行<code>if</code>语句后面的其他语句。</li><li>如果<em>condition</em>为假，则跳过<em>statement</em>。对于简单<code>if</code>语句来说，程序直接执行<code>if</code>语句后面的其他语句；对于<code>if-else</code>语句来说，程序先执行<em>statement2</em>，再执行<code>if</code>语句后面的其他语句。</li></ul><p><code>if</code>语句可以嵌套，其中<code>else</code>与离它最近的尚未匹配的<code>if</code>相匹配。</p><h3 id="switch语句the-switch-statement"><a class="markdownIt-Anchor" href="#switch语句the-switch-statement"></a> switch语句（The switch Statement）</h3><p><code>switch</code>语句的形式：</p><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200823154030.png" alt=""></p><p><code>switch</code>语句先对括号里的表达式求值，值转换成整数类型后再与每个<code>case</code>标签（case label）的值进行比较。如果表达式的值和某个<code>case</code>标签匹配，程序从该标签之后的第一条语句开始执行，直到到达<code>switch</code>的结尾或者遇到<code>break</code>语句为止。<code>case</code>标签必须是整型常量表达式。</p><p>通常情况下每个<code>case</code>分支后都有<code>break</code>语句。如果确实不应该出现<code>break</code>语句，最好写一段注释说明程序的逻辑。</p><p>尽管<code>switch</code>语句没有强制要求在最后一个<code>case</code>标签后写上<code>break</code>，但为了安全起见，最好添加<code>break</code>。这样即使以后增加了新的<code>case</code>分支，也不用再在前面补充<code>break</code>语句了。</p><p><code>switch</code>语句中可以添加一个<code>default</code>标签（default label），如果没有任何一个<code>case</code>标签能匹配上<code>switch</code>表达式的值，程序将执行<code>default</code>标签后的语句。</p><p>即使不准备在<code>default</code>标签下做任何操作，程序中也应该定义一个<code>default</code>标签。其目的在于告诉他人我们已经考虑到了默认情况，只是目前不需要实际操作。</p><p>不允许跨过变量的初始化语句直接跳转到该变量作用域内的另一个位置。如果需要为<code>switch</code>的某个<code>case</code>分支定义并初始化一个变量，则应该把变量定义在块内。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="literal">true</span>:</span><br><span class="line">{</span><br><span class="line">    <span class="comment">// ok: declaration statement within a statement block</span></span><br><span class="line">    string file_name = <span class="built_in">get_file_name</span>();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="迭代语句iterative-statements"><a class="markdownIt-Anchor" href="#迭代语句iterative-statements"></a> 迭代语句（Iterative Statements）</h2><p>迭代语句通常称为循环，它重复执行操作直到满足某个条件才停止。<code>while</code>和<code>for</code>语句在执行循环体之前检查条件，<code>do-while</code>语句先执行循环体再检查条件。</p><h3 id="while语句the-while-statement"><a class="markdownIt-Anchor" href="#while语句the-while-statement"></a> while语句（The while Statement）</h3><p><code>while</code>语句的形式：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (condition)</span><br><span class="line">    statement</span><br></pre></td></tr></tbody></table></figure><p>只要<em>condition</em>的求值结果为<code>true</code>，就一直执行<em>statement</em>（通常是一个块）。<em>condition</em>不能为空，如果<em>condition</em>第一次求值就是<code>false</code>，<em>statement</em>一次都不会执行。</p><p>定义在<code>while</code>条件部分或者循环体内的变量每次迭代都经历从创建到销毁的过程。</p><p>在不确定迭代次数，或者想在循环结束后访问循环控制变量时，使用<code>while</code>比较合适。</p><h3 id="传统的for语句traditional-for-statement"><a class="markdownIt-Anchor" href="#传统的for语句traditional-for-statement"></a> 传统的for语句（Traditional for Statement）</h3><p><code>for</code>语句的形式：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (initializer; condition; expression)</span><br><span class="line">    statement</span><br></pre></td></tr></tbody></table></figure><p>一般情况下，<em>initializer</em>负责初始化一个值，这个值会随着循环的进行而改变。<em>condition</em>作为循环控制的条件，只要<em>condition</em>的求值结果为<code>true</code>，就执行一次<em>statement</em>。执行后再由<em>expression</em>负责修改<em>initializer</em>初始化的变量，这个变量就是<em>condition</em>检查的对象。如果<em>condition</em>第一次求值就是<code>false</code>，<em>statement</em>一次都不会执行。<em>initializer</em>中也可以定义多个对象，但是只能有一条声明语句，因此所有变量的基础类型必须相同。</p><p><code>for</code>语句头中定义的对象只在<code>for</code>循环体内可见。</p><h3 id="范围for语句range-for-statement"><a class="markdownIt-Anchor" href="#范围for语句range-for-statement"></a> 范围for语句（Range for Statement）</h3><p>范围<code>for</code>语句的形式：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (declaration : expression)</span><br><span class="line">    statement</span><br></pre></td></tr></tbody></table></figure><p>其中<em>expression</em>表示一个序列，拥有能返回迭代器的<code>begin</code>和<code>end</code>成员。<em>declaration</em>定义一个变量，序列中的每个元素都应该能转换成该变量的类型（可以使用<code>auto</code>）。如果需要对序列中的元素执行写操作，循环变量必须声明成引用类型。每次迭代都会重新定义循环控制变量，并将其初始化为序列中的下一个值，之后才会执行<em>statement</em>。</p><h3 id="do-while语句the-do-while-statement"><a class="markdownIt-Anchor" href="#do-while语句the-do-while-statement"></a> do-while语句（The do-while Statement）</h3><p><code>do-while</code>语句的形式：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">do</span></span></span><br><span class="line"><span class="function">    statement</span></span><br><span class="line"><span class="function"><span class="title">while</span> <span class="params">(condition)</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>计算<em>condition</em>的值之前会先执行一次<em>statement</em>，<em>condition</em>不能为空。如果<em>condition</em>的值为<code>false</code>，循环终止，否则重复执行<em>statement</em>。</p><p>因为<code>do-while</code>语句先执行语句或块，再判断条件，所以不允许在条件部分定义变量。</p><h2 id="跳转语句jump-statements"><a class="markdownIt-Anchor" href="#跳转语句jump-statements"></a> 跳转语句（Jump Statements）</h2><p>跳转语句中断当前的执行过程。</p><h3 id="break语句the-break-statement"><a class="markdownIt-Anchor" href="#break语句the-break-statement"></a> break语句（The break Statement）</h3><p><code>break</code>语句只能出现在迭代语句或者<code>switch</code>语句的内部，负责终止离它最近的<code>while</code>、<code>do-while</code>、<code>for</code>或者<code>switch</code>语句，并从这些语句之后的第一条语句开始执行。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">string buf;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; buf &amp;&amp; !buf.<span class="built_in">empty</span>())</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">switch</span>(buf[<span class="number">0</span>])</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">            <span class="comment">// process up to the first blank</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> it = buf.<span class="built_in">begin</span>()+<span class="number">1</span>; it != buf.<span class="built_in">end</span>(); ++it)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">if</span> (*it == <span class="string">' '</span>)</span><br><span class="line">                <span class="keyword">break</span>;  <span class="comment">// #1, leaves the for loop</span></span><br><span class="line">                <span class="comment">// . . .</span></span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// break #1 transfers control here</span></span><br><span class="line">            <span class="comment">// remaining '-' processing:</span></span><br><span class="line">            <span class="keyword">break</span>;  <span class="comment">// #2, leaves the switch statement</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">    <span class="comment">// . . .</span></span><br><span class="line">    } <span class="comment">// end switch</span></span><br><span class="line"><span class="comment">// end of switch: break #2 transfers control here</span></span><br><span class="line">} <span class="comment">// end while</span></span><br></pre></td></tr></tbody></table></figure><h3 id="continue语句the-continue-statement"><a class="markdownIt-Anchor" href="#continue语句the-continue-statement"></a> continue语句（The continue Statement）</h3><p><code>continue</code>语句只能出现在迭代语句的内部，负责终止离它最近的循环的当前一次迭代并立即开始下一次迭代。和<code>break</code>语句不同的是，只有当<code>switch</code>语句嵌套在迭代语句内部时，才能在<code>switch</code>中使用<code>continue</code>。</p><p><code>continue</code>语句中断当前迭代后，具体操作视迭代语句类型而定：</p><ul><li>对于<code>while</code>和<code>do-while</code>语句来说，继续判断条件的值。</li><li>对于传统的<code>for</code>语句来说，继续执行<code>for</code>语句头中的第三部分，之后判断条件的值。</li><li>对于范围<code>for</code>语句来说，是用序列中的下一个元素初始化循环变量。</li></ul><h3 id="goto语句the-goto-statement"><a class="markdownIt-Anchor" href="#goto语句the-goto-statement"></a> goto语句（The goto Statement）</h3><p><code>goto</code>语句（labeled statement）是一种特殊的语句，在它之前有一个标识符和一个冒号。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">end: <span class="keyword">return</span>; <span class="comment">// labeled statement; may be the target of a goto</span></span><br></pre></td></tr></tbody></table></figure><p>标签标识符独立于变量和其他标识符的名字，它们之间不会相互干扰。</p><p><code>goto</code>语句的形式：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">goto</span> label;</span><br></pre></td></tr></tbody></table></figure><p><code>goto</code>语句使程序无条件跳转到标签为<em>label</em>的语句处执行，但两者必须位于同一个函数内，同时<code>goto</code>语句也不能将程序的控制权从变量的作用域之外转移到作用域之内。</p><p>建议不要在程序中使用<code>goto</code>语句，它使得程序既难理解又难修改。</p><h2 id="try语句块和异常处理try-blocks-and-exception-handling"><a class="markdownIt-Anchor" href="#try语句块和异常处理try-blocks-and-exception-handling"></a> try语句块和异常处理（try Blocks and Exception Handling）</h2><p>异常（exception）是指程序运行时的反常行为，这些行为超出了函数正常功能的范围。当程序的某一部分检测到一个它无法处理的问题时，需要使用异常处理（exception handling）。</p><p>异常处理机制包括<code>throw</code>表达式（throw expression）、<code>try</code>语句块（try block）和异常类（exception class）。</p><ul><li>异常检测部分使用<code>throw</code>表达式表示它遇到了无法处理的问题（<code>throw</code>引发了异常）。</li><li>异常处理部分使用<code>try</code>语句块处理异常。<code>try</code>语句块以关键字<code>try</code>开始，并以一个或多个<code>catch</code>子句（catch clause）结束。<code>try</code>语句块中代码抛出的异常通常会被某个<code>catch</code>子句处理，<code>catch</code>子句也被称作异常处理代码（exception handler）。</li><li>异常类用于在<code>throw</code>表达式和相关的<code>catch</code>子句之间传递异常的具体信息。</li></ul><h3 id="throw表达式a-throw-expression"><a class="markdownIt-Anchor" href="#throw表达式a-throw-expression"></a> throw表达式（A throw Expression）</h3><p><code>throw</code>表达式包含关键字<code>throw</code>和紧随其后的一个表达式，其中表达式的类型就是抛出的异常类型。</p><h3 id="try语句块the-try-block"><a class="markdownIt-Anchor" href="#try语句块the-try-block"></a> try语句块（The try Block）</h3><p><code>try</code>语句块的通用形式：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">{</span><br><span class="line">    program-statements</span><br><span class="line">}</span><br><span class="line"><span class="built_in">catch</span> (exception-declaration)</span><br><span class="line">{</span><br><span class="line">    handler-statements</span><br><span class="line">}</span><br><span class="line"><span class="built_in">catch</span> (exception-declaration)</span><br><span class="line">{</span><br><span class="line">    handler-statements</span><br><span class="line">} <span class="comment">// . . .</span></span><br></pre></td></tr></tbody></table></figure><p><code>try</code>语句块中的<em>program-statements</em>组成程序的正常逻辑，其内部声明的变量在块外无法访问，即使在<code>catch</code>子句中也不行。<code>catch</code>子句包含关键字<code>catch</code>、括号内一个对象的声明（异常声明，exception declaration）和一个块。当选中了某个<code>catch</code>子句处理异常后，执行与之对应的块。<code>catch</code>一旦完成，程序会跳过剩余的所有<code>catch</code>子句，继续执行后面的语句。</p><p>如果最终没能找到与异常相匹配的<code>catch</code>子句，程序会执行名为<code>terminate</code>的标准库函数。该函数的行为与系统有关，一般情况下，执行该函数将导致程序非正常退出。类似的，如果一段程序没有<code>try</code>语句块且发生了异常，系统也会调用<code>terminate</code>函数并终止当前程序的执行。</p><h3 id="标准异常standard-exceptions"><a class="markdownIt-Anchor" href="#标准异常standard-exceptions"></a> 标准异常（Standard Exceptions）</h3><p>异常类分别定义在4个头文件中：</p><ul><li><p>头文件<em>exception</em>定义了最通用的异常类<code>exception</code>。它只报告异常的发生，不提供任何额外信息。</p></li><li><p>头文件<em>stdexcept</em>定义了几种常用的异常类。</p><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200823153130.png" alt=""></p></li><li><p>头文件<em>new</em>定义了<code>bad_alloc</code>异常类。</p></li><li><p>头文件<em>type_info</em>定义了<code>bad_cast</code>异常类。</p></li></ul><p>标准库异常类的继承体系：</p><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200823153053.png" alt=""></p><p>只能以默认初始化的方式初始化<code>exception</code>、<code>bad_alloc</code>和<code>bad_cast</code>对象，不允许为这些对象提供初始值。其他异常类的对象在初始化时必须提供一个<code>string</code>或一个C风格字符串，通常表示异常信息。<code>what</code>成员函数可以返回该字符串的<code>string</code>副本。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Exercise of chapter 04</title>
      <link href="/posts/5cc1.html"/>
      <url>/posts/5cc1.html</url>
      
        <content type="html"><![CDATA[<h2 id="exercise_41"><a class="markdownIt-Anchor" href="#exercise_41"></a> Exercise_4.1</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//表达式 5 + 10 * 20 / 2 的求值结果是多少？</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> t = <span class="number">5</span> + <span class="number">10</span> * <span class="number">20</span> / <span class="number">2</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"the result is  "</span> &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="exercise_42"><a class="markdownIt-Anchor" href="#exercise_42"></a> Exercise_4.2</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    根据4.12节中的表，在下述表达式的合理位置添加括号，</span></span><br><span class="line"><span class="comment">    使得添加括号后运算对象的组合顺序与添加括号前一致。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    vector &lt;<span class="type">int</span>&gt; <span class="built_in">vec</span>(<span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> first1 = *(vec.<span class="built_in">begin</span>());</span><br><span class="line">    <span class="type">int</span> first2 = (*(vec.<span class="built_in">begin</span>())) + <span class="number">1</span>;</span><br><span class="line">    cout &lt;&lt; first1 &lt;&lt; <span class="string">"  "</span> &lt;&lt; first2;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="exercise_43"><a class="markdownIt-Anchor" href="#exercise_43"></a> Exercise_4.3</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    C++语言没有明确规定大多数二元运算符的求值顺序，给编译器优化留下了余地。</span></span><br><span class="line"><span class="comment">    这种策略实际上是在代码生成效率和程序潜在缺陷之间进行了权衡，</span></span><br><span class="line"><span class="comment">    你认为这可以接受吗？请说出你的理由。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    可以接受。C++的设计思想是尽可能地“相信”程序员，将效率最大化。</span></span><br><span class="line"><span class="comment">    然而这种思想却有着潜在的危害，就是无法控制程序员自身引发的错误。</span></span><br><span class="line"><span class="comment">    因此 Java 的诞生也是必然，Java的思想就是尽可能地“不相信”程序员。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="exercise_44"><a class="markdownIt-Anchor" href="#exercise_44"></a> Exercise_4.4</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    在下面的表达式中添加括号，说明其求值过程及最终结果。</span></span><br><span class="line"><span class="comment">    编写程序编译该（不加括号的）表达式并输出结果验证之前的推断。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> t= <span class="number">12</span> / <span class="number">3</span> * <span class="number">4</span> + <span class="number">5</span> * <span class="number">15</span> + <span class="number">24</span> % <span class="number">4</span> / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> s = ((<span class="number">12</span> / <span class="number">3</span>) * <span class="number">4</span>) + (<span class="number">5</span> * <span class="number">15</span>) + ((<span class="number">24</span> % <span class="number">4</span>) / <span class="number">2</span>);</span><br><span class="line">    cout &lt;&lt; t&lt;&lt;<span class="string">" "</span>&lt;&lt;s&lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="exercise_45"><a class="markdownIt-Anchor" href="#exercise_45"></a> Exercise_4.5</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//写出下列表达式的求值结果。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">-30 * 3 + 21 / 5  // -90+4 = -86</span></span><br><span class="line"><span class="comment">-30 + 3 * 21 / 5  // -30+63/5 = -30+12 = -18</span></span><br><span class="line"><span class="comment">30 / 3 * 21 % 5   // 10*21%5 = 210%5 = 0</span></span><br><span class="line"><span class="comment">-30 / 3 * 21 % 4  // -10*21%4 = -210%4 = -2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><h2 id="exercise_46"><a class="markdownIt-Anchor" href="#exercise_46"></a> Exercise_4.6</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//写出一条表达式用于确定一个整数是奇数还是偶数。</span></span><br><span class="line"><span class="comment">//if (i % 2 == 0) /* ... */</span></span><br></pre></td></tr></tbody></table></figure><h2 id="exercise_47"><a class="markdownIt-Anchor" href="#exercise_47"></a> Exercise_4.7</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//溢出是何含义？写出三条将导致溢出的表达式。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    当计算的结果超出该类型所能表示的范围时就会产生溢出。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">short</span> svalue = <span class="number">32767</span>; ++svalue; <span class="comment">// -32768</span></span><br><span class="line">    <span class="type">unsigned</span> uivalue = <span class="number">0</span>; --uivalue;  <span class="comment">// 4294967295</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> usvalue = <span class="number">65535</span>; ++usvalue;  <span class="comment">// 0</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>v</p><h2 id="exercise_48"><a class="markdownIt-Anchor" href="#exercise_48"></a> Exercise_4.8</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//说明在逻辑与、逻辑或及相等性运算符中运算对象的求值顺序。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    逻辑与运算符和逻辑或运算符都是先求左侧运算对象的值再求右侧运算对象的值，</span></span><br><span class="line"><span class="comment">    当且仅当左侧运算对象无法确定表达式的结果时才会计算右侧运算对象的值。</span></span><br><span class="line"><span class="comment">    这种策略称为 短路求值。相等性运算符未定义求值顺序。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><h2 id="exercise_49"><a class="markdownIt-Anchor" href="#exercise_49"></a> Exercise_4.9</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*  解释在下面的if语句中条件部分的判断过程。</span></span><br><span class="line"><span class="comment">    const char *cp = "Hello World";</span></span><br><span class="line"><span class="comment">    if (cp &amp;&amp; *cp)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    首先判断 cp ，cp 不是一个空指针，因此 cp 为真。</span></span><br><span class="line"><span class="comment">    然后判断 *cp，*cp 的值是字符 'H'，非0。</span></span><br><span class="line"><span class="comment">    因此最后的结果为真。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><h2 id="exercise_410"><a class="markdownIt-Anchor" href="#exercise_410"></a> Exercise_4.10</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//为while 循环写一个条件，使其从标准输入中读取整数，遇到 42 时停止。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; i &amp;&amp; i != <span class="number">42</span>){</span><br><span class="line">        num++;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="exercise_411"><a class="markdownIt-Anchor" href="#exercise_411"></a> Exercise_4.11</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//书写一条表达式用于测试4个值a、b、c、d的关系，确保a大于b、b大于c、c大于d。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> a, b, c, d;</span><br><span class="line">    <span class="keyword">if</span>(a&gt;b &amp;&amp; b&gt;c &amp;&amp; c&gt;d)</span><br><span class="line">        cout &lt;&lt; a &lt;&lt; b &lt;&lt; c &lt;&lt; d;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="exercise_412"><a class="markdownIt-Anchor" href="#exercise_412"></a> Exercise_4.12</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    假设i、j 和k 是三个整数，说明表达式 i != j &lt; k 的含义。</span></span><br><span class="line"><span class="comment">    这个表达式等于 i != (j &lt; k)。首先得到 j &lt; k 的结果为 true 或 false，转换为整数值是 1 和 0，</span></span><br><span class="line"><span class="comment">    然后判断 i 不等于 1 和 0 ，最终的结果为 bool 值。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><h2 id="exercise_413"><a class="markdownIt-Anchor" href="#exercise_413"></a> Exercise_4.13</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    在下述语句中，当赋值完成后 i 和 d 的值分别是多少？</span></span><br><span class="line"><span class="comment">    int i;   double d;</span></span><br><span class="line"><span class="comment">    d = i = 3.5; // i = 3, d = 3.0</span></span><br><span class="line"><span class="comment">    i = d = 3.5; // d = 3.5, i = 3</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><h2 id="exercise_414"><a class="markdownIt-Anchor" href="#exercise_414"></a> Exercise_4.14</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    执行下述 if 语句后将发生什么情况？</span></span><br><span class="line"><span class="comment">    if (42 = i)   // 编译错误。赋值运算符左侧必须是一个可修改的左值。而字面值是右值。</span></span><br><span class="line"><span class="comment">    if (i = 42)   // true.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><h2 id="exercise_415"><a class="markdownIt-Anchor" href="#exercise_415"></a> Exercise_4.15</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    下面的赋值是非法的，为什么？应该如何修改？</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    double dval; int ival; int *pi;</span></span><br><span class="line"><span class="comment">    dval = ival = pi = 0;</span></span><br><span class="line"><span class="comment">    // pi is a pointer to int.</span></span><br><span class="line"><span class="comment">    // can not assign to 'int' from type 'int *'</span></span><br><span class="line"><span class="comment">    // correct it:</span></span><br><span class="line"><span class="comment">    dval = ival = 0;</span></span><br><span class="line"><span class="comment">    pi = 0;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><h2 id="exercise_416"><a class="markdownIt-Anchor" href="#exercise_416"></a> Exercise_4.16</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    尽管下面的语句合法，但它们实际执行的行为可能和预期并不一样，</span></span><br><span class="line"><span class="comment">    为什么？应该如何修改？</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    if (p = getPtr() != 0)</span></span><br><span class="line"><span class="comment">    if (i = 1024)</span></span><br><span class="line"><span class="comment">    // why? always true. use an assigment as a condition.</span></span><br><span class="line"><span class="comment">    // correct it</span></span><br><span class="line"><span class="comment">    if ((p=getPtr()) != 0)</span></span><br><span class="line"><span class="comment">    if (i == 1024)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><h2 id="exercise_417"><a class="markdownIt-Anchor" href="#exercise_417"></a> Exercise_4.17</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    说明前置递增运算符和后置递增运算符的区别。</span></span><br><span class="line"><span class="comment">    前置递增运算符将对象本身作为左值返回，</span></span><br><span class="line"><span class="comment">    而后置递增运算符将对象原始值的副本作为右值返回。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><h2 id="exercise_418"><a class="markdownIt-Anchor" href="#exercise_418"></a> Exercise_4.18</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    如果132页那个输出vector对象元素的while循环使用前置递增运算符，将得到什么结果？</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    将会从第二个元素开始取值，并且最后对 v.end() 进行取值，结果是未定义的。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><h2 id="exercise_419"><a class="markdownIt-Anchor" href="#exercise_419"></a> Exercise_4.19</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment">    假设 ptr 的类型是指向 int 的指针、vec 的类型是vector、</span></span><br><span class="line"><span class="comment">    ival 的类型是int，说明下面的表达式是何含义？</span></span><br><span class="line"><span class="comment">    如果有表达式不正确，为什么？应该如何修改？</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    (a) ptr != 0 &amp;&amp; *ptr++  </span></span><br><span class="line"><span class="comment">    (b) ival++ &amp;&amp; ival</span></span><br><span class="line"><span class="comment">    (c) vec[ival++] &lt;= vec[ival] </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    (a) 判断ptr 不是一个空指针，并且ptr 当前指向的元素的值也为真，然后将ptr指向下一个元素</span></span><br><span class="line"><span class="comment">    (b) 判断 ival 的值为真，并且 (ival + 1) 的值也为真</span></span><br><span class="line"><span class="comment">    (c) 表达式有误。C++并没有规定 &lt;= 运算符两边的求值顺序，应该改为 vec[ival] &lt;= vec[ival+1]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><h2 id="exercise_420"><a class="markdownIt-Anchor" href="#exercise_420"></a> Exercise_4.20</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    假设 iter 的类型是 vector::iterator, 说明下面的表达式是否合法。如果合法，表达式的含义是什么？如果不合法，错在何处？</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    (a) *iter++;</span></span><br><span class="line"><span class="comment">    (b) (*iter)++;</span></span><br><span class="line"><span class="comment">    (c) *iter.empty();</span></span><br><span class="line"><span class="comment">    (d) iter-&gt;empty();</span></span><br><span class="line"><span class="comment">    (e) ++*iter;</span></span><br><span class="line"><span class="comment">    (f) iter++-&gt;empty();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    (a)合法。返回迭代器所指向的元素，然后迭代器递增。</span></span><br><span class="line"><span class="comment">    (b)不合法。因为vector元素类型是 string，没有 ++ 操作。</span></span><br><span class="line"><span class="comment">    (c)不合法。这里应该加括号。</span></span><br><span class="line"><span class="comment">    (d)合法。判断迭代器当前的元素是否为空。</span></span><br><span class="line"><span class="comment">    (e)不合法。string 类型没有 ++ 操作。</span></span><br><span class="line"><span class="comment">    (f)合法。判断迭代器当前元素是否为空，然后迭代器递增。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><h2 id="exercise_421"><a class="markdownIt-Anchor" href="#exercise_421"></a> Exercise_4.21</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//编写一段程序，使用条件运算符从 vector 中找到哪些元素的值是奇数，然后将这些奇数值翻倍。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ivec{ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> };</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : ivec)</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; ((i &amp; <span class="number">0x1</span>) ? i * <span class="number">2</span> : i) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">}</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    C语言中2113&amp;表示按位与，0x开头的表示的是十六5261进制数，</span></span><br><span class="line"><span class="comment">    k&amp;0x1表示k与0x1按位与4102，其效果为取k的二进制中最右边的数字，</span></span><br><span class="line"><span class="comment">    该式也可以用做判断k的奇偶性， 如果k为奇数，其计算结果为1，否则为0。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><h2 id="exercise_422"><a class="markdownIt-Anchor" href="#exercise_422"></a> Exercise_4.22</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    本节的示例程序将成绩划分为high pass、pass 和 fial 三种，</span></span><br><span class="line"><span class="comment">    扩展该程序使其进一步将 60 分到 75 分之间的成绩设定为 low pass。</span></span><br><span class="line"><span class="comment">    要求程序包含两个版本：一个版本只使用条件运算符；</span></span><br><span class="line"><span class="comment">    另一个版本使用1个或多个if语句。</span></span><br><span class="line"><span class="comment">    哪个版本的程序更容易理解呢？为什么？</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout; <span class="keyword">using</span> std::cin; <span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">for</span> (<span class="type">unsigned</span> g; cin &gt;&gt; g;)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">auto</span> result = g &gt; <span class="number">90</span> ? <span class="string">"high pass"</span> : g &lt; <span class="number">60</span> ? <span class="string">"fail"</span> : g &lt; <span class="number">75</span> ? <span class="string">"low pass"</span> : <span class="string">"pass"</span>;</span><br><span class="line">cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------------------</span></span><br><span class="line"><span class="keyword">if</span> (g &gt; <span class="number">90</span>)         cout &lt;&lt; <span class="string">"high pass"</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (g &lt; <span class="number">60</span>)    cout &lt;&lt; <span class="string">"fail"</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (g &lt; <span class="number">75</span>)    cout &lt;&lt; <span class="string">"low pass"</span>;</span><br><span class="line"><span class="keyword">else</span>                cout &lt;&lt; <span class="string">"pass"</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="exercise_423"><a class="markdownIt-Anchor" href="#exercise_423"></a> Exercise_4.23</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment">    因为运算符的优先级问题，下面这条表达式无法通过编译。</span></span><br><span class="line"><span class="comment">    根据4.12节中的表指出它的问题在哪里？应该如何修改？</span></span><br><span class="line"><span class="comment">    string s = "word";</span></span><br><span class="line"><span class="comment">    string pl = s + s[s.size() - 1] == 's' ? "" : "s" ;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    加法运算符的优先级高于条件运算符。因此要改为：</span></span><br><span class="line"><span class="comment">    string pl = s + (s[s.size() - 1] == 's' ? "" : "s") ;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><h2 id="exercise_424"><a class="markdownIt-Anchor" href="#exercise_424"></a> Exercise_4.24</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    本节的示例程序将成绩划分为 high pass、pass、和fail三种，它的依据是条件运算符满足右结合律。</span></span><br><span class="line"><span class="comment">    假如条件运算符满足的是左结合律，求值的过程将是怎样的？</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    如果条件运算符满足的是左结合律。那么</span></span><br><span class="line"><span class="comment">    finalgrade = (grade &gt; 90) ? "high pass" : (grade &lt; 60) ? "fail" : "pass";</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    等同于</span></span><br><span class="line"><span class="comment">    finalgrade = ((grade &gt; 90) ? "high pass" : (grade &lt; 60)) ? "fail" : "pass";</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    假如此时 grade &gt; 90 ，第一个条件表达式的结果是 "high pass" ，而字符串字面值的类型是 const char *，非空所以为真。</span></span><br><span class="line"><span class="comment">    因此第二个条件表达式的结果是 "fail"。这样就出现了自相矛盾的逻辑。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><h2 id="exercise_425"><a class="markdownIt-Anchor" href="#exercise_425"></a> Exercise_4.25</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    如果一台机器上 int 占 32 位、char 占8位，用的是 Latin-1 字符集，其中字符'q' 的二进制形式是 01110001，</span></span><br><span class="line"><span class="comment">    那么表达式'q' &lt;&lt; 6的值是什么？</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    首先将char类型提升为int 类型，等同于 00000000 00000000 00000000 01110001 &lt;&lt; 6，结果是 00000000 00000000 00011100 01000000，</span></span><br><span class="line"><span class="comment">    转换是十进制是7232。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><h2 id="exercise_426"><a class="markdownIt-Anchor" href="#exercise_426"></a> Exercise_4.26</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    在本节关于测验成绩的例子中，如果使用unsigned int 作为quiz1 的类型会发生什么情况？</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    在有的机器上，unsigned int 类型可能只有 16 位，因此结果是未定义的。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><h2 id="exercise_427"><a class="markdownIt-Anchor" href="#exercise_427"></a> Exercise_4.27</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    下列表达式的结果是什么？</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    unsigned long ul1 = 3, ul2 = 7;</span></span><br><span class="line"><span class="comment">    (a) ul1 &amp; ul2 </span></span><br><span class="line"><span class="comment">    (b) ul1 | ul2 </span></span><br><span class="line"><span class="comment">    (c) ul1 &amp;&amp; ul2</span></span><br><span class="line"><span class="comment">    (d) ul1 || ul2 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    (a) 3</span></span><br><span class="line"><span class="comment">    (b) 7</span></span><br><span class="line"><span class="comment">    (c) true</span></span><br><span class="line"><span class="comment">    (d) ture</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><h2 id="exercise_428"><a class="markdownIt-Anchor" href="#exercise_428"></a> Exercise_4.28</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//编写一段程序，输出每一种内置类型所占空间的大小。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"bool:\t\t"</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">bool</span>) &lt;&lt; <span class="string">" bytes"</span> &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">"char:\t\t"</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">char</span>) &lt;&lt; <span class="string">" bytes"</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"wchar_t:\t"</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">wchar_t</span>) &lt;&lt; <span class="string">" bytes"</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"char16_t:\t"</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">char16_t</span>) &lt;&lt; <span class="string">" bytes"</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"char32_t:\t"</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">char32_t</span>) &lt;&lt; <span class="string">" bytes"</span> &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">"short:\t\t"</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">short</span>) &lt;&lt; <span class="string">" bytes"</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"int:\t\t"</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">int</span>) &lt;&lt; <span class="string">" bytes"</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"long:\t\t"</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">long</span>) &lt;&lt; <span class="string">" bytes"</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"long long:\t"</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">long</span> <span class="type">long</span>) &lt;&lt; <span class="string">" bytes"</span> &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">"float:\t\t"</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">float</span>) &lt;&lt; <span class="string">" bytes"</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"double:\t\t"</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">double</span>) &lt;&lt; <span class="string">" bytes"</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"long double:\t"</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">long</span> <span class="type">double</span>) &lt;&lt; <span class="string">" bytes"</span> &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="exercise_429"><a class="markdownIt-Anchor" href="#exercise_429"></a> Exercise_4.29</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    推断下面代码的输出结果并说明理由。实际运行这段程序，</span></span><br><span class="line"><span class="comment">    结果和你想象的一样吗？如不一样，为什么？</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int x[10];   int *p = x;</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; sizeof(x)/sizeof(*x) &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; sizeof(p)/sizeof(*p) &lt;&lt; endl;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    第一个输出结果是 10。第二个结果是未定义。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><h2 id="exercise_430"><a class="markdownIt-Anchor" href="#exercise_430"></a> Exercise_4.30</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    根据4.12节中的表，在下述表达式的适当位置加上括号，</span></span><br><span class="line"><span class="comment">    使得加上括号之后的表达式的含义与原来的含义相同。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    (a) sizeof x + y      </span></span><br><span class="line"><span class="comment">    (b) sizeof p-&gt;mem[i]  </span></span><br><span class="line"><span class="comment">    (c) sizeof a &lt; b     </span></span><br><span class="line"><span class="comment">    (d) sizeof f()  </span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    (a) (sizeof x) + y</span></span><br><span class="line"><span class="comment">    (b) sizeof(p-&gt;mem[i])</span></span><br><span class="line"><span class="comment">    (c) sizeof(a) &lt; b</span></span><br><span class="line"><span class="comment">    (d) sizeof(f())</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><h2 id="exercise_431"><a class="markdownIt-Anchor" href="#exercise_431"></a> Exercise_4.31</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    本节的程序使用了前置版本的递增运算符和递减运算符，解释为什么要用前置版本而不用后置版本。要想使用后置版本的递增递减运算符需要做哪些改动？使用后置版本重写本节的程序。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    在4.5节（132页）已经说过了，除非必须，否则不用递增递减运算符的后置版本。在这里要使用后者版本的递增递减运算符不需要任何改动。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><h2 id="exercise_432"><a class="markdownIt-Anchor" href="#exercise_432"></a> Exercise_4.32</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    解释下面这个循环的含义。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    constexpr int size = 5;</span></span><br><span class="line"><span class="comment">    int ia[size] = { 1, 2, 3, 4, 5 };</span></span><br><span class="line"><span class="comment">    for (int *ptr = ia, ix = 0;</span></span><br><span class="line"><span class="comment">        ix != size &amp;&amp; ptr != ia+size;</span></span><br><span class="line"><span class="comment">        ++ix, ++ptr) {  ...  }</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    这个循环在遍历数组 ia，指针 ptr 和 整型 ix 都是起到一个循环计数的功能。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><h2 id="exercise_433"><a class="markdownIt-Anchor" href="#exercise_433"></a> Exercise_4.33</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    根据4.12节中的表说明下面这条表达式的含义。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    someValue ? ++x, ++y : --x, --y</span></span><br><span class="line"><span class="comment">    逗号表达式的优先级是最低的。因此这条表达式也等于：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    (someValue ? ++x, ++y : --x), --y</span></span><br><span class="line"><span class="comment">    如果 someValue的值为真，x 和 y 的值都自增并返回 y 值，然后丢弃 y 值，y递减并返回 y 值。如果 someValue的值为假，x 递减并返回 x 值，然后丢弃 x 值，y递减并返回 y 值。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><h2 id="exercise_434"><a class="markdownIt-Anchor" href="#exercise_434"></a> Exercise_4.34</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    根据本节给出的变量定义，说明在下面的表达式中奖发生什么样的类型转换：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    (a) if (fval)</span></span><br><span class="line"><span class="comment">    (b) dval = fval + ival;</span></span><br><span class="line"><span class="comment">    (c) dval + ival * cval;</span></span><br><span class="line"><span class="comment">    需要注意每种运算符遵循的是左结合律还是右结合律。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    (a) fval 转换为 bool 类型</span></span><br><span class="line"><span class="comment">    (b) ival 转换为 float ，相加的结果转换为 double</span></span><br><span class="line"><span class="comment">    (c) cval 转换为 int，然后相乘的结果转换为 double</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><h2 id="exercise_435"><a class="markdownIt-Anchor" href="#exercise_435"></a> Exercise_4.35</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    假设有如下的定义：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    char cval;</span></span><br><span class="line"><span class="comment">    int ival;</span></span><br><span class="line"><span class="comment">    unsigned int ui;</span></span><br><span class="line"><span class="comment">    float fval;</span></span><br><span class="line"><span class="comment">    double dval;</span></span><br><span class="line"><span class="comment">    请回答在下面的表达式中发生了隐式类型转换吗？如果有，指出来。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    (a) cval = 'a' + 3;</span></span><br><span class="line"><span class="comment">    (b) fval = ui - ival * 1.0;</span></span><br><span class="line"><span class="comment">    (c) dval = ui * fval;</span></span><br><span class="line"><span class="comment">    (d) cval = ival + fval + dval;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    (a) 'a' 转换为 int ，然后与 3 相加的结果转换为 char</span></span><br><span class="line"><span class="comment">    (b) ival 转换为 double，ui 转换为 double，结果转换为 float</span></span><br><span class="line"><span class="comment">    (c) ui 转换为 float，结果转换为 double</span></span><br><span class="line"><span class="comment">    (d) ival 转换为 float，与fval相加后的结果转换为 double，最后的结果转换为char</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><h2 id="exercise_436"><a class="markdownIt-Anchor" href="#exercise_436"></a> Exercise_4.36</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    假设 i 是int类型，d 是double类型，书写表达式 i*=d 使其执行整数类型的乘法而非浮点类型的乘法。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    i *= static_cast&lt;int&gt;(d);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><h2 id="exercise_437"><a class="markdownIt-Anchor" href="#exercise_437"></a> Exercise_4.37</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    用命名的强制类型转换改写下列旧式的转换语句。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    int i; double d; const string *ps; char *pc; void *pv;</span></span><br><span class="line"><span class="comment">    (a) pv = (void*)ps;</span></span><br><span class="line"><span class="comment">    (b) i = int(*pc);</span></span><br><span class="line"><span class="comment">    (c) pv = &amp;d;</span></span><br><span class="line"><span class="comment">    (d) pc = (char*)pv;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    (a) pv = static_cast&lt;void*&gt;(const_cast&lt;string*&gt;(ps));</span></span><br><span class="line"><span class="comment">    (b) i = static_cast(*pc);</span></span><br><span class="line"><span class="comment">    (c) pv = static_cast&lt;void*&gt;(&amp;d);</span></span><br><span class="line"><span class="comment">    (d) pc = static_cast&lt;char*&gt;(pv);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><h2 id="exercise_438"><a class="markdownIt-Anchor" href="#exercise_438"></a> Exercise_4.38</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    说明下面这条表达式的含义。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    double slope = static_cast&lt;double&gt;(j/i);</span></span><br><span class="line"><span class="comment">    将 j/i 的结果值转换为 double，然后赋值给slope。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter04 表达式</title>
      <link href="/posts/45e4.html"/>
      <url>/posts/45e4.html</url>
      
        <content type="html"><![CDATA[<h1 id="第4章-表达式"><a class="markdownIt-Anchor" href="#第4章-表达式"></a> 第4章 表达式</h1><h2 id="基础fundamentals"><a class="markdownIt-Anchor" href="#基础fundamentals"></a> 基础（Fundamentals）</h2><p>表达式（expression）由一个或多个运算对象（operand）组成，对表达式求值将得到一个结果（result）。字面值和变量是最简单的表达式，其结果就是字面值和变量的值。</p><h3 id="基础概念basic-concepts"><a class="markdownIt-Anchor" href="#基础概念basic-concepts"></a> 基础概念（Basic Concepts）</h3><p>C++定义了一元运算符（unary operator）和二元运算符（binary operator）。除此之外，还有一个作用于三个运算对象的三元运算符。函数调用也是一种特殊的运算符，它对运算对象的数量没有限制。</p><p>表达式求值过程中，小整数类型（如<code>bool</code>、<code>char</code>、<code>short</code>等）通常会被提升（promoted）为较大的整数类型，主要是<code>int</code>。</p><p>C++定义了运算符作用于内置类型和复合类型的运算对象时所执行的操作。当运算符作用于类类型的运算对象时，用户可以自定义其含义，这被称作运算符重载（overloaded operator）。</p><p>C++的表达式分为右值（rvalue）和左值（lvalue）。<font color="red">当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值时，用的是对象的地址。需要右值的地方可以用左值代替，反之则不行。</font></p><ul><li>赋值运算符需要一个非常量左值作为其左侧运算对象，返回结果也是一个左值。</li><li>取地址符作用于左值运算对象，返回指向该运算对象的指针，该指针是一个右值。</li><li>内置解引用运算符、下标运算符、迭代器解引用运算符、<code>string</code>和<code>vector</code>的下标运算符都返回左值。</li><li>内置类型和迭代器的递增递减运算符作用于左值运算对象。前置版本返回左值，后置版本返回右值。</li></ul><p>如果<code>decltype</code>作用于一个求值结果是左值的表达式，会得到引用类型。</p><h3 id="优先级与结合律precedence-and-associativity"><a class="markdownIt-Anchor" href="#优先级与结合律precedence-and-associativity"></a> 优先级与结合律（Precedence and Associativity）</h3><p>复合表达式（compound expression）指含有两个或多个运算符的表达式。优先级与结合律决定了运算对象的组合方式。</p><p>括号无视优先级与结合律，表达式中括号括起来的部分被当成一个单元来求值，然后再与其他部分一起按照优先级组合。</p><h3 id="求值顺序order-of-evaluation"><a class="markdownIt-Anchor" href="#求值顺序order-of-evaluation"></a> 求值顺序（Order of Evaluation）</h3><p>对于那些没有指定执行顺序的运算符来说，如果表达式指向并修改了同一个对象，将会引发错误并产生未定义的行为。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; ++i &lt;&lt; endl;    <span class="comment">// undefined</span></span><br></pre></td></tr></tbody></table></figure><p>处理复合表达式时建议遵循以下两点：</p><ul><li>不确定求值顺序时，使用括号来强制让表达式的组合关系符合程序逻辑的要求。</li><li>如果表达式改变了某个运算对象的值，则在表达式的其他位置不要再使用这个运算对象。</li></ul><p>当改变运算对象的子表达式本身就是另一个子表达式的运算对象时，第二条规则无效。如<code>*++iter</code>，递增运算符改变了<em>iter</em>的值，而改变后的<em>iter</em>又是解引用运算符的运算对象。类似情况下，求值的顺序不会成为问题。</p><h2 id="算术运算符arithmetic-operators"><a class="markdownIt-Anchor" href="#算术运算符arithmetic-operators"></a> 算术运算符（Arithmetic Operators）</h2><p>算术运算符（左结合律）：</p><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200811154837.png" alt="4-1"></p><p>在除法运算中，C<ins>语言的早期版本允许结果为负数的商向上或向下取整，C</ins>11新标准则规定商一律向0取整（即直接去除小数部分）。</p><h2 id="逻辑和关系运算符logical-and-relational-operators"><a class="markdownIt-Anchor" href="#逻辑和关系运算符logical-and-relational-operators"></a> 逻辑和关系运算符（Logical and Relational Operators）</h2><p>关系运算符作用于算术类型和指针类型，逻辑运算符作用于任意能转换成布尔值的类型。逻辑运算符和关系运算符的返回值都是布尔类型。</p><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200811162232.png" alt="4-2"></p><p>逻辑与（logical AND）运算符<code>&amp;&amp;</code>和逻辑或（logical OR）运算符<code>||</code>都是先计算左侧运算对象的值再计算右侧运算对象的值，当且仅当左侧运算对象无法确定表达式的结果时才会去计算右侧运算对象的值。这种策略称为短路求值（short-circuit evaluation）。</p><ul><li>对于逻辑与运算符来说，当且仅当左侧运算对象为真时才对右侧运算对象求值。</li><li>对于逻辑或运算符来说，当且仅当左侧运算对象为假时才对右侧运算对象求值。</li></ul><p>进行比较运算时，除非比较的对象是布尔类型，否则不要使用布尔字面值<code>true</code>和<code>false</code>作为运算对象。</p><h2 id="赋值运算符assignment-operators"><a class="markdownIt-Anchor" href="#赋值运算符assignment-operators"></a> 赋值运算符（Assignment Operators）</h2><p>赋值运算符<code>=</code>的左侧运算对象必须是一个可修改的左值。</p><p>C++11新标准允许使用花括号括起来的初始值列表作为赋值语句的右侧运算对象。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vi;     <span class="comment">// initially empty</span></span><br><span class="line">vi = {<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>};     <span class="comment">// vi now has ten elements, values 0 through 9</span></span><br></pre></td></tr></tbody></table></figure><p>赋值运算符满足右结合律。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> ival, jval;</span><br><span class="line">ival = jval = <span class="number">0</span>;    <span class="comment">// ok: each assigned 0</span></span><br></pre></td></tr></tbody></table></figure><p>因为赋值运算符的优先级低于关系运算符的优先级，所以在条件语句中，赋值部分通常应该加上括号。</p><p>不要混淆相等运算符<code>==</code>和赋值运算符<code>=</code>。</p><p>复合赋值运算符包括<code>+=</code>、<code>-=</code>、<code>*=</code>、<code>/=</code>、<code>%=</code>、<code>&lt;&lt;=</code>、<code>&gt;&gt;=</code>、<code>&amp;=</code>、<code>^=</code>和<code>|=</code>。任意一种复合运算都完全等价于<em>a = a op b</em>。</p><h2 id="递增和递减运算符increment-and-decrement-operators"><a class="markdownIt-Anchor" href="#递增和递减运算符increment-and-decrement-operators"></a> 递增和递减运算符（Increment and Decrement Operators）</h2><p>递增和递减运算符是为对象加1或减1的简洁书写形式。很多不支持算术运算的迭代器可以使用递增和递减运算符。</p><p>递增和递减运算符分为前置版本和后置版本：</p><ul><li>前置版本首先将运算对象加1（或减1），然后将改变后的对象作为求值结果。</li><li>后置版本也会将运算对象加1（或减1），但求值结果是运算对象改变前的值的副本。</li></ul><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>, j;</span><br><span class="line">j = ++i;    <span class="comment">// j = 1, i = 1: prefix yields the incremented value</span></span><br><span class="line">j = i++;    <span class="comment">// j = 1, i = 2: postfix yields the unincremented value</span></span><br></pre></td></tr></tbody></table></figure><p>除非必须，否则不应该使用递增或递减运算符的后置版本。后置版本需要将原始值存储下来以便于返回修改前的内容，如果我们不需要这个值，那么后置版本的操作就是一种浪费。</p><p>在某些语句中混用解引用和递增运算符可以使程序更简洁。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">cout &lt;&lt; *iter++ &lt;&lt; endl;</span><br></pre></td></tr></tbody></table></figure><h2 id="成员访问运算符the-member-access-operators"><a class="markdownIt-Anchor" href="#成员访问运算符the-member-access-operators"></a> 成员访问运算符（The Member Access Operators）</h2><p>点运算符<code>.</code>和箭头运算符<code>-&gt;</code>都可以用来访问成员，表达式<code>ptr-&gt;mem</code>等价于<code>(*ptr).mem</code>。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">string s1 = <span class="string">"a string"</span>, *p = &amp;s1;</span><br><span class="line"><span class="keyword">auto</span> n = s1.<span class="built_in">size</span>();  <span class="comment">// run the size member of the string s1</span></span><br><span class="line">n = (*p).<span class="built_in">size</span>();    <span class="comment">// run size on the object to which p points</span></span><br><span class="line">n = p-&gt;<span class="built_in">size</span>();      <span class="comment">// equivalent to (*p).size()</span></span><br></pre></td></tr></tbody></table></figure><h2 id="条件运算符the-conditional-operator"><a class="markdownIt-Anchor" href="#条件运算符the-conditional-operator"></a> 条件运算符（The Conditional Operator）</h2><p>条件运算符的使用形式如下：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">cond ? expr1 : expr2;</span><br></pre></td></tr></tbody></table></figure><p>其中<em>cond</em>是判断条件的表达式，如果<em>cond</em>为真则对<em>expr1</em>求值并返回该值，否则对<em>expr2</em>求值并返回该值。</p><p>只有当条件运算符的两个表达式都是左值或者能转换成同一种左值类型时，运算的结果才是左值，否则运算的结果就是右值。</p><p>条件运算符可以嵌套，但是考虑到代码的可读性，运算的嵌套层数最好不要超过两到三层。</p><p>条件运算符的优先级非常低，因此当一个长表达式中嵌套了条件运算子表达式时，通常需要在它两端加上括号。</p><h2 id="位运算符the-bitwise-operators"><a class="markdownIt-Anchor" href="#位运算符the-bitwise-operators"></a> 位运算符（The Bitwise Operators）</h2><p>位运算符（左结合律）：</p><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200812155042.png" alt="4-3"></p><p>在位运算中符号位如何处理并没有明确的规定，所以建议仅将位运算符用于无符号类型的处理。</p><p>左移运算符<code>&lt;&lt;</code>在运算对象右侧插入值为0的二进制位。右移运算符<code>&gt;&gt;</code>的行为依赖于其左侧运算对象的类型：如果该运算对象是无符号类型，在其左侧插入值为0的二进制位；如果是带符号类型，在其左侧插入符号位的副本或者值为0的二进制位，如何选择视具体环境而定。</p><h2 id="sizeof运算符the-sizeof-operator"><a class="markdownIt-Anchor" href="#sizeof运算符the-sizeof-operator"></a> sizeof运算符（The sizeof Operator）</h2><p><code>sizeof</code>运算符返回一个表达式或一个类型名字所占的字节数，返回值是<code>size_t</code>类型。</p><p>在<code>sizeof</code>的运算对象中解引用一个无效指针仍然是一种安全的行为，因为指针实际上并没有被真正使用。</p><p><code>sizeof</code>运算符的结果部分依赖于其作用的类型：</p><ul><li>对<code>char</code>或者类型为<code>char</code>的表达式执行<code>sizeof</code>运算，返回值为1。</li><li>对引用类型执行<code>sizeof</code>运算得到被引用对象所占空间的大小。</li><li>对指针执行<code>sizeof</code>运算得到指针本身所占空间的大小。</li><li>对解引用指针执行<code>sizeof</code>运算得到指针指向的对象所占空间的大小，指针不需要有效。</li><li>对数组执行<code>sizeof</code>运算得到整个数组所占空间的大小。</li><li>对<code>string</code>或<code>vector</code>对象执行<code>sizeof</code>运算只返回该类型固定部分的大小，不会计算对象中元素所占空间的大小。</li></ul><h2 id="逗号运算符comma-operator"><a class="markdownIt-Anchor" href="#逗号运算符comma-operator"></a> 逗号运算符（Comma Operator）</h2><p>逗号运算符<code>,</code>含有两个运算对象，按照从左向右的顺序依次求值，最后返回右侧表达式的值。逗号运算符经常用在<code>for</code>循环中。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::size_type cnt = ivec.<span class="built_in">size</span>();</span><br><span class="line"><span class="comment">// assign values from size... 1 to the elements in ivec</span></span><br><span class="line"><span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::size_type ix = <span class="number">0</span>; ix != ivec.<span class="built_in">size</span>(); ++ix, --cnt)</span><br><span class="line">    ivec[ix] = cnt;</span><br></pre></td></tr></tbody></table></figure><h2 id="类型转换type-conversions"><a class="markdownIt-Anchor" href="#类型转换type-conversions"></a> 类型转换（Type Conversions）</h2><p>无须程序员介入，会自动执行的类型转换叫做隐式转换（implicit conversions）。</p><h3 id="算术转换integral-promotions"><a class="markdownIt-Anchor" href="#算术转换integral-promotions"></a> 算术转换（Integral Promotions）</h3><p>把一种算术类型转换成另一种算术类型叫做算术转换。</p><p>整型提升（integral promotions）负责把小整数类型转换成较大的整数类型。</p><h3 id="其他隐式类型转换other-implicit-conversions"><a class="markdownIt-Anchor" href="#其他隐式类型转换other-implicit-conversions"></a> 其他隐式类型转换（Other Implicit Conversions）</h3><p>在大多数表达式中，数组名字自动转换成指向数组首元素的指针。</p><p>常量整数值0或字面值<code>nullptr</code>能转换成任意指针类型；指向任意非常量的指针能转换成<code>void*</code>；指向任意对象的指针能转换成<code>const void*</code>。</p><p>任意一种算术类型或指针类型都能转换成布尔类型。如果指针或算术类型的值为0，转换结果是<code>false</code>，否则是<code>true</code>。</p><p>指向非常量类型的指针能转换成指向相应的常量类型的指针。</p><h3 id="显式转换explicit-conversions"><a class="markdownIt-Anchor" href="#显式转换explicit-conversions"></a> 显式转换（Explicit Conversions）</h3><p>显式类型转换也叫做强制类型转换（cast）。虽然有时不得不使用强制类型转换，但这种方法本质上是非常危险的。建议尽量避免强制类型转换。</p><p>命名的强制类型转换（named cast）形式如下：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">cast-<span class="built_in">name</span>&lt;type&gt;(expression);</span><br></pre></td></tr></tbody></table></figure><p>其中<em>type</em>是转换的目标类型，<em>expression</em>是要转换的值。如果<em>type</em>是引用类型，则转换结果是左值。<em>cast-name</em>是<code>static_cast</code>、<code>dynamic_cast</code>、<code>const_cast</code>和<code>reinterpret_cast</code>中的一种，用来指定转换的方式。</p><ul><li><code>dynamic_cast</code>支持运行时类型识别。</li><li>任何具有明确定义的类型转换，只要不包含底层<code>const</code>，都能使用<code>static_cast</code>。</li><li><code>const_cast</code>只能改变运算对象的底层<code>const</code>，不能改变表达式的类型。同时也只有<code>const_cast</code>能改变表达式的常量属性。<code>const_cast</code>常常用于函数重载。</li><li><code>reinterpret_cast</code>通常为运算对象的位模式提供底层上的重新解释。</li></ul><p>早期版本的C++语言中，显式类型转换包含两种形式：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">type</span> (expression);    <span class="comment">// function-style cast notation</span></span><br><span class="line">(type) expression;    <span class="comment">// C-language-style cast notation</span></span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ getline()</title>
      <link href="/posts/87ea.html"/>
      <url>/posts/87ea.html</url>
      
        <content type="html"><![CDATA[<p>虽然可以使用 cin 和 &gt;&gt; 运算符来输入字符串，但它可能会导致一些需要注意的问题。</p><p>当 cin 读取数据时，它会传递并忽略任何前导白色空格字符（空格、制表符或换行符）。一旦它接触到第一个非空格字符即开始阅读，当它读取到下一个空白字符时，它将停止读取。以下面的语句为例：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">cin &gt;&gt; namel;</span><br></pre></td></tr></tbody></table></figure><p>可以输入 “Mark” 或 “Twain”，但不能输入 “Mark Twain”，因为 cin 不能输入包含嵌入空格的字符串。下面程序演示了这个问题：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// This program illustrates a problem that can occur if</span></span><br><span class="line"><span class="comment">// cin is used to read character data into a string object.</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span> <span class="comment">// Header file needed to use string objects</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    string name;</span><br><span class="line">    string city;</span><br><span class="line">    cout &lt;&lt; <span class="string">"Please enter your name: "</span>;</span><br><span class="line">    cin &gt;&gt; name;</span><br><span class="line">    cout &lt;&lt; <span class="string">"Enter the city you live in: "</span>;</span><br><span class="line">    cin &gt;&gt; city;</span><br><span class="line">    cout &lt;&lt; <span class="string">"Hello, "</span> &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"You live in "</span> &lt;&lt; city &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序输出结果：</p><blockquote><p>Please enter your name： John Doe<br>Enter the city you live in: Hello, John<br>You live in Doe</p></blockquote><p>请注意，在这个示例中，用户根本没有机会输入 city 城市名。因为在第一个输入语句中，当 cin 读取到 John 和 Doe 之间的空格时，它就会停止阅读，只存储 John 作为 name 的值。在第二个输入语句中， cin 使用键盘缓冲区中找到的剩余字符，并存储 Doe 作为 city 的值。</p><p>为了解决这个问题，可以使用一个叫做 getline 的 C++ 函数。此函数可读取整行，包括前导和嵌入的空格，并将其存储在字符串对象中。</p><p>getline 函数如下所示：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">getline</span>(cin, inputLine);</span><br></pre></td></tr></tbody></table></figure><p>其中 cin 是正在读取的输入流，而 inputLine 是接收输入字符串的 string 变量的名称。下面的程序演示了 getline 函数的应用：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// This program illustrates using the getline function</span></span><br><span class="line"><span class="comment">//to read character data into a string object.</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span> <span class="comment">// Header file needed to use string objects</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    string name;</span><br><span class="line">    string city;</span><br><span class="line">    cout &lt;&lt; <span class="string">"Please enter your name: "</span>;</span><br><span class="line">    <span class="built_in">getline</span>(cin, name);</span><br><span class="line">    cout &lt;&lt; <span class="string">"Enter the city you live in: "</span>;</span><br><span class="line">    <span class="built_in">getline</span>(cin, city);</span><br><span class="line">    cout &lt;&lt; <span class="string">"Hello, "</span> &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"You live in "</span> &lt;&lt; city &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>程序输出结果：</p><blockquote><p>Please enter your name: John Doe<br>Enter the city you live in: Chicago<br>Hello, John Doe<br>You live in Chicago</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Exercise of chapter 3</title>
      <link href="/posts/a5.html"/>
      <url>/posts/a5.html</url>
      
        <content type="html"><![CDATA[<h2 id="exercise-32"><a class="markdownIt-Anchor" href="#exercise-32"></a> Exercise 3.2</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   编写一段程序从标准输入中一次读入一行，然后修改该程序使其一次读入一个词。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    string s;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">getline</span>(cin,s))</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">}      <span class="comment">//一次读入一行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; s)</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">}       <span class="comment">//一次读入一个词</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="exercise-33"><a class="markdownIt-Anchor" href="#exercise-33"></a> Exercise 3.3</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   请说明string类的输入运算符和getline函数分别是如何处理空白字符的。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">/*******输入 " this is a string."************/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   类似 getline(is, s) 的读取，string对象</span></span><br><span class="line"><span class="comment">*   会从输入流中读取字符，直到遇见换行符为止。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    string s;  <span class="comment">// 输入 " this is a string."</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">getline</span>(cin,s))</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   类似 is &gt;&gt; s 的读取，string对象会忽略开头的空白</span></span><br><span class="line"><span class="comment">*   并从第一个真正的字符开始，直到遇见下一空白为止。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; s)</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="exercise-34"><a class="markdownIt-Anchor" href="#exercise-34"></a> Exercise 3.4</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   请说明string类的输入运算符和getline函数分别是如何处理空白字符的。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">/*******输入 " this is a string."************/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   类似 getline(is, s) 的读取，string对象</span></span><br><span class="line"><span class="comment">*   会从输入流中读取字符，直到遇见换行符为止。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    string s;  <span class="comment">// 输入 " this is a string."</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">getline</span>(cin,s))</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   类似 is &gt;&gt; s 的读取，string对象会忽略开头的空白</span></span><br><span class="line"><span class="comment">*   并从第一个真正的字符开始，直到遇见下一空白为止。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; s)</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="exercise-35"><a class="markdownIt-Anchor" href="#exercise-35"></a> Exercise 3.5</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*    编写一段程序从标准输入中读入多个字符串并将他们连接起来，</span></span><br><span class="line"><span class="comment">*    输出连接成的大字符串。然后修改上述程序，用空格把输入的多个字符串分割开来。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{   </span><br><span class="line">string result, s;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; s)</span><br><span class="line">{</span><br><span class="line">result += s;</span><br><span class="line">}</span><br><span class="line">cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    string result, s;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; s)</span><br><span class="line">{</span><br><span class="line">result += s + <span class="string">" "</span>;</span><br><span class="line">}</span><br><span class="line">cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="exercise-36"><a class="markdownIt-Anchor" href="#exercise-36"></a> Exercise 3.6</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">string <span class="title">line</span> <span class="params">(<span class="string">"this is a string."</span>)</span></span>;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c:line){</span><br><span class="line">       <span class="keyword">if</span>(<span class="built_in">isalpha</span>(c)){</span><br><span class="line">           c = <span class="string">'X'</span>;</span><br><span class="line">       }</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; line &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="exercise-37"><a class="markdownIt-Anchor" href="#exercise-37"></a> Exercise 3.7</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">string <span class="title">line</span> <span class="params">(<span class="string">"this is a string."</span>)</span></span>;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> c:line){</span><br><span class="line">       <span class="keyword">if</span>(<span class="built_in">isalpha</span>(c)){</span><br><span class="line">           c = <span class="string">'X'</span>;</span><br><span class="line">       }</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; line &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//如果设置为char，那么原来的字符串不会发生改变。</span></span><br></pre></td></tr></tbody></table></figure><h2 id="exercise-38"><a class="markdownIt-Anchor" href="#exercise-38"></a> Exercise 3.8</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">string <span class="title">line</span><span class="params">(<span class="string">"this is a string"</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;line.<span class="built_in">size</span>()){</span><br><span class="line">        <span class="keyword">if</span>( <span class="built_in">isalpha</span>(line[i]))</span><br><span class="line">        {</span><br><span class="line">            line[i] = <span class="string">'X'</span>;</span><br><span class="line">        }</span><br><span class="line">        i++;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; line &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; line.<span class="built_in">size</span>();i++){</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isalpha</span>(line[i]))</span><br><span class="line">            line[i] = <span class="string">'Y'</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; line &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 范围for语句更好，不直接操作索引，更简洁。</span></span><br></pre></td></tr></tbody></table></figure><h2 id="exercise-39"><a class="markdownIt-Anchor" href="#exercise-39"></a> Exercise 3.9</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">string <span class="title">line</span><span class="params">(<span class="string">"this is a string"</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; line[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    string s;</span><br><span class="line">    cout &lt;&lt; s[<span class="number">0</span>] &lt;&lt; endl;     <span class="comment">//使用下标访问空字符串是非法的行为。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="exercise-310"><a class="markdownIt-Anchor" href="#exercise-310"></a> Exercise 3.10</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">string <span class="title">line</span><span class="params">(<span class="string">"Hello my name is lhg, this is my blog."</span>)</span></span>;</span><br><span class="line">    string result;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != line.<span class="built_in">size</span>();i++){</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">ispunct</span>(line[i]))</span><br><span class="line">            result += line[i];</span><br><span class="line">    } <span class="comment">// one </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c:line){</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">ispunct</span>(c))</span><br><span class="line">            result += c;</span><br><span class="line">    } <span class="comment">// two</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; line &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="exercise-311"><a class="markdownIt-Anchor" href="#exercise-311"></a> Exercise 3.11</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Is the following range for legal? If so, what is the type of c?</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="type">const</span> string <span class="title">line</span><span class="params">(<span class="string">"keep out !"</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c:line){</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        ****************</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   要根据for循环中的代码来看是否合法，c是string 对象中字符的引用，s是常量。</span></span><br><span class="line"><span class="comment">    因此如果for循环中的代码重新给c赋值就会非法，如果不改变c的值，那么合法。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><h2 id="exercise-312"><a class="markdownIt-Anchor" href="#exercise-312"></a> Exercise 3.12</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   下列vector对象的定义有不正确的吗？如果有，请指出来。</span></span><br><span class="line"><span class="comment">*    对于正确的，描述其执行结果；对于不正确的，说明其错误的原因。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ivec;         <span class="comment">// 在C++11当中合法</span></span><br><span class="line"><span class="comment">//    vector&lt;string&gt; svec = ivec;       // 不合法，类型不一样</span></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">svec</span><span class="params">(<span class="number">10</span>, <span class="string">"null"</span>)</span></span>;  <span class="comment">// 合法</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="exercise-313"><a class="markdownIt-Anchor" href="#exercise-313"></a> Exercise 3.13</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   下列的vector对象各包含多少个元素？这些元素的值分别是多少？</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v1;         <span class="comment">// size:0,  no values.</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v2</span><span class="params">(<span class="number">10</span>)</span></span>;     <span class="comment">// size:10, value:0</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">10</span>, <span class="number">42</span>)</span></span>; <span class="comment">// size:10, value:42</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v4{ <span class="number">10</span> };     <span class="comment">// size:1,  value:10</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v5{ <span class="number">10</span>, <span class="number">42</span> }; <span class="comment">// size:2,  value:10, 42</span></span><br><span class="line">    vector&lt;string&gt; v6{ <span class="number">10</span> };  <span class="comment">// size:10, value:""</span></span><br><span class="line">    vector&lt;string&gt; v7{ <span class="number">10</span>, <span class="string">"hi"</span> };  <span class="comment">// size:10, value:"hi"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="exercise-314"><a class="markdownIt-Anchor" href="#exercise-314"></a> Exercise 3.14</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   编写一段程序，用cin读入一组整数并把它们存入一个vector对象。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; number;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;i)</span><br><span class="line">        number.<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="exercise-315"><a class="markdownIt-Anchor" href="#exercise-315"></a> Exercise 3.15</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   编写一段程序，用cin读入一组读入的字符串。</span></span><br><span class="line"><span class="comment">*   并把它们存入一个vector对象。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    vector&lt;string&gt; line;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;s){</span><br><span class="line">        line.<span class="built_in">push_back</span>(s);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="exercise-316"><a class="markdownIt-Anchor" href="#exercise-316"></a> Exercise 3.16</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   编写一段程序，把练习3.13中vector对象的容量和具体内容输出出来</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v1;         <span class="comment">// size:0,  no values.</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v2</span><span class="params">(<span class="number">10</span>)</span></span>;     <span class="comment">// size:10, value:0</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">10</span>, <span class="number">42</span>)</span></span>; <span class="comment">// size:10, value:42</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v4{ <span class="number">10</span> };     <span class="comment">// size:1,  value:10</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v5{ <span class="number">10</span>, <span class="number">42</span> }; <span class="comment">// size:2,  value:10, 42</span></span><br><span class="line">    vector&lt;string&gt; v6{ <span class="number">10</span> };  <span class="comment">// size:10, value:""</span></span><br><span class="line">    vector&lt;string&gt; v7{ <span class="number">10</span>, <span class="string">"hi"</span> };  <span class="comment">// size:10, value:"hi"</span></span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; X {v1, v2, v3, v4, v5};</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; X.<span class="built_in">size</span>();i++){</span><br><span class="line">        cout &lt;&lt; <span class="string">"v"</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">" "</span>&lt;&lt; <span class="string">"size :"</span> &lt;&lt; X[i].<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> n : X[i]){</span><br><span class="line">            cout &lt;&lt; n &lt;&lt; <span class="string">" "</span>&lt;&lt; endl;</span><br><span class="line">        }</span><br><span class="line">        cout &lt;&lt; endl&lt;&lt; endl;</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; Y {v6, v7};</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; Y.<span class="built_in">size</span>();i++){</span><br><span class="line">        cout &lt;&lt; <span class="string">"v"</span>&lt;&lt;i+<span class="number">6</span>&lt;&lt;<span class="string">" "</span>&lt;&lt; <span class="string">"size :"</span> &lt;&lt; Y[i].<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> m : Y[i]){</span><br><span class="line">            cout &lt;&lt; m &lt;&lt; <span class="string">" "</span>&lt;&lt; endl;</span><br><span class="line">        }</span><br><span class="line">        cout &lt;&lt; endl&lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">v1 size :0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">v2 size :10</span></span><br><span class="line"><span class="comment">0 0 0 0 0 0 0 0 0 0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">v3 size :10</span></span><br><span class="line"><span class="comment">42 42 42 42 42 42 42 42 42 42</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">v4 size :1</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">v5 size :2</span></span><br><span class="line"><span class="comment">10 42</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">v1 size :10</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">v2 size :10</span></span><br><span class="line"><span class="comment">hi hi hi hi hi hi hi hi hi hi</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><h2 id="exercise-317"><a class="markdownIt-Anchor" href="#exercise-317"></a> Exercise 3.17</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   编写一段程序，用cin读入一组整数并把它们存入一个vector对象。</span></span><br><span class="line"><span class="comment">*   然后设法把所有词都改为大写形式。输出改变后的结果，每个词占一行。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    vector&lt;string&gt; number;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;s){</span><br><span class="line">        number.<span class="built_in">push_back</span>(s);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;str:number){</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c:str)</span><br><span class="line">            c = <span class="built_in">toupper</span>(c);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : number)</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    for (decltype(number.size()) i = 0; i != number.size(); ++i) {</span></span><br><span class="line"><span class="comment">        if (i != 0 &amp;&amp; i % 8 == 0) cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; number[i] &lt;&lt; " ";</span></span><br><span class="line"><span class="comment">    }</span></span><br><span class="line"><span class="comment">    cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="exercise-318"><a class="markdownIt-Anchor" href="#exercise-318"></a> Exercise 3.18</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   下面的程序合法吗？如果不合法，你准备如何修改？</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ivec;</span><br><span class="line">    ivec[<span class="number">0</span>] = <span class="number">42</span>;      <span class="comment">// 错误 改为ivec.push_back(42);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="exercise-319"><a class="markdownIt-Anchor" href="#exercise-319"></a> Exercise 3.19</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   如果想定义一个含有10个元素的vector对象，所有元素的值都是42，</span></span><br><span class="line"><span class="comment">*  请例举三种不同的实现方法，哪种方式更好呢？</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">num1</span><span class="params">(<span class="number">10</span>,<span class="number">42</span>)</span></span>;    <span class="comment">// best way</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; num2{<span class="number">42</span>, <span class="number">42</span>, <span class="number">42</span>, <span class="number">42</span>, <span class="number">42</span>, <span class="number">42</span>, <span class="number">42</span>, <span class="number">42</span>, <span class="number">42</span>, <span class="number">42</span>};</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; num;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">decltype</span>(num.<span class="built_in">size</span>()) i = <span class="number">0</span>; i != num.<span class="built_in">size</span>(); ++i){</span><br><span class="line">        num.<span class="built_in">push_back</span>(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="exercise-320"><a class="markdownIt-Anchor" href="#exercise-320"></a> Exercise 3.20</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   读入一组整数并把他们存入一个vector对象，将每对相邻整数的和输出出来。</span></span><br><span class="line"><span class="comment">*   改写你的程序，这次要求先输出第一个和最后一个元素的和，</span></span><br><span class="line"><span class="comment">*   接着输入第二个和倒数第二个元素的和，以此类推。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ivec;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; i)</span><br><span class="line">ivec.<span class="built_in">push_back</span>(i);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ivec.<span class="built_in">size</span>() - <span class="number">1</span>; ++i)</span><br><span class="line">cout &lt;&lt; ivec[i] + ivec[i + <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//---------------------------------</span></span><br><span class="line">cout &lt;&lt; <span class="string">"---------------------------------"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> n = ivec.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (m &lt; n)</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; ivec[m] + ivec[n] &lt;&lt; endl;</span><br><span class="line">++m;</span><br><span class="line">--n;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="exercise-321-0"><a class="markdownIt-Anchor" href="#exercise-321-0"></a> Exercise 3.21-0</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*    请使用迭代器重做3.3.3节的第一个练习。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v1;         <span class="comment">// size:0,  no values.</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v2</span><span class="params">(<span class="number">10</span>)</span></span>;     <span class="comment">// size:10, value:0</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">10</span>, <span class="number">42</span>)</span></span>; <span class="comment">// size:10, value:42</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v4{ <span class="number">10</span> };     <span class="comment">// size:1,  value:10</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v5{ <span class="number">10</span>, <span class="number">42</span> }; <span class="comment">// size:2,  value:10, 42</span></span><br><span class="line">    vector&lt;string&gt; v6{ <span class="number">10</span> };  <span class="comment">// size:10, value:""</span></span><br><span class="line">    vector&lt;string&gt; v7{ <span class="number">10</span>, <span class="string">"hi"</span> };  <span class="comment">// size:10, value:"hi"</span></span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; X {v1, v2, v3, v4, v5};</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;::const_iterator it;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">decltype</span>(X.<span class="built_in">size</span>()) i = <span class="number">0</span>; i != X.<span class="built_in">size</span>(); ++i) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"v"</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">" "</span>&lt;&lt; <span class="string">"size :"</span> &lt;&lt; X[i].<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = X[i].<span class="built_in">cbegin</span>(); it !=X[i].<span class="built_in">cend</span>(); ++it){</span><br><span class="line">            cout &lt;&lt; (*it) &lt;&lt; <span class="string">" "</span>&lt;&lt; endl;</span><br><span class="line">        }</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; Y {v6, v7};</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;::const_iterator its;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">decltype</span>(Y.<span class="built_in">size</span>()) i = <span class="number">0</span>; i != Y.<span class="built_in">size</span>(); ++i){</span><br><span class="line">        cout &lt;&lt; <span class="string">"v"</span>&lt;&lt;i+<span class="number">6</span>&lt;&lt;<span class="string">" "</span>&lt;&lt; <span class="string">"size :"</span> &lt;&lt; Y[i].<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> its = Y[i].<span class="built_in">cbegin</span>(); its!=Y[i].<span class="built_in">cend</span>(); ++its){</span><br><span class="line">            cout &lt;&lt; (*its) &lt;&lt; <span class="string">" "</span>&lt;&lt; endl;</span><br><span class="line">        }</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="exercise-321-1"><a class="markdownIt-Anchor" href="#exercise-321-1"></a> Exercise 3.21-1</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">check_and_print</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; vec)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">cout &lt;&lt; <span class="string">"size: "</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; <span class="string">"  content: ["</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); ++it)</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; (it != vec.<span class="built_in">end</span>() - <span class="number">1</span> ? <span class="string">","</span> : <span class="string">""</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">"]\n"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">check_and_print</span><span class="params">(<span class="type">const</span> vector&lt;string&gt;&amp; vec)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">"size: "</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; <span class="string">"  content: ["</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); ++it)</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; (it != vec.<span class="built_in">end</span>() - <span class="number">1</span> ? <span class="string">","</span> : <span class="string">""</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">"]\n"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v2</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">10</span>, <span class="number">42</span>)</span></span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v4{ <span class="number">10</span> };</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v5{ <span class="number">10</span>, <span class="number">42</span> };</span><br><span class="line">vector&lt;string&gt; v6{ <span class="number">10</span> };</span><br><span class="line">vector&lt;string&gt; v7{ <span class="number">10</span>, <span class="string">"hi"</span> };</span><br><span class="line"></span><br><span class="line"><span class="built_in">check_and_print</span>(v1);</span><br><span class="line"><span class="built_in">check_and_print</span>(v2);</span><br><span class="line"><span class="built_in">check_and_print</span>(v3);</span><br><span class="line"><span class="built_in">check_and_print</span>(v4);</span><br><span class="line"><span class="built_in">check_and_print</span>(v5);</span><br><span class="line"><span class="built_in">check_and_print</span>(v6);</span><br><span class="line"><span class="built_in">check_and_print</span>(v7);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="exercise-321-2"><a class="markdownIt-Anchor" href="#exercise-321-2"></a> Exercise 3.21-2</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">check</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; vec)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (vec.<span class="built_in">empty</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">"size: 0; no values."</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        cout &lt;&lt; <span class="string">"size: "</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; <span class="string">"; values:"</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); ++it) cout &lt;&lt; *it &lt;&lt; <span class="string">","</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">"\b."</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">check</span><span class="params">(<span class="type">const</span> vector&lt;string&gt;&amp; vec)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (vec.<span class="built_in">empty</span>())</span><br><span class="line">        cout &lt;&lt; <span class="string">"size: 0; no values."</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        cout &lt;&lt; <span class="string">"size: "</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; <span class="string">"; values:"</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); ++it)</span><br><span class="line">            <span class="keyword">if</span> (it-&gt;<span class="built_in">empty</span>())</span><br><span class="line">                cout &lt;&lt; <span class="string">"(null)"</span></span><br><span class="line">                     &lt;&lt; <span class="string">","</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cout &lt;&lt; *it &lt;&lt; <span class="string">","</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">"\b."</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v2</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">10</span>, <span class="number">42</span>)</span></span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v4{<span class="number">10</span>};</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v5{<span class="number">10</span>, <span class="number">42</span>};</span><br><span class="line">    vector&lt;string&gt; v6{<span class="number">10</span>};</span><br><span class="line">    vector&lt;string&gt; v7{<span class="number">10</span>, <span class="string">"hi"</span>};</span><br><span class="line"></span><br><span class="line">    <span class="built_in">check</span>(v1);</span><br><span class="line">    <span class="built_in">check</span>(v2);</span><br><span class="line">    <span class="built_in">check</span>(v3);</span><br><span class="line">    <span class="built_in">check</span>(v4);</span><br><span class="line">    <span class="built_in">check</span>(v5);</span><br><span class="line">    <span class="built_in">check</span>(v6);</span><br><span class="line">    <span class="built_in">check</span>(v7);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="exercise-322"><a class="markdownIt-Anchor" href="#exercise-322"></a> Exercise 3.22</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   修改之前那个输出text第一段的程序，首先把text的第一段全部改成大写形式，然后输出它。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    vector&lt;string&gt; text;</span><br><span class="line">    <span class="comment">//vector&lt;string&gt;::iterator it;</span></span><br><span class="line">    text.<span class="built_in">push_back</span>(<span class="string">"this is a string"</span>);</span><br><span class="line">    text.<span class="built_in">push_back</span>(<span class="string">""</span>);     <span class="comment">//使用空字符串分割段落</span></span><br><span class="line">    text.<span class="built_in">push_back</span>(<span class="string">"this is another string"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = text.<span class="built_in">begin</span>(); it != text.<span class="built_in">end</span>() &amp;&amp; !it-&gt;<span class="built_in">empty</span>(); ++it){</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;c : *it){</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">isalpha</span>(c)) c = <span class="built_in">toupper</span>(c);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it : text){</span><br><span class="line">cout &lt;&lt; it &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="exercise-323"><a class="markdownIt-Anchor" href="#exercise-323"></a> Exercise 3.23</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   编写一段程序，创建一个含有10个整数的vector对象，</span></span><br><span class="line"><span class="comment">*   然后使用迭代器将所有元素的值都变成原来的两倍。</span></span><br><span class="line"><span class="comment">*   输出vector对象的内容，检验程序是否正确。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"><span class="keyword">using</span> std::string;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; num;</span><br><span class="line">    <span class="comment">//vector&lt;int&gt; num(10, 42);</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i != <span class="number">10</span>;i++){</span><br><span class="line">         num.<span class="built_in">push_back</span>(i);          <span class="comment">// 先定义迭代器再使用范围for会导致迭代器失效</span></span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt; <span class="string">"the result is [ "</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// iterator way</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = num.<span class="built_in">begin</span>(); it != num.<span class="built_in">end</span>();it++){</span><br><span class="line">        *it *= <span class="number">2</span>;</span><br><span class="line">        cout &lt;&lt; (*it) &lt;&lt; <span class="string">" "</span>; </span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// range for</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;it : num)</span><br><span class="line">{</span><br><span class="line">it = it * <span class="number">2</span>;</span><br><span class="line">cout &lt;&lt; it &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt;<span class="string">" ]"</span>&lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="exercise-324"><a class="markdownIt-Anchor" href="#exercise-324"></a> Exercise 3.24</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   读入一组整数并把他们存入一个vector对象，将每对相邻整数的和输出出来。</span></span><br><span class="line"><span class="comment">*   改写你的程序，这次要求先输出第一个和最后一个元素的和，</span></span><br><span class="line"><span class="comment">*   接着输入第二个和倒数第二个元素的和，以此类推。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*********  iterator way *************/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ivec;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="comment">/*while (cin &gt;&gt; i)</span></span><br><span class="line"><span class="comment">ivec.push_back(i);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i != <span class="number">10</span>;++i){</span><br><span class="line">         ivec.<span class="built_in">push_back</span>(i);          <span class="comment">// 先定义迭代器再使用范围for会导致迭代器失效</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = ivec.<span class="built_in">begin</span>(); it != ivec.<span class="built_in">end</span>()<span class="number">-1</span>; ++it)</span><br><span class="line">        cout &lt;&lt; (*it) + *(it+<span class="number">1</span>)&lt;&lt; <span class="string">" "</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"---------------------------------"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> it1 = ivec.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">auto</span> it2 = ivec.<span class="built_in">end</span>() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (it1 &lt; it2)</span><br><span class="line">{</span><br><span class="line">cout &lt;&lt; *it1 + *it2 &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">++it1;</span><br><span class="line">--it2;</span><br><span class="line">}</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="exercise-325"><a class="markdownIt-Anchor" href="#exercise-325"></a> Exercise 3.25</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   3.3.3节划分分数段的程序是使用下标运算符实现的，</span></span><br><span class="line"><span class="comment">*   请利用迭代器改写该程序实现完全相同的功能。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ivec{<span class="number">42</span>,<span class="number">65</span>,<span class="number">95</span>,<span class="number">100</span>,<span class="number">39</span>,<span class="number">67</span>,<span class="number">95</span>,<span class="number">76</span>,<span class="number">88</span>,<span class="number">76</span>,<span class="number">83</span>,<span class="number">92</span>,<span class="number">76</span>,<span class="number">93</span>}; <span class="comment">// 列表初始化</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">unsigned</span>&gt; <span class="title">scores</span><span class="params">(<span class="number">11</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="type">unsigned</span> garde;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********  index way *************/</span></span><br><span class="line">    <span class="keyword">while</span> (cin&gt;&gt;garde){</span><br><span class="line">        <span class="keyword">if</span>(garde&lt;=<span class="number">100</span>)</span><br><span class="line">            ++scores[garde / <span class="number">10</span>];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="comment">/*********  iterator way *************/</span></span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; garde)</span><br><span class="line">{</span><br><span class="line"><span class="keyword">if</span> (garde &lt;= <span class="number">100</span>)</span><br><span class="line">++*(scores.<span class="built_in">begin</span>() + garde / <span class="number">10</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> s : scores)</span><br><span class="line">cout &lt;&lt; s &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="exercise-326"><a class="markdownIt-Anchor" href="#exercise-326"></a> Exercise 3.26</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   在100页的二分搜索程序中，为什么用的是 mid = beg + (end - beg) / 2, </span></span><br><span class="line"><span class="comment">*   而非 mid = (beg + end) / 2 ; ?</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   因为迭代器支持的运算只有 - ，而没有 + 。end - beg 意思是相距若干个元素，</span></span><br><span class="line"><span class="comment">*   将之除以2然后与beg相加，表示将beg移动到一半的位置。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    vector&lt;string&gt; text;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// text must be sorted</span></span><br><span class="line">    <span class="comment">// beg and end will denote the range we're searching</span></span><br><span class="line">    <span class="keyword">auto</span> beg = text.<span class="built_in">begin</span>(), end = text.<span class="built_in">end</span>();</span><br><span class="line">    <span class="keyword">auto</span> mid = text.<span class="built_in">begin</span>() + (end - beg)/<span class="number">2</span>;        <span class="comment">// original midpoint</span></span><br><span class="line">    <span class="comment">// while there are still elements to look at and we haven't yet found sought</span></span><br><span class="line">    <span class="keyword">while</span> (mid != end &amp;&amp; *mid != <span class="string">"sought"</span>) {</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"sought"</span> &lt; *mid)  <span class="comment">// is the element we want in the first half?</span></span><br><span class="line">            end = mid;      <span class="comment">// if so, adjust the range to ignore the secondhalf</span></span><br><span class="line">        <span class="keyword">else</span>                <span class="comment">// the element we want is in the second half</span></span><br><span class="line">            beg = mid + <span class="number">1</span>;  <span class="comment">// start looking with the element just after mid</span></span><br><span class="line">        mid = beg + (end - beg)/<span class="number">2</span>; <span class="comment">// new midpoint</span></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="exercise-327"><a class="markdownIt-Anchor" href="#exercise-327"></a> Exercise 3.27</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//假设txt_size 是一个无参函数，它的返回值是int。请回答下列哪个定义是非法的，为什么？</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">unsigned</span> buf_size = <span class="number">1024</span>;</span><br><span class="line"><span class="comment">//    int ia[buf_size];</span></span><br><span class="line"><span class="comment">//    int ia[4 * 7 - 14];</span></span><br><span class="line"><span class="comment">//    int ia[txt_size()];</span></span><br><span class="line"><span class="comment">//    char st[11] = "fundamental";</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    (a) 非法。纬度必须是一个常量表达式。</span></span><br><span class="line"><span class="comment">    (b) 合法。</span></span><br><span class="line"><span class="comment">    (c) 非法。txt_size() 的值必须要到运行时才能得到。</span></span><br><span class="line"><span class="comment">    (d) 非法。数组的大小应该是12。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><h2 id="exercise-328"><a class="markdownIt-Anchor" href="#exercise-328"></a> Exercise 3.28</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//下列数组中元素的值是什么？</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    string sa[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> ia[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">string sa2[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> ia2[<span class="number">10</span>];</span><br><span class="line">}</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   数组的元素会被默认初始化。</span></span><br><span class="line"><span class="comment">*   sa 的元素值全部为空字符串，ia 的元素值全部为0。</span></span><br><span class="line"><span class="comment">    sa2 的元素值全部为空字符串，ia2 的元素值全部未定义。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><h2 id="exercise-329"><a class="markdownIt-Anchor" href="#exercise-329"></a> Exercise 3.29</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    相比于vector 来说，数组有哪些缺点，请例举一些。</span></span><br><span class="line"><span class="comment">    数组的大小是确定的。</span></span><br><span class="line"><span class="comment">    不能随意增加元素</span></span><br><span class="line"><span class="comment">    不允许拷贝和赋值</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><h2 id="exercise-330"><a class="markdownIt-Anchor" href="#exercise-330"></a> Exercise 3.30</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">size_t</span> array_size = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> ia[array_size];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> ix = <span class="number">1</span>; ix &lt;= array_size; ++ix)</span><br><span class="line">    ia[ix] = ix;    <span class="comment">//当 ix 增长到 10 的时候，ia[ix] 的下标越界。</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="exercise-331"><a class="markdownIt-Anchor" href="#exercise-331"></a> Exercise 3.31</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    编写一段程序，定义一个含有10个int的数组，令</span></span><br><span class="line"><span class="comment">    每个元素的值就是其下标值。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">size_t</span> array_size = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> array[array_size] = {};</span><br><span class="line">    <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:array){</span><br><span class="line">        i = num++;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="exercise-332"><a class="markdownIt-Anchor" href="#exercise-332"></a> Exercise 3.32</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    编写一段程序，定义一个含有10个int的数组，令</span></span><br><span class="line"><span class="comment">    每个元素的值就是其下标值。</span></span><br><span class="line"><span class="comment">    vector realization</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout; <span class="keyword">using</span> std::endl; <span class="keyword">using</span> std::vector;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="comment">// array</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) arr[i] = i;</span><br><span class="line"><span class="type">int</span> arr2[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) arr2[i] = arr[i];</span><br><span class="line"></span><br><span class="line"><span class="comment">// vector</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i) v[i] = arr[i];</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v2</span><span class="params">(v)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : v2) cout &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="exercise-333"><a class="markdownIt-Anchor" href="#exercise-333"></a> Exercise 3.33</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 数组中所有元素的值将会未定义。</span></span><br></pre></td></tr></tbody></table></figure><h2 id="exercise-334"><a class="markdownIt-Anchor" href="#exercise-334"></a> Exercise 3.34</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//将 p1 移动到 p2 的位置。任何情况下都合法。</span></span><br></pre></td></tr></tbody></table></figure><h2 id="exercise-335"><a class="markdownIt-Anchor" href="#exercise-335"></a> Exercise 3.35</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">size_t</span> array_size = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> array[array_size] = {<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>};</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> *p = array;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;i:array){</span><br><span class="line">        i = *p;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="exercise-336"><a class="markdownIt-Anchor" href="#exercise-336"></a> Exercise 3.36</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(<span class="type">int</span>* <span class="type">const</span> pb1, <span class="type">int</span>* <span class="type">const</span> pe1, <span class="type">int</span>* <span class="type">const</span> pb2, <span class="type">int</span>* <span class="type">const</span> pe2)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">if</span> ((pe1 - pb1) != (pe2 - pb2)) </span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span>* i = pb1, *j = pb2; (i != pe1) &amp;&amp; (j != pe2); ++i, ++j)</span><br><span class="line"><span class="keyword">if</span> (*i != *j) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="type">int</span> arr1[<span class="number">3</span>] = { <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span> };</span><br><span class="line"><span class="type">int</span> arr2[<span class="number">3</span>] = { <span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span> };</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">compare</span>(<span class="built_in">begin</span>(arr1), <span class="built_in">end</span>(arr1), <span class="built_in">begin</span>(arr2), <span class="built_in">end</span>(arr2)))</span><br><span class="line">cout &lt;&lt; <span class="string">"The two arrays are equal."</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout &lt;&lt; <span class="string">"The two arrays are not equal."</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">"=========="</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec1 = { <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span> };</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec2 = { <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span> };</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (vec1 == vec2)</span><br><span class="line">cout &lt;&lt; <span class="string">"The two vectors are equal."</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout &lt;&lt; <span class="string">"The two vectors are not equal."</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="exercise-337"><a class="markdownIt-Anchor" href="#exercise-337"></a> Exercise 3.37</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 下面的程序是何含义，程序的输出结果是什么？</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> ca[] = { <span class="string">'h'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span> };</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *cp = ca;</span><br><span class="line">    <span class="keyword">while</span> (*cp) {</span><br><span class="line">        cout &lt;&lt; *cp &lt;&lt; endl;</span><br><span class="line">        ++cp;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//会将ca 字符数组中的元素打印出来。但是因为没有空字符的存在，程序不会退出循环。</span></span><br></pre></td></tr></tbody></table></figure><h2 id="exercise-338"><a class="markdownIt-Anchor" href="#exercise-338"></a> Exercise 3.38</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在本节中我们提到，将两个指针相加不但是非法的，</span></span><br><span class="line"><span class="comment">而且也没有什么意义。请问为什么两个指针相加没有意义？</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">将两个指针相减可以表示两个指针(在同一数组中)相距的距离，</span></span><br><span class="line"><span class="comment">将指针加上一个整数也可以表示移动这个指针到某一位置。</span></span><br><span class="line"><span class="comment">但是两个指针相加并没有逻辑上的意义，因此两个指针不能相加。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></tbody></table></figure><h2 id="exercise-339"><a class="markdownIt-Anchor" href="#exercise-339"></a> Exercise 3.39</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">string <span class="title">string1</span><span class="params">(<span class="string">"this is a string"</span>)</span></span>;</span><br><span class="line">    <span class="function">string <span class="title">string2</span><span class="params">(<span class="string">"this is a string"</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(string1==string2)</span><br><span class="line">        cout &lt;&lt; <span class="string">"two string is equal"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">"two string is not equal"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> str1[] = {<span class="string">'C'</span>, <span class="string">'+'</span>, <span class="string">'+'</span>};</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> str2[] = {<span class="string">'J'</span>, <span class="string">'a'</span>, <span class="string">'v'</span>,<span class="string">'a'</span>};</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(str1,str2)==<span class="number">0</span>) </span><br><span class="line">        cout &lt;&lt; <span class="string">"two string is equal"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">"two string is not equal"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="exercise-340"><a class="markdownIt-Anchor" href="#exercise-340"></a> Exercise 3.40</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> cstr1[] = <span class="string">"Hello"</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> cstr2[] = <span class="string">"world!"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> new_size = <span class="built_in">strlen</span>(cstr1) + <span class="built_in">strlen</span>(<span class="string">" "</span>) + <span class="built_in">strlen</span>(cstr2) + <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span>* cstr3 = <span class="keyword">new</span> <span class="type">char</span>[new_size];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(cstr3, cstr1);</span><br><span class="line">    <span class="built_in">strcat</span>(cstr3, <span class="string">" "</span>);</span><br><span class="line">    <span class="built_in">strcat</span>(cstr3, cstr2);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; cstr3 &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">delete</span> [] cstr3;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="exercise-341"><a class="markdownIt-Anchor" href="#exercise-341"></a> Exercise 3.41</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    编写一段程序，用整型数组初始化一个vector对象。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> array[] = {<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>};</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">number</span><span class="params">(begin(array),end(array))</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"the contents of number are: "</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:number){</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="exercise-342"><a class="markdownIt-Anchor" href="#exercise-342"></a> Exercise 3.42</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    编写一段程序，将含有整数元素的vector对象拷贝给一个整型数组。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> array[] = {<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>};</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">num</span><span class="params">(<span class="number">10</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i!=num.<span class="built_in">size</span>();i++){</span><br><span class="line">        *(array + i) = num[i];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : array){</span><br><span class="line">         cout &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="exercise-343"><a class="markdownIt-Anchor" href="#exercise-343"></a> Exercise 3.43</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">    编写3个不同版本的程序，令其均能输出ia的元素。</span></span><br><span class="line"><span class="comment">    版本1使用范围for语句管理迭代过程；</span></span><br><span class="line"><span class="comment">    版本2和版本3都使用普通for语句，其中版本2要求使用下标运算符，</span></span><br><span class="line"><span class="comment">    版本3要求使用指针。此外，在所有3个版本的程序中都要直接写出数据类型，</span></span><br><span class="line"><span class="comment">    而不能使用类型别名、auto关键字和decltype关键字。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout; <span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">3</span>][<span class="number">4</span>] = </span><br><span class="line">    { </span><br><span class="line">        { <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> },</span><br><span class="line">        { <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span> },</span><br><span class="line">        { <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span> }</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="comment">// range for</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="built_in">int</span>(&amp;row)[<span class="number">4</span>] : arr)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> col : row) cout &lt;&lt; col &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for loop</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i != <span class="number">3</span>; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j != <span class="number">4</span>; ++j) cout &lt;&lt; arr[i][j] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// using pointers.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span>(*row)[<span class="number">4</span>] = arr; row != arr + <span class="number">3</span>; ++row)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> *col = *row; col != *row + <span class="number">4</span>; ++col) cout &lt;&lt; *col &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="exercise-344"><a class="markdownIt-Anchor" href="#exercise-344"></a> Exercise 3.44</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//改写上一个练习中的程序，使用类型别名来代替循环控制变量的类型。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout; <span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = { <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span> };</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a range for to manage the iteration</span></span><br><span class="line">    <span class="comment">// use type alias</span></span><br><span class="line">    <span class="keyword">using</span> int_array = <span class="type">int</span>[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">for</span> (int_array&amp; p : ia)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> q : p)</span><br><span class="line">            cout &lt;&lt; q &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ordinary for loop using subscripts</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i != <span class="number">3</span>; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j != <span class="number">4</span>; ++j)</span><br><span class="line">            cout &lt;&lt; ia[i][j] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// using pointers.</span></span><br><span class="line">    <span class="comment">// use type alias</span></span><br><span class="line">    <span class="keyword">for</span> (int_array* p = ia; p != ia + <span class="number">3</span>; ++p)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> *q = *p; q != *p + <span class="number">4</span>; ++q)</span><br><span class="line">            cout &lt;&lt; *q &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="exercise-345"><a class="markdownIt-Anchor" href="#exercise-345"></a> Exercise 3.45</h2><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//再一次改写程序，这次使用auto关键字。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout; <span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = { <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span> };</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a range for to manage the iteration</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p : ia)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> q : p)</span><br><span class="line">            cout &lt;&lt; q &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ordinary for loop using subscripts</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i != <span class="number">3</span>; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j != <span class="number">4</span>; ++j)</span><br><span class="line">            cout &lt;&lt; ia[i][j] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// using pointers.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> p = ia; p != ia + <span class="number">3</span>; ++p)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> *q = *p; q != *p + <span class="number">4</span>; ++q)</span><br><span class="line">            cout &lt;&lt; *q &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chapter03 字符串、向量和数组</title>
      <link href="/posts/1d50.html"/>
      <url>/posts/1d50.html</url>
      
        <content type="html"><![CDATA[<h2 id="命名空间的using声明namespace-using-declarations"><a class="markdownIt-Anchor" href="#命名空间的using声明namespace-using-declarations"></a> 命名空间的using声明（Namespace using Declarations）</h2><p>使用<code>using</code>声明后就无须再通过专门的前缀去获取所需的名字了。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> std::cout;</span><br></pre></td></tr></tbody></table></figure><p>程序中使用的每个名字都需要用独立的<code>using</code>声明引入。</p><p>头文件中通常不应该包含<code>using</code>声明。</p><h2 id="标准库类型stringlibrary-string-type"><a class="markdownIt-Anchor" href="#标准库类型stringlibrary-string-type"></a> 标准库类型string（Library string Type）</h2><p>标准库类型<code>string</code>表示可变长的字符序列，定义在头文件<em>string</em>中。</p><h3 id="定义和初始化string对象defining-and-initializing-strings"><a class="markdownIt-Anchor" href="#定义和初始化string对象defining-and-initializing-strings"></a> 定义和初始化string对象（Defining and Initializing strings）</h3><p>初始化<code>string</code>的方式：</p><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200804211406.png" alt="3-1"></p><p>如果使用等号初始化一个变量，实际上执行的是拷贝初始化（copy initialization），编译器把等号右侧的初始值拷贝到新创建的对象中去。如果不使用等号，则执行的是直接初始化（direct initialization）。</p><p>如果初始化要用到的值有多个，那么一般来说只能使用直接初始化，如果非要用拷贝初始化的话，就需要显示的创建一个（临时对象）用于拷贝：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">string s5 = <span class="string">"hiya"</span>;     <span class="comment">//拷贝初始化</span></span><br><span class="line">string s6 = <span class="string">"hiya"</span>;     <span class="comment">//直接初始化</span></span><br><span class="line"><span class="function">string <span class="title">s7</span><span class="params">(<span class="number">10</span>, <span class="string">'c'</span>)</span></span>;      <span class="comment">//直接初始化</span></span><br><span class="line"></span><br><span class="line">string s8 = <span class="built_in">string</span>(<span class="number">10</span>,<span class="string">'c'</span>);  <span class="comment">//拷贝初始化 1</span></span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">temp</span><span class="params">(<span class="number">10</span>,<span class="string">'c'</span>)</span></span>;        <span class="comment">//拷贝初始化  2</span></span><br><span class="line">string s8 = temp;</span><br></pre></td></tr></tbody></table></figure><h3 id="string对象上的操作operations-on-strings"><a class="markdownIt-Anchor" href="#string对象上的操作operations-on-strings"></a> string对象上的操作（Operations on strings）</h3><p><code>string</code>的操作：</p><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200804212827.png" alt="3-2"></p><p>在执行读取操作时，<code>string</code>对象会自动忽略开头的空白（空格符、换行符、制表符等）并从第一个真正的字符开始读取，直到遇见下一处空白为止。</p><p>使用<code>getline</code>函数可以读取一整行字符。该函数只要遇到换行符就结束读取并返回结果，如果输入的开始就是一个换行符，则得到空<code>string</code>。触发<code>getline</code>函数返回的那个换行符实际上被丢弃掉了，得到的<code>string</code>对象中并不包含该换行符。</p><p><code>size</code>函数返回<code>string</code>对象的长度，返回值是<code>string::size_type</code>类型，这是一种无符号类型。要使用<code>size_type</code>，必须先指定它是由哪种类型定义的。</p><p>如果一个表达式中已经有了<code>size</code>函数就不要再使用<code>int</code>了，这样可以避免混用<code>int</code>和<code>unsigned int</code>可能带来的问题。</p><p>当把<code>string</code>对象和字符字面值及字符串字面值混合在一条语句中使用时，必须确保每个加法运算符两侧的运算对象中至少有一个是<code>string</code>。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">string s4 = s1 + <span class="string">", "</span>;          <span class="comment">// ok: adding a string and a literal</span></span><br><span class="line">string s5 = <span class="string">"hello"</span> + <span class="string">", "</span>;     <span class="comment">// error: no string operand</span></span><br><span class="line">string s6 = s1 + <span class="string">", "</span> + <span class="string">"world"</span>;    <span class="comment">// ok: each + has a string operand</span></span><br></pre></td></tr></tbody></table></figure><p>为了与C兼容，C++语言中的字符串字面值并不是标准库<code>string</code>的对象。</p><h3 id="处理string对象中的字符dealing-with-the-characters-in-a-string"><a class="markdownIt-Anchor" href="#处理string对象中的字符dealing-with-the-characters-in-a-string"></a> 处理string对象中的字符（Dealing with the Characters in a string）</h3><p>头文件<em>cctype</em>中的字符操作函数：</p><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200805111754.png" alt="3-3"></p><p>建议使用C<ins>版本的C标准库头文件。C语言中名称为<em>name.h</em>的头文件，在C</ins>中则被命名为<em>cname</em>。</p><p>C++11提供了范围<code>for</code>（range for）语句，可以遍历给定序列中的每个元素并执行某种操作。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (declaration : expression)</span><br><span class="line">    statement</span><br></pre></td></tr></tbody></table></figure><p><em>expression</em>部分是一个对象，用于表示一个序列。<em>declaration</em>部分负责定义一个变量，该变量被用于访问序列中的基础元素。每次迭代，<em>declaration</em>部分的变量都会被初始化为<em>expression</em>部分的下一个元素值。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">str</span><span class="params">(<span class="string">"some string"</span>)</span></span>;</span><br><span class="line"><span class="comment">// print the characters in str one character to a line</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> c : str)      <span class="comment">// for every char in str</span></span><br><span class="line">    cout &lt;&lt; c &lt;&lt; endl;  <span class="comment">// print the current character followed by a newline</span></span><br></pre></td></tr></tbody></table></figure><p>如果想在范围<code>for</code>语句中改变<code>string</code>对象中字符的值，必须把循环变量定义成引用类型。</p><p>下标运算符接收的输入参数是<code>string::size_type</code>类型的值，表示要访问字符的位置，返回值是该位置上字符的引用。</p><p>下标数值从0记起，范围是0至<em>size - 1</em>。使用超出范围的下标将引发不可预知的后果。</p><p>C++标准并不要求标准库检测下标是否合法。编程时可以把下标的类型定义为相应的<code>size_type</code>，这是一种无符号数，可以确保下标不会小于0，此时代码只需要保证下标小于<code>size</code>的值就可以了。另一种确保下标合法的有效手段就是使用范围<code>for</code>语句。</p><h2 id="标准库类型vectorlibrary-vector-type"><a class="markdownIt-Anchor" href="#标准库类型vectorlibrary-vector-type"></a> 标准库类型vector（Library vector Type）</h2><p>标准库类型<code>vector</code>表示对象的集合，也叫做容器（container），定义在头文件<em>vector</em>中。<code>vector</code>中所有对象的类型都相同，每个对象都有一个索引与之对应并用于访问该对象。</p><p><code>vector</code>是模板（template）而非类型，由<code>vector</code>生成的类型必须包含<code>vector</code>中元素的类型，如<code>vector&lt;int&gt;</code>。</p><p><font color="red">因为引用不是对象，所以不存在包含引用的<code>vector</code>。</font></p><p>在早期的C<ins>标准中，如果<code>vector</code>的元素还是<code>vector</code>，定义时必须在外层<code>vector</code>对象的右尖括号和其元素类型之间添加一个空格，如<code>vector&lt;vector&lt;int&gt; &gt;</code>。但是在C</ins>11标准中，可以直接写成<code>vector&lt;vector&lt;int&gt;&gt;</code>，不需要添加空格。</p><h3 id="定义和初始化vector对象defining-and-initializing-vectors"><a class="markdownIt-Anchor" href="#定义和初始化vector对象defining-and-initializing-vectors"></a> 定义和初始化vector对象（Defining and Initializing vectors）</h3><p>初始化<code>vector</code>对象的方法：</p><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200805152813.png" alt="3-4"></p><p>初始化<code>vector</code>对象时如果使用圆括号，可以说提供的值是用来构造（construct）<code>vector</code>对象的；如果使用的是花括号，则是在列表初始化（list initialize）该<code>vector</code>对象。</p><p>可以只提供<code>vector</code>对象容纳的元素数量而省略初始值，此时会创建一个值初始化（value-initialized）的元素初值，并把它赋给容器中的所有元素。这个初值由<code>vector</code>对象中的元素类型决定。</p><h3 id="向vector对象中添加元素adding-elements-to-a-vector"><a class="markdownIt-Anchor" href="#向vector对象中添加元素adding-elements-to-a-vector"></a> 向vector对象中添加元素（Adding Elements to a vector）</h3><p><code>push_back</code>函数可以把一个值添加到<code>vector</code>的尾端。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v2;         <span class="comment">// empty vector</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != <span class="number">100</span>; ++i)</span><br><span class="line">    v2.<span class="built_in">push_back</span>(i);    <span class="comment">// append sequential integers to v2</span></span><br><span class="line"><span class="comment">// at end of loop v2 has 100 elements, values 0 . . . 99</span></span><br></pre></td></tr></tbody></table></figure><p>范围<code>for</code>语句体内不应该改变其所遍历序列的大小。</p><h3 id="其他vector操作other-vector-operations"><a class="markdownIt-Anchor" href="#其他vector操作other-vector-operations"></a> 其他vector操作（Other vector Operations）</h3><p><code>vector</code>支持的操作：</p><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200805162732.png" alt="3-5"></p><p><code>size</code>函数返回<code>vector</code>对象中元素的个数，返回值是由<code>vector</code>定义的<code>size_type</code>类型。<code>vector</code>对象的类型包含其中元素的类型。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::size_type  <span class="comment">// ok</span></span><br><span class="line">vector::size_type       <span class="comment">// error</span></span><br></pre></td></tr></tbody></table></figure><p><code>vector</code>和<code>string</code>对象的下标运算符只能用来访问已经存在的元素，而不能用来添加元素。<br>确保下标合法的一种有效手段是尽可能使用范围 for语句。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; ivec;   <span class="comment">// empty vector</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">decltype</span>(ivec.<span class="built_in">size</span>()) ix = <span class="number">0</span>; ix != <span class="number">10</span>; ++ix)</span><br><span class="line">{</span><br><span class="line">    ivec[ix] = ix;  <span class="comment">// disaster: ivec has no elements</span></span><br><span class="line">    ivec.<span class="built_in">push_back</span>(ix); <span class="comment">// ok: adds a new element with value ix</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="迭代器介绍introducing-iterators"><a class="markdownIt-Anchor" href="#迭代器介绍introducing-iterators"></a> 迭代器介绍（Introducing Iterators）</h2><p>迭代器的作用和下标类似，但是更加通用。所有标准库容器都可以使用迭代器，但是其中只有少数几种同时支持下标运算符。</p><h3 id="使用迭代器using-iterators"><a class="markdownIt-Anchor" href="#使用迭代器using-iterators"></a> 使用迭代器（Using Iterators）</h3><p>vector 支持下标运算，string支持迭代器</p><p>定义了迭代器的类型都拥有<code>begin</code>和<code>end</code>两个成员函数。<code>begin</code>函数返回指向第一个元素的迭代器，<code>end</code>函数返回指向容器“尾元素的下一位置（one past the end）”的迭代器，通常被称作尾后迭代器（off-the-end iterator）或者简称为尾迭代器（end iterator）。尾后迭代器仅是个标记，表示程序已经处理完了容器中的所有元素。迭代器一般为<code>iterator</code>类型。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// b denotes the first element and e denotes one past the last element in ivec</span></span><br><span class="line"><span class="keyword">auto</span> b = ivec.<span class="built_in">begin</span>(), e = ivec.<span class="built_in">end</span>();    <span class="comment">// b and e have the same type</span></span><br></pre></td></tr></tbody></table></figure><p>如果容器为空，则<code>begin</code>和<code>end</code>返回的是同一个迭代器，都是尾后迭代器。</p><p>标准容器迭代器的运算符：</p><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200805212839.png" alt="3-6"></p><p>因为<code>end</code>返回的迭代器并不实际指向某个元素，所以不能对其进行递增或者解引用的操作。</p><p>在<code>for</code>或者其他循环语句的判断条件中，最好使用<code>!=</code>而不是<code>&lt;</code>。所有标准库容器的迭代器都定义了<code>==</code>和<code>!=</code>，但是只有其中少数同时定义了<code>&lt;</code>运算符。</p><p>如果<code>vector</code>或<code>string</code>对象是常量，则只能使用<code>const_iterator</code>迭代器，该迭代器只能读元素，不能写元素。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it; <span class="comment">// it can read and write vector&lt;int&gt; elements</span></span><br><span class="line">string::iterator it2; <span class="comment">// it2 can read and write characters in a string</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::const_iterator it3; <span class="comment">// it3 can read but not write elements</span></span><br><span class="line">string::const_iterator it4; <span class="comment">// it4 can read but not write</span></span><br></pre></td></tr></tbody></table></figure><p><code>begin</code>和<code>end</code>返回的迭代器具体类型由对象是否是常量决定，如果对象是常量，则返回<code>const_iterator</code>；如果对象不是常量，则返回<code>iterator</code>。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="type">const</span> vector&lt;<span class="type">int</span>&gt; cv;</span><br><span class="line"><span class="keyword">auto</span> it1 = v.<span class="built_in">begin</span>();   <span class="comment">// it1 has type vector&lt;int&gt;::iterator</span></span><br><span class="line"><span class="keyword">auto</span> it2 = cv.<span class="built_in">begin</span>();  <span class="comment">// it2 has type vector&lt;int&gt;::const_iterator</span></span><br></pre></td></tr></tbody></table></figure><p>C++11新增了<code>cbegin</code>和<code>cend</code>函数，不论<code>vector</code>或<code>string</code>对象是否为常量，都返回<code>const_iterator</code>迭代器。</p><p>任何可能改变容器对象容量的操作，都会使该对象的迭代器失效。<br>失效的两个原因：<br>1.在范围for循环中向vector对象添加元素<br>2.使用一种可以改变vector对象容量的操作，比如 push_back</p><h3 id="迭代器运算iterator-arithmetic"><a class="markdownIt-Anchor" href="#迭代器运算iterator-arithmetic"></a> 迭代器运算（Iterator Arithmetic）</h3><p><code>vector</code>和<code>string</code>迭代器支持的操作：</p><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200806194430.png" alt="3-7"></p><p><code>difference_type</code>类型用来表示两个迭代器间的距离，这是一种带符号整数类型。</p><p>迭代器运算例子：二分搜索</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// text must be sorted</span></span><br><span class="line"><span class="comment">// beg and end will denote the range we're searching</span></span><br><span class="line"><span class="keyword">auto</span> beg = text.<span class="built_in">begin</span>(), end = text.<span class="built_in">end</span>();</span><br><span class="line"><span class="keyword">auto</span> mid = text.<span class="built_in">begin</span>() + (end - beg)/<span class="number">2</span>;    <span class="comment">// original midpoint</span></span><br><span class="line"><span class="comment">// while there are still elements to look at and we haven't yet found sought</span></span><br><span class="line"><span class="keyword">while</span> (mid != end &amp;&amp; *mid != sought) {</span><br><span class="line">    <span class="keyword">if</span> (sought &lt; *mid) <span class="comment">// is the element we want in the first half?</span></span><br><span class="line">        end = mid;     <span class="comment">// if so, adjust the range to ignore the second half</span></span><br><span class="line">    <span class="keyword">else</span>               <span class="comment">// the element we want is in the second half</span></span><br><span class="line">        beg = mid + <span class="number">1</span>; <span class="comment">// start looking with the element just after mid</span></span><br><span class="line">    mid = beg + (end - beg)/<span class="number">2</span>; <span class="comment">// new midpoint</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="数组arrays"><a class="markdownIt-Anchor" href="#数组arrays"></a> 数组（Arrays）</h2><p>数组类似<code>vector</code>，但数组的大小确定不变，不能随意向数组中添加元素。</p><p>如果不清楚元素的确切个数，应该使用<code>vector</code>。</p><h3 id="定义和初始化内置数组defining-and-initializing-built-in-arrays"><a class="markdownIt-Anchor" href="#定义和初始化内置数组defining-and-initializing-built-in-arrays"></a> 定义和初始化内置数组（Defining and Initializing Built-in Arrays）</h3><p>数组是一种复合类型，声明形式为<code>a[d]</code>，其中<em>a</em>是数组名称，<em>d</em>是数组维度（dimension）。维度必须是一个常量表达式。</p><p>默认情况下，数组的元素被默认初始化。</p><p>定义数组的时候必须指定数组的类型，不允许用<code>auto</code>关键字由初始值列表推断类型。</p><p>如果定义数组时提供了元素的初始化列表，则允许省略数组维度，编译器会根据初始值的数量计算维度。但如果显式指明了维度，那么初始值的数量不能超过指定的大小。如果维度比初始值的数量大，则用提供的值初始化数组中靠前的元素，剩下的元素被默认初始化。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">unsigned</span> sz = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> ia1[sz] = {<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>};  <span class="comment">// array of three ints with values 0, 1, 2</span></span><br><span class="line"><span class="type">int</span> a2[] = {<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>};   <span class="comment">// an array of dimension 3</span></span><br><span class="line"><span class="type">int</span> a3[<span class="number">5</span>] = {<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>};  <span class="comment">// equivalent to a3[] = {0, 1, 2, 0, 0}</span></span><br><span class="line">string a4[<span class="number">3</span>] = {<span class="string">"hi"</span>, <span class="string">"bye"</span>};   <span class="comment">// same as a4[] = {"hi", "bye", ""}</span></span><br><span class="line"><span class="type">int</span> a5[<span class="number">2</span>] = {<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>};    <span class="comment">// error: too many initializers</span></span><br></pre></td></tr></tbody></table></figure><p>可以用字符串字面值初始化字符数组，但字符串字面值结尾处的空字符也会一起被拷贝到字符数组中。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">char</span> a1[] = {<span class="string">'C'</span>, <span class="string">'+'</span>, <span class="string">'+'</span>};        <span class="comment">// list initialization, no null</span></span><br><span class="line"><span class="type">char</span> a2[] = {<span class="string">'C'</span>, <span class="string">'+'</span>, <span class="string">'+'</span>, <span class="string">'\0'</span>};  <span class="comment">// list initialization, explicit null</span></span><br><span class="line"><span class="type">char</span> a3[] = <span class="string">"C++"</span>;      <span class="comment">// null terminator added automatically</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> a4[<span class="number">6</span>] = <span class="string">"Daniel"</span>;    <span class="comment">// error: no space for the null!</span></span><br></pre></td></tr></tbody></table></figure><p>不能用一个数组初始化或直接赋值给另一个数组。</p><p>从数组的名字开始由内向外阅读有助于理解复杂数组声明的含义。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> *ptrs[<span class="number">10</span>];              <span class="comment">// ptrs is an array of ten pointers to int</span></span><br><span class="line"><span class="type">int</span> &amp;refs[<span class="number">10</span>] = <span class="comment">/* ? */</span>;    <span class="comment">// error: no arrays of references</span></span><br><span class="line"><span class="built_in">int</span> (*Parray)[<span class="number">10</span>] = &amp;arr;   <span class="comment">// Parray points to an array of ten ints</span></span><br><span class="line"><span class="built_in">int</span> (&amp;arrRef)[<span class="number">10</span>] = arr;    <span class="comment">// arrRef refers to an array of ten ints</span></span><br></pre></td></tr></tbody></table></figure><h3 id="访问数组元素accessing-the-elements-of-an-array"><a class="markdownIt-Anchor" href="#访问数组元素accessing-the-elements-of-an-array"></a> 访问数组元素（Accessing the Elements of an Array）</h3><p>数组下标通常被定义成<code>size_t</code>类型，这是一种机器相关的无符号类型，可以表示内存中任意对象的大小。<code>size_t</code>定义在头文件<em>cstddef</em>中。</p><p>大多数常见的安全问题都源于缓冲区溢出错误。当数组或其他类似数据结构的下标越界并试图访问非法内存区域时，就会产生此类错误。</p><h3 id="指针和数组pointers-and-arrays"><a class="markdownIt-Anchor" href="#指针和数组pointers-and-arrays"></a> 指针和数组（Pointers and Arrays）</h3><p>在大多数表达式中，使用数组类型的对象其实是在使用一个指向该数组首元素的指针。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">string nums[] = {<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>};    <span class="comment">// array of strings</span></span><br><span class="line">string *p = &amp;nums[<span class="number">0</span>];   <span class="comment">// p points to the first element in nums</span></span><br><span class="line">string *p2 = nums;      <span class="comment">// equivalent to p2 = &amp;nums[0]</span></span><br></pre></td></tr></tbody></table></figure><p>指针做迭代器：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> *e = &amp;arr[<span class="number">10</span>]; <span class="comment">// pointer just past the last element in arr</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> *b = arr; b != e; ++b)</span><br><span class="line">cout &lt;&lt; *b &lt;&lt; endl; <span class="comment">// print the elements in arr</span></span><br></pre></td></tr></tbody></table></figure><p>一维数组寻址公式：</p><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200806220854.png" alt="3-8"></p><p>当使用数组作为一个<code>auto</code>变量的初始值时，推断得到的类型是指针而非数组。但<code>decltype</code>关键字不会发生这种转换，直接返回数组类型。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> ia[] = {<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>};   <span class="comment">// ia is an array of ten ints</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ia2</span><span class="params">(ia)</span></span>;   <span class="comment">// ia2 is an int* that points to the first element in ia</span></span><br><span class="line">ia2 = <span class="number">42</span>;       <span class="comment">// error: ia2 is a pointer, and we can't assign an int to a pointer</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ia2</span><span class="params">(&amp;ia[<span class="number">0</span>])</span></span>;   <span class="comment">// now it's clear that ia2 has type int*</span></span><br><span class="line"><span class="comment">// ia3 is an array of ten ints</span></span><br><span class="line"><span class="keyword">decltype</span>(ia) ia3 = {<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>};</span><br><span class="line">ia3 = p;    <span class="comment">// error: can't assign an int* to an array</span></span><br><span class="line">ia3[<span class="number">4</span>] = i;     <span class="comment">// ok: assigns the value of i to an element in ia3</span></span><br></pre></td></tr></tbody></table></figure><p>C++11在头文件<em>iterator</em>中定义了两个名为<code>begin</code>和<code>end</code>的函数，功能与容器中的两个同名成员函数类似，参数是一个数组。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> ia[] = {<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>};   <span class="comment">// ia is an array of ten ints</span></span><br><span class="line"><span class="type">int</span> *beg = <span class="built_in">begin</span>(ia);   <span class="comment">// pointer to the first element in ia</span></span><br><span class="line"><span class="type">int</span> *last = <span class="built_in">end</span>(ia);    <span class="comment">// pointer one past the last element in ia</span></span><br></pre></td></tr></tbody></table></figure><p>两个指针相减的结果类型是<code>ptrdiff_t</code>，这是一种定义在头文件<em>cstddef</em>中的带符号类型。</p><p>标准库类型限定使用的下标必须是无符号类型，而内置的下标运算无此要求。</p><h3 id="c风格字符串c-style-character-strings"><a class="markdownIt-Anchor" href="#c风格字符串c-style-character-strings"></a> C风格字符串（C-Style Character Strings）</h3><p>C风格字符串是将字符串存放在字符数组中，并以空字符结束（null terminated）。这不是一种类型，而是一种为了表达和使用字符串而形成的书写方法。</p><p>C<ins>标准支持C风格字符串，但是最好不要在C</ins>程序中使用它们。对大多数程序来说，使用标准库<code>string</code>要比使用C风格字符串更加安全和高效。</p><p>C风格字符串的函数：</p><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200806220526.png" alt="3-9"></p><p>C风格字符串函数不负责验证其参数的正确性，传入此类函数的指针必须指向以空字符作为结尾的数组。</p><h3 id="与旧代码的接口interfacing-to-older-code"><a class="markdownIt-Anchor" href="#与旧代码的接口interfacing-to-older-code"></a> 与旧代码的接口（Interfacing to Older Code）</h3><p>任何出现字符串字面值的地方都可以用以空字符结束的字符数组来代替：</p><ul><li>允许使用以空字符结束的字符数组来初始化<code>string</code>对象或为<code>string</code>对象赋值。</li><li>在<code>string</code>对象的加法运算中，允许使用以空字符结束的字符数组作为其中一个运算对象（不能两个运算对象都是）。</li><li>在<code>string</code>对象的复合赋值运算中，允许使用以空字符结束的字符数组作为右侧运算对象。</li></ul><p>不能用<code>string</code>对象直接初始化指向字符的指针。为了实现该功能，<code>string</code>提供了一个名为<code>c_str</code>的成员函数，返回<code>const char*</code>类型的指针，指向一个以空字符结束的字符数组，数组的数据和<code>string</code>对象一样。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">"Hello World"</span>)</span></span>;    <span class="comment">// s holds Hello World</span></span><br><span class="line"><span class="type">char</span> *str = s;  <span class="comment">// error: can't initialize a char* from a string</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *str = s.<span class="built_in">c_str</span>();    <span class="comment">// ok</span></span><br></pre></td></tr></tbody></table></figure><p>针对<code>string</code>对象的后续操作有可能会让<code>c_str</code>函数之前返回的数组失去作用，如果程序想一直都能使用其返回的数组，最好将该数组重新拷贝一份。</p><p>可以使用数组来初始化<code>vector</code>对象，但是需要指明要拷贝区域的首元素地址和尾后地址。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> int_arr[] = {<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>};</span><br><span class="line"><span class="comment">// ivec has six elements; each is a copy of the corresponding element in int_arr</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ivec</span><span class="params">(begin(int_arr), end(int_arr))</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>在新版本的C++程序中应该尽量使用<code>vector</code>、<code>string</code>和迭代器，避免使用内置数组、C风格字符串和指针。</p><h2 id="多维数组multidimensional-arrays"><a class="markdownIt-Anchor" href="#多维数组multidimensional-arrays"></a> 多维数组（Multidimensional Arrays）</h2><p>C++中的多维数组其实就是数组的数组。当一个数组的元素仍然是数组时，通常需要用两个维度定义它：一个维度表示数组本身的大小，另一个维度表示其元素（也是数组）的大小。通常把二维数组的第一个维度称作行，第二个维度称作列。</p><p>多维数组初始化的几种方式：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] =</span><br><span class="line">{   <span class="comment">// three elements; each element is an array of size 4</span></span><br><span class="line">    {<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>},   <span class="comment">// initializers for the row indexed by 0</span></span><br><span class="line">    {<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>},   <span class="comment">// initializers for the row indexed by 1</span></span><br><span class="line">    {<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>}  <span class="comment">// initializers for the row indexed by 2</span></span><br><span class="line">};</span><br><span class="line"><span class="comment">// equivalent initialization without the optional nested braces for each row</span></span><br><span class="line"><span class="type">int</span> ib[<span class="number">3</span>][<span class="number">4</span>] = {<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>};</span><br><span class="line"><span class="comment">// explicitly initialize only element 0 in each row</span></span><br><span class="line"><span class="type">int</span> ic[<span class="number">3</span>][<span class="number">4</span>] = {{ <span class="number">0</span> }, { <span class="number">4</span> }, { <span class="number">8</span> }};</span><br><span class="line"><span class="comment">// explicitly initialize row 0; the remaining elements are value initialized</span></span><br><span class="line"><span class="type">int</span> id[<span class="number">3</span>][<span class="number">4</span>] = {<span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>};</span><br></pre></td></tr></tbody></table></figure><p>可以使用下标访问多维数组的元素，数组的每个维度对应一个下标运算符。如果表达式中下标运算符的数量和数组维度一样多，则表达式的结果是给定类型的元素。如果下标运算符数量比数组维度小，则表达式的结果是给定索引处的一个内层数组。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// assigns the first element of arr to the last element in the last row of ia</span></span><br><span class="line">ia[<span class="number">2</span>][<span class="number">3</span>] = arr[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"><span class="built_in">int</span> (&amp;row)[<span class="number">4</span>] = ia[<span class="number">1</span>];  <span class="comment">// binds row to the second four-element array in ia</span></span><br></pre></td></tr></tbody></table></figure><p>多维数组寻址公式：</p><p><img src="https://cdn.jsdelivr.net/gh/tlhg-0/blogimage/images/20200807121513.png" alt="3-10"></p><p>使用范围<code>for</code>语句处理多维数组时，为了避免数组被自动转换成指针，语句中的外层循环控制变量必须声明成引用类型。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;row : ia)  <span class="comment">// for every element in the outer array</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> col : row)    <span class="comment">// for every element in the inner array</span></span><br><span class="line">        cout &lt;&lt; col &lt;&lt; endl;</span><br></pre></td></tr></tbody></table></figure><p>如果<em>row</em>不是引用类型，编译器初始化<em>row</em>时会自动将数组形式的元素转换成指向该数组内首元素的指针，这样得到的<em>row</em>就是<code>int*</code>类型，而之后的内层循环则试图在一个<code>int*</code>内遍历，程序将无法通过编译。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> row : ia)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> col : row)</span><br></pre></td></tr></tbody></table></figure><p>使用范围<code>for</code>语句处理多维数组时，除了最内层的循环，其他所有外层循环的控制变量都应该定义成引用类型。</p><p>因为多维数组实际上是数组的数组，所以由多维数组名称转换得到的指针指向第一个内层数组。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> ia[<span class="number">3</span>][<span class="number">4</span>];       <span class="comment">// array of size 3; each element is an array of ints of size 4</span></span><br><span class="line"><span class="built_in">int</span> (*p)[<span class="number">4</span>] = ia;   <span class="comment">// p points to an array of four ints</span></span><br><span class="line">p = &amp;ia[<span class="number">2</span>];         <span class="comment">// p now points to the last element in ia</span></span><br></pre></td></tr></tbody></table></figure><p>声明指向数组类型的指针时，必须带有圆括号。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> *ip[<span class="number">4</span>];     <span class="comment">// array of pointers to int</span></span><br><span class="line"><span class="built_in">int</span> (*ip)[<span class="number">4</span>];   <span class="comment">// pointer to an array of four ints</span></span><br></pre></td></tr></tbody></table></figure><p>使用<code>auto</code>和<code>decltype</code>能省略复杂的指针定义。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// print the value of each element in ia, with each inner array on its own line</span></span><br><span class="line"><span class="comment">// p points to an array of four ints</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> p = ia; p != ia + <span class="number">3</span>; ++p)</span><br><span class="line">{</span><br><span class="line">    <span class="comment">// q points to the first element of an array of four ints; that is, q points to an int</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> q = *p; q != *p + <span class="number">4</span>; ++q)</span><br><span class="line">        cout &lt;&lt; *q &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>使用标准库函数<code>begin</code>和<code>end</code>能更加简洁</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// p points to the first array in ia</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> p = <span class="built_in">begin</span>(ia); p != <span class="built_in">end</span>(ia); ++p) {</span><br><span class="line"><span class="comment">// q points to the first element in an inner array</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> q = <span class="built_in">begin</span>(*p); q != <span class="built_in">end</span>(*p); ++q)</span><br><span class="line">cout &lt;&lt; *q &lt;&lt; <span class="string">' '</span>; <span class="comment">// prints the int value to which q</span></span><br><span class="line">points</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> language </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CVE-2019-6778</title>
      <link href="/posts/2b89.html"/>
      <url>/posts/2b89.html</url>
      
        <content type="html"><![CDATA[<h1 id="一切皆socket"><a class="markdownIt-Anchor" href="#一切皆socket"></a> 一切皆socket</h1><p>socket起源于UNIX,可以看出来socket完美的贴合了UNIX一切皆文件的编程思想.我们可以对socket描述符进行ORW的操作,类似普通文件.</p><p>在网络编程中,都是由socket实现的,在linux中,socket由上层的libc中的socket和内核中的socket两部分组成,当然为了和硬件交互,最后还需要控制网卡驱动,才是一个完整的体系.</p><p>这里我们可以进行一个完整流程的追踪,直接断在tcp_emu上.然后查看调用栈,回溯一下</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">#0  tcp_emu (so=0x7fffe0193ed0, m=0x7fffe0180e20) at /home/mozhucy/qemu-3.0.0/slirp/tcp_subr.c:617</span><br><span class="line">#1  0x0000555555bfc697 in tcp_input (m=0x7fffe0180e20, iphlen=20, inso=0x0, af=2) at /home/mozhucy/qemu-3.0.0/slirp/tcp_input.c:572</span><br><span class="line">#2  0x0000555555bf35c7 in ip_input (m=0x7fffe0180e20) at /home/mozhucy/qemu-3.0.0/slirp/ip_input.c:206</span><br><span class="line">#3  0x0000555555bf6a4a in slirp_input (slirp=0x55555680c500, pkt=0x7fffe02f2700 "RU\n", pkt_len=1334) at /home/mozhucy/qemu-3.0.0/slirp/slirp.c:874</span><br><span class="line">#4  0x0000555555bdf408 in net_slirp_receive (nc=0x55555680c350, buf=0x7fffe02f2700 "RU\n", size=1334) at /home/mozhucy/qemu-3.0.0/net/slirp.c:121</span><br><span class="line">#5  0x0000555555bd5117 in nc_sendv_compat (nc=0x55555680c350, iov=0x7fffeedc3310, iovcnt=1, flags=0) at /home/mozhucy/qemu-3.0.0/net/net.c:701</span><br><span class="line">#6  0x0000555555bd51d9 in qemu_deliver_packet_iov (sender=0x5555578b7d90, flags=0, iov=0x7fffeedc3310, iovcnt=1, opaque=0x55555680c350) at /home/mozhucy/qemu-3.0.0/net/net.c:728</span><br><span class="line">#7  0x0000555555bd7b08 in qemu_net_queue_deliver (queue=0x55555680c290, sender=0x5555578b7d90, flags=0, data=0x7fffe02f2700 "RU\n", size=1334) at /home/mozhucy/qemu-3.0.0/net/queue.c:164</span><br><span class="line">#8  0x0000555555bd7c24 in qemu_net_queue_send (queue=0x55555680c290, sender=0x5555578b7d90, flags=0, data=0x7fffe02f2700 "RU\n", size=1334, sent_cb=0x0) at /home/mozhucy/qemu-3.0.0/net/queue.c:199</span><br><span class="line">#9  0x0000555555bd4f7e in qemu_send_packet_async_with_flags (sender=0x5555578b7d90, flags=0, buf=0x7fffe02f2700 "RU\n", size=1334, sent_cb=0x0) at /home/mozhucy/qemu-3.0.0/net/net.c:655</span><br><span class="line">#10 0x0000555555bd4fb6 in qemu_send_packet_async (sender=0x5555578b7d90, buf=0x7fffe02f2700 "RU\n", size=1334, sent_cb=0x0) at /home/mozhucy/qemu-3.0.0/net/net.c:662</span><br><span class="line">#11 0x0000555555bd4fe3 in qemu_send_packet (nc=0x5555578b7d90, buf=0x7fffe02f2700 "RU\n", size=1334) at /home/mozhucy/qemu-3.0.0/net/net.c:668</span><br><span class="line">#12 0x0000555555aeb758 in rtl8139_transfer_frame (s=0x5555578b2d30, buf=0x7fffe02f2700 "RU\n", size=1334, do_interrupt=1, dot1q_buf=0x0) at /home/mozhucy/qemu-3.0.0/hw/net/rtl8139.c:1804</span><br><span class="line">#13 0x0000555555aecb73 in rtl8139_cplus_transmit_one (s=0x5555578b2d30) at /home/mozhucy/qemu-3.0.0/hw/net/rtl8139.c:2332</span><br><span class="line">#14 0x0000555555aecc31 in rtl8139_cplus_transmit (s=0x5555578b2d30) at /home/mozhucy/qemu-3.0.0/hw/net/rtl8139.c:2359</span><br><span class="line">#15 0x0000555555aed8a2 in rtl8139_io_writeb (opaque=0x5555578b2d30, addr=217 '\331', val=64) at /home/mozhucy/qemu-3.0.0/hw/net/rtl8139.c:2742</span><br><span class="line">#16 0x0000555555aee87f in rtl8139_ioport_write (opaque=0x5555578b2d30, addr=217, val=64, size=1) at /home/mozhucy/qemu-3.0.0/hw/net/rtl8139.c:3279</span><br><span class="line">#17 0x000055555585cbb6 in memory_region_write_accessor (mr=0x5555578b57c0, addr=217, value=0x7fffeedc37e8, size=1, shift=0, mask=255, attrs=...) at /home/mozhucy/qemu-3.0.0/memory.c:527</span><br><span class="line">#18 0x000055555585cdce in access_with_adjusted_size (addr=217, value=0x7fffeedc37e8, size=1, access_size_min=1, access_size_max=4, access_fn=0x55555585cacc &lt;memory_region_write_accessor&gt;, mr=0x5555578b57c0, attrs=...) at /home/mozhucy/qemu-3.0.0/memory.c:594</span><br><span class="line">#19 0x000055555585f9f6 in memory_region_dispatch_write (mr=0x5555578b57c0, addr=217, data=64, size=1, attrs=...) at /home/mozhucy/qemu-3.0.0/memory.c:1473</span><br><span class="line">#20 0x00005555557fba28 in flatview_write_continue (fv=0x7fffe017c000, addr=4273803481, attrs=..., buf=0x7ffff7ff0028 "@\020", len=1, addr1=217, l=1, mr=0x5555578b57c0) at /home/mozhucy/qemu-3.0.0/exec.c:3255</span><br><span class="line">#21 0x00005555557fbb72 in flatview_write (fv=0x7fffe017c000, addr=4273803481, attrs=..., buf=0x7ffff7ff0028 "@\020", len=1) at /home/mozhucy/qemu-3.0.0/exec.c:3294</span><br><span class="line">#22 0x00005555557fbe78 in address_space_write (as=0x5555566e6640 &lt;address_space_memory&gt;, addr=4273803481, attrs=..., buf=0x7ffff7ff0028 "@\020", len=1) at /home/mozhucy/qemu-3.0.0/exec.c:3384</span><br><span class="line">#23 0x00005555557fbec9 in address_space_rw (as=0x5555566e6640 &lt;address_space_memory&gt;, addr=4273803481, attrs=..., buf=0x7ffff7ff0028 "@\020", len=1, is_write=true) at /home/mozhucy/qemu-3.0.0/exec.c:3395</span><br><span class="line">#24 0x000055555587ac06 in kvm_cpu_exec (cpu=0x555556833070) at /home/mozhucy/qemu-3.0.0/accel/kvm/kvm-all.c:1979</span><br><span class="line">#25 0x0000555555841f35 in qemu_kvm_cpu_thread_fn (arg=0x555556833070) at /home/mozhucy/qemu-3.0.0/cpus.c:1215</span><br><span class="line">#26 0x0000555555d668d7 in qemu_thread_start (args=0x555556854b30) at /home/mozhucy/qemu-3.0.0/util/qemu-thread-posix.c:504</span><br><span class="line">#27 0x00007ffff62526ba in start_thread (arg=0x7fffeedc4700) at pthread_create.c:333</span><br><span class="line">#28 0x00007ffff5f8841d in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:109</span><br></pre></td></tr></tbody></table></figure><p>可以看到还是很多的调用流程,不过大概可以梳理出一个流程,28-24属于kvm/多CPU初始化的过程,23-17属于内存的处理过程,16-12属于网卡虚拟化内部的数据流处理流程,11-0属于qemu对于数据包的底层调用,也就是qemu网络的后端实现</p><p>There are two parts to networking within QEMU:</p><ul><li>the virtual network device that is provided to the guest (e.g. a PCI network card).</li><li>the network backend that interacts with the emulated NIC (e.g. puts packets onto the host’s network).</li></ul><p>slirp_input函数作为入口</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">net_slirp_receive</span><span class="params">(NetClientState *nc, <span class="type">const</span> <span class="type">uint8_t</span> *buf, <span class="type">size_t</span> size)</span></span><br><span class="line">{</span><br><span class="line">    SlirpState *s = DO_UPCAST(SlirpState, nc, nc);</span><br><span class="line"></span><br><span class="line">    slirp_input(s-&gt;slirp, buf, size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里是qemu调用slirp_input的地方,可以看到,传入参数为buf,size,还有Slirp结构体,其中buf为网络包的内容size为网络包的大小</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">slirp_input</span><span class="params">(Slirp *slirp, <span class="type">const</span> <span class="type">uint8_t</span> *pkt, <span class="type">int</span> pkt_len)</span></span><br><span class="line">{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">m</span>;</span></span><br><span class="line">    <span class="type">int</span> proto;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pkt_len &lt; ETH_HLEN)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    proto = ntohs(*(<span class="type">uint16_t</span> *)(pkt + <span class="number">12</span>));</span><br><span class="line">    <span class="keyword">switch</span>(proto) {</span><br><span class="line">    <span class="keyword">case</span> ETH_P_ARP:</span><br><span class="line">        arp_input(slirp, pkt, pkt_len);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ETH_P_IP:</span><br><span class="line">    <span class="keyword">case</span> ETH_P_IPV6:</span><br><span class="line">        m = m_get(slirp);</span><br><span class="line">        <span class="keyword">if</span> (!m)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">/* Note: we add 2 to align the IP header on 4 bytes,</span></span><br><span class="line"><span class="comment">         * and add the margin for the tcpiphdr overhead  */</span></span><br><span class="line">        <span class="keyword">if</span> (M_FREEROOM(m) &lt; pkt_len + TCPIPHDR_DELTA + <span class="number">2</span>) {</span><br><span class="line">            m_inc(m, pkt_len + TCPIPHDR_DELTA + <span class="number">2</span>);</span><br><span class="line">        }</span><br><span class="line">        m-&gt;m_len = pkt_len + TCPIPHDR_DELTA + <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>(m-&gt;m_data + TCPIPHDR_DELTA + <span class="number">2</span>, pkt, pkt_len);</span><br><span class="line"></span><br><span class="line">        m-&gt;m_data += TCPIPHDR_DELTA + <span class="number">2</span> + ETH_HLEN;</span><br><span class="line">        m-&gt;m_len -= TCPIPHDR_DELTA + <span class="number">2</span> + ETH_HLEN;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (proto == ETH_P_IP) {</span><br><span class="line">            ip_input(m);</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (proto == ETH_P_IPV6) {</span><br><span class="line">            ip6_input(m);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> ETH_P_NCSI:</span><br><span class="line">        ncsi_input(slirp, pkt, pkt_len);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>到达slirp_input函数后,libslirp开始解析网络包,首先验证packet_len和ETH_HLEN长度的大小,ETH_HLEN为以太帧头部的大小,两个6字节表示mac地址,两字节表示协议</p><p>判断后,取出以太帧传输的协议部分.开始进行数据的分发,这里分为四个case,三个处理块,分别为ARP协议IP协议和NCSI协议</p><p>在ip处理块中,计算了偏移,去除了ETH_HLEN,并且将待处理的值,放到m中</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> {</span></span><br><span class="line"><span class="comment">/* XXX should union some of these! */</span></span><br><span class="line"><span class="comment">/* header at beginning of each mbuf: */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span><span class="title">mbuf</span> *<span class="title">m_next</span>;</span><span class="comment">/* Linked list of mbufs */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span><span class="title">mbuf</span> *<span class="title">m_prev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span><span class="title">mbuf</span> *<span class="title">m_nextpkt</span>;</span><span class="comment">/* Next packet in queue/record */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span><span class="title">mbuf</span> *<span class="title">m_prevpkt</span>;</span><span class="comment">/* Flags aren't used in the output queue */</span></span><br><span class="line"><span class="type">int</span>m_flags;<span class="comment">/* Misc flags */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>m_size;<span class="comment">/* Size of mbuf, from m_dat or m_ext */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span><span class="title">socket</span> *<span class="title">m_so</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">caddr_t</span>m_data;<span class="comment">/* Current location of data */</span></span><br><span class="line"><span class="type">int</span>m_len;<span class="comment">/* Amount of data in this mbuf, from m_data */</span></span><br><span class="line"></span><br><span class="line">Slirp *slirp;</span><br><span class="line"><span class="type">bool</span>resolution_requested;</span><br><span class="line"><span class="type">uint64_t</span> expiration_date;</span><br><span class="line"><span class="type">char</span>   *m_ext;</span><br><span class="line"><span class="comment">/* start of dynamic buffer area, must be last element */</span></span><br><span class="line"><span class="type">char</span>    m_dat[];</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>可以看到mbuf是由一个双向链表所维护的,还包括了socket结构体,data指针和长度,最后将这个传入ip_input中</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">ip_input</span><span class="params">(<span class="keyword">struct</span> mbuf *m)</span></span><br><span class="line">{</span><br><span class="line">Slirp *slirp = m-&gt;slirp;<span class="comment">//取出slirp结构体</span></span><br><span class="line"><span class="keyword">register</span> <span class="class"><span class="keyword">struct</span> <span class="title">ip</span> *<span class="title">ip</span>;</span><span class="comment">//初始化ip结构体</span></span><br><span class="line"><span class="type">int</span> hlen;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!slirp-&gt;in_enabled) {</span><br><span class="line"><span class="keyword">goto</span> bad;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">DEBUG_CALL(<span class="string">"ip_input"</span>);</span><br><span class="line">DEBUG_ARG(<span class="string">"m = %p"</span>, m);</span><br><span class="line">DEBUG_ARG(<span class="string">"m_len = %d"</span>, m-&gt;m_len);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (m-&gt;m_len &lt; <span class="keyword">sizeof</span> (<span class="keyword">struct</span> ip)) { <span class="comment">//判断数据长度和ip结构体长度的关系</span></span><br><span class="line"><span class="keyword">goto</span> bad;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">ip = mtod(m, <span class="keyword">struct</span> ip *);<span class="comment">//给数据转换类型为ip</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ip-&gt;ip_v != IPVERSION) {<span class="comment">//检查是不是IPV4</span></span><br><span class="line"><span class="keyword">goto</span> bad;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">hlen = ip-&gt;ip_hl &lt;&lt; <span class="number">2</span>; <span class="comment">//计算头部ip长度</span></span><br><span class="line"><span class="keyword">if</span> (hlen&lt;<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ip ) || hlen&gt;m-&gt;m_len) {<span class="comment">/* min header length */</span></span><br><span class="line">  <span class="keyword">goto</span> bad;                                  <span class="comment">/* or packet too short */</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* keep ip header intact for ICMP reply</span></span><br><span class="line"><span class="comment"> * ip-&gt;ip_sum = cksum(m, hlen);</span></span><br><span class="line"><span class="comment"> * if (ip-&gt;ip_sum) {</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span>(cksum(m,hlen)) {<span class="comment">//计算校验和</span></span><br><span class="line">  <span class="keyword">goto</span> bad;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Convert fields to host representation.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">NTOHS(ip-&gt;ip_len);</span><br><span class="line"><span class="keyword">if</span> (ip-&gt;ip_len &lt; hlen) {</span><br><span class="line"><span class="keyword">goto</span> bad;</span><br><span class="line">}</span><br><span class="line">NTOHS(ip-&gt;ip_id);</span><br><span class="line">NTOHS(ip-&gt;ip_off);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Check that the amount of data in the buffers</span></span><br><span class="line"><span class="comment"> * is as at least much as the IP header would have us expect.</span></span><br><span class="line"><span class="comment"> * Trim mbufs if longer than we expect.</span></span><br><span class="line"><span class="comment"> * Drop packet if shorter than we expect.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (m-&gt;m_len &lt; ip-&gt;ip_len) {</span><br><span class="line"><span class="keyword">goto</span> bad;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Should drop packet if mbuf too long? hmmm... */</span></span><br><span class="line"><span class="keyword">if</span> (m-&gt;m_len &gt; ip-&gt;ip_len)</span><br><span class="line">   m_adj(m, ip-&gt;ip_len - m-&gt;m_len);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* check ip_ttl for a correct ICMP reply */</span></span><br><span class="line"><span class="keyword">if</span> (ip-&gt;ip_ttl == <span class="number">0</span>) {</span><br><span class="line">    icmp_send_error(m, ICMP_TIMXCEED, ICMP_TIMXCEED_INTRANS, <span class="number">0</span>, <span class="string">"ttl"</span>);</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If offset or IP_MF are set, must reassemble.</span></span><br><span class="line"><span class="comment"> * Otherwise, nothing need be done.</span></span><br><span class="line"><span class="comment"> * (We could look in the reassembly queue to see</span></span><br><span class="line"><span class="comment"> * if the packet was previously fragmented,</span></span><br><span class="line"><span class="comment"> * but it's not worth the time; just let them time out.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * XXX This should fail, don't fragment yet</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (ip-&gt;ip_off &amp;~ IP_DF) {<span class="comment">//IP分片处理</span></span><br><span class="line">  <span class="keyword">register</span> <span class="class"><span class="keyword">struct</span> <span class="title">ipq</span> *<span class="title">fp</span>;</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">qlink</span> *<span class="title">l</span>;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Look for queue of fragments</span></span><br><span class="line"><span class="comment"> * of this datagram.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">for</span> (l = slirp-&gt;ipq.ip_link.next; l != &amp;slirp-&gt;ipq.ip_link;</span><br><span class="line">     l = l-&gt;next) {</span><br><span class="line">            fp = container_of(l, <span class="keyword">struct</span> ipq, ip_link);</span><br><span class="line">            <span class="keyword">if</span> (ip-&gt;ip_id == fp-&gt;ipq_id &amp;&amp;</span><br><span class="line">                    ip-&gt;ip_src.s_addr == fp-&gt;ipq_src.s_addr &amp;&amp;</span><br><span class="line">                    ip-&gt;ip_dst.s_addr == fp-&gt;ipq_dst.s_addr &amp;&amp;</span><br><span class="line">                    ip-&gt;ip_p == fp-&gt;ipq_p)</span><br><span class="line">    <span class="keyword">goto</span> found;</span><br><span class="line">        }</span><br><span class="line">        fp = <span class="literal">NULL</span>;</span><br><span class="line">found:</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Adjust ip_len to not reflect header,</span></span><br><span class="line"><span class="comment"> * set ip_mff if more fragments are expected,</span></span><br><span class="line"><span class="comment"> * convert offset of this to bytes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ip-&gt;ip_len -= hlen;</span><br><span class="line"><span class="keyword">if</span> (ip-&gt;ip_off &amp; IP_MF)</span><br><span class="line">  ip-&gt;ip_tos |= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  ip-&gt;ip_tos &amp;= ~<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">ip-&gt;ip_off &lt;&lt;= <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * If datagram marked as having more fragments</span></span><br><span class="line"><span class="comment"> * or if this is not the first fragment,</span></span><br><span class="line"><span class="comment"> * attempt reassembly; if it succeeds, proceed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (ip-&gt;ip_tos &amp; <span class="number">1</span> || ip-&gt;ip_off) {</span><br><span class="line">ip = ip_reass(slirp, ip, fp);</span><br><span class="line">                        <span class="keyword">if</span> (ip == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">m = dtom(slirp, ip);</span><br><span class="line">} <span class="keyword">else</span></span><br><span class="line"><span class="keyword">if</span> (fp)</span><br><span class="line">      ip_freef(slirp, fp);</span><br><span class="line"></span><br><span class="line">} <span class="keyword">else</span></span><br><span class="line">ip-&gt;ip_len -= hlen;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Switch out to protocol's input routine.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">switch</span> (ip-&gt;ip_p) { <span class="comment">//选择协议模拟</span></span><br><span class="line"> <span class="keyword">case</span> IPPROTO_TCP:</span><br><span class="line">tcp_input(m, hlen, (<span class="keyword">struct</span> socket *)<span class="literal">NULL</span>, AF_INET);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">case</span> IPPROTO_UDP:</span><br><span class="line">udp_input(m, hlen);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">case</span> IPPROTO_ICMP:</span><br><span class="line">icmp_input(m, hlen);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">default</span>:</span><br><span class="line">m_free(m);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">bad:</span><br><span class="line">m_free(m);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以看到这里是对数据包的检测以及分段的模拟等,随后进入到协议模拟</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
